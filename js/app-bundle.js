/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	window.$ = window.jQuery = __webpack_require__(1);
	__webpack_require__(2);
	var Tone = __webpack_require__(3);
	var Instrument  = __webpack_require__(4);
	var sampleSet = __webpack_require__(13);
	var async = __webpack_require__(14);
	var loadSequencer = __webpack_require__(15);
	var ui = __webpack_require__(16);
	var decoder = __webpack_require__(18);
	var g = __webpack_require__(12);
	    
	//Define the nx.onload callback
	nx.onload = ui.nexusSetting;

	//Load start motion display
	ui.mainDisplayAnimation();

	//create the instrument (async loading audio samples)
	g.setInstru(new Instrument(sampleSet["Bulldog"]));

	//change the track names in the interface
	ui.displayTrackNames(g.getInstru());

	//load search handlers
	ui.loadSearchHandlers();

	//Load sequencer only when nexus UI has loaded
	if (g.getNexus()){
	    loadSequencer(g.getInstru());
	    ui.loadPlayButtonHandler();
	}

	// Fetch user location + weather then connect fx if successful
	async.getUserLatLong().then(function(userLatLong){
	    
	    async.getPosition(userLatLong);
	    
	    async.getWeather(userLatLong).then(function(weather){
	        
	        g.getInstru().connectFX(weather);
	        
	        if (g.getNexus()){
	            ui.dialAnimationLauncher(weather);
	        };
	        
	    });
	});

	//load google library Autocomplete
	var input = document.getElementById('searchTextField');
	var options = { types: ["(cities)"] };
	var autocomplete = new google.maps.places.Autocomplete(input,options);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v2.1.4
	 * http://jquery.com/
	 *
	 * Includes Sizzle.js
	 * http://sizzlejs.com/
	 *
	 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2015-04-28T16:01Z
	 */

	(function( global, factory ) {

		if ( typeof module === "object" && typeof module.exports === "object" ) {
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//

	var arr = [];

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};



	var
		// Use the correct document accordingly with window argument (sandbox)
		document = window.document,

		version = "2.1.4",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android<4.1
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([\da-z])/gi,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {
		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
			return num != null ?

				// Return just the one element from the set
				( num < 0 ? this[ num + this.length ] : this[ num ] ) :

				// Return all the elements in a clean array
				slice.call( this );
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		// (You can seed the arguments with an array of args, but this is
		// only used internally.)
		each: function( callback, args ) {
			return jQuery.each( this, callback, args );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map(this, function( elem, i ) {
				return callback.call( elem, i, elem );
			}));
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor(null);
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray(src) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {
			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
		},

		isPlainObject: function( obj ) {
			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
				return false;
			}

			if ( obj.constructor &&
					!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
				return false;
			}

			// If the function hasn't returned already, we're confident that
			// |obj| is a plain object, created by {} or constructed with new Object
			return true;
		},

		isEmptyObject: function( obj ) {
			var name;
			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}
			// Support: Android<4.0, iOS<6 (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call(obj) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			var script,
				indirect = eval;

			code = jQuery.trim( code );

			if ( code ) {
				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if ( code.indexOf("use strict") === 1 ) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild( script ).parentNode.removeChild( script );
				} else {
				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval
					indirect( code );
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		// args is for internal usage only
		each: function( obj, callback, args ) {
			var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike( obj );

			if ( args ) {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.apply( obj[ i ], args );

						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.apply( obj[ i ], args );

						if ( value === false ) {
							break;
						}
					}
				}

			// A special, fast, case for the most common use of each
			} else {
				if ( isArray ) {
					for ( ; i < length; i++ ) {
						value = callback.call( obj[ i ], i, obj[ i ] );

						if ( value === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						value = callback.call( obj[ i ], i, obj[ i ] );

						if ( value === false ) {
							break;
						}
					}
				}
			}

			return obj;
		},

		// Support: Android<4.1
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArraylike( Object(arr) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var value,
				i = 0,
				length = elems.length,
				isArray = isArraylike( elems ),
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	});

	function isArraylike( obj ) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.nodeType === 1 && length ) {
			return true;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.2.0-pre
	 * http://sizzlejs.com/
	 *
	 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2014-12-16
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// General-purpose constants
		MAX_NEGATIVE = 1 << 31,

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
		// http://www.w3.org/TR/css3-syntax/#characters
		characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

		// Loosely modeled on CSS identifier characters
		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = characterEncoding.replace( "w", "w#" ),

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + characterEncoding + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + characterEncoding + ")" ),
			"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
			"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,
		rescape = /'|\\/g,

		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		};

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}

		context = context || document;
		results = results || [];
		nodeType = context.nodeType;

		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		if ( !seed && documentIsHTML ) {

			// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
				// Speed-up: Sizzle("#ID")
				if ( (m = match[1]) ) {
					if ( nodeType === 9 ) {
						elem = context.getElementById( m );
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document (jQuery #6963)
						if ( elem && elem.parentNode ) {
							// Handle the case where IE, Opera, and Webkit return items
							// by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
					} else {
						// Context is not a document
						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
							contains( context, elem ) && elem.id === m ) {
							results.push( elem );
							return results;
						}
					}

				// Speed-up: Sizzle("TAG")
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Speed-up: Sizzle(".CLASS")
				} else if ( (m = match[3]) && support.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// QSA path
			if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				nid = old = expando;
				newContext = context;
				newSelector = nodeType !== 1 && selector;

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );

					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";

					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + toSelector( groups[i] );
					}
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
					newSelector = groups.join(",");
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");

		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = attrs.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, parent,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// If no document and documentElement is available, return
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Set our document
		document = doc;
		docElem = doc.documentElement;
		parent = doc.defaultView;

		// Support: IE>8
		// If iframe document is assigned to "document" variable and if iframe has been reloaded,
		// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
		// IE6-8 do not support the defaultView property so parent will be undefined
		if ( parent && parent !== parent.top ) {
			// IE11 does not have attachEvent, so all must suffer
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", unloadHandler, false );
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Support tests
		---------------------------------------------------------------------- */
		documentIsHTML = !isXML( doc );

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( doc.createComment("") );
			return !div.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
		});

		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];

			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\f]' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
				if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibing-combinator selector` fails
				if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = doc.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully does not implement inclusive descendent
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === doc ? -1 :
					b === doc ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return doc;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, outerCache, node, diff, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || (parent[ expando ] = {});
								cache = outerCache[ type ] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							// Use previously-cached element index if available
							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
								diff = cache[1];

							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
										// Cache the index of each encountered element
										if ( useCache ) {
											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},

			"disabled": function( elem ) {
				return elem.disabled === true;
			},

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
							if ( (oldCache = outerCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								outerCache[ dir ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context !== document && context;
				}

				// Add elements passing elementMatchers directly to results
				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// Apply set filters to unmatched elements
				matchedCount += i;
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is no seed and only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;



	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				/* jshint -W018 */
				return !!qualifier.call( elem, i, elem ) !== not;
			});

		}

		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			});

		}

		if ( typeof qualifier === "string" ) {
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			qualifier = jQuery.filter( qualifier, elements );
		}

		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
		});
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			}));
	};

	jQuery.fn.extend({
		find: function( selector ) {
			var i,
				len = this.length,
				ret = [],
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter(function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				}) );
			}

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow(this, selector || [], false) );
		},
		not: function( selector ) {
			return this.pushStack( winnow(this, selector || [], true) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	});


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

		init = jQuery.fn.init = function( selector, context ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && (match[1] || !context) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[1] ) {
						context = context instanceof jQuery ? context[0] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[1],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[2] );

						// Support: Blackberry 4.6
						// gEBID returns nodes no longer in the document (#6963)
						if ( elem && elem.parentNode ) {
							// Inject the element directly into the jQuery object
							this.length = 1;
							this[0] = elem;
						}

						this.context = document;
						this.selector = selector;
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || rootjQuery ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this.context = this[0] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return typeof rootjQuery.ready !== "undefined" ?
					rootjQuery.ready( selector ) :
					// Execute immediately if ready is not present
					selector( jQuery );
			}

			if ( selector.selector !== undefined ) {
				this.selector = selector.selector;
				this.context = selector.context;
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.extend({
		dir: function( elem, dir, until ) {
			var matched = [],
				truncate = until !== undefined;

			while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
				if ( elem.nodeType === 1 ) {
					if ( truncate && jQuery( elem ).is( until ) ) {
						break;
					}
					matched.push( elem );
				}
			}
			return matched;
		},

		sibling: function( n, elem ) {
			var matched = [];

			for ( ; n; n = n.nextSibling ) {
				if ( n.nodeType === 1 && n !== elem ) {
					matched.push( n );
				}
			}

			return matched;
		}
	});

	jQuery.fn.extend({
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter(function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[i] ) ) {
						return true;
					}
				}
			});
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
					jQuery( selectors, context || this.context ) :
					0;

			for ( ; i < l; i++ ) {
				for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
					// Always skip document fragments
					if ( cur.nodeType < 11 && (pos ?
						pos.index(cur) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector(cur, selectors)) ) {

						matched.push( cur );
						break;
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.unique(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter(selector)
			);
		}
	});

	function sibling( cur, dir ) {
		while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each({
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return jQuery.dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return jQuery.dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return jQuery.dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return jQuery.dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return jQuery.sibling( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.unique( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	});
	var rnotwhite = (/\S+/g);



	// String to Object options format cache
	var optionsCache = {};

	// Convert String-formatted options into Object-formatted ones and store in cache
	function createOptions( options ) {
		var object = optionsCache[ options ] = {};
		jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		});
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			( optionsCache[ options ] || createOptions( options ) ) :
			jQuery.extend( {}, options );

		var // Last fire value (for non-forgettable lists)
			memory,
			// Flag to know if list was already fired
			fired,
			// Flag to know if list is currently firing
			firing,
			// First callback to fire (used internally by add and fireWith)
			firingStart,
			// End of the loop when firing
			firingLength,
			// Index of currently firing callback (modified by remove if needed)
			firingIndex,
			// Actual callback list
			list = [],
			// Stack of fire calls for repeatable lists
			stack = !options.once && [],
			// Fire callbacks
			fire = function( data ) {
				memory = options.memory && data;
				fired = true;
				firingIndex = firingStart || 0;
				firingStart = 0;
				firingLength = list.length;
				firing = true;
				for ( ; list && firingIndex < firingLength; firingIndex++ ) {
					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
						memory = false; // To prevent further calls using add
						break;
					}
				}
				firing = false;
				if ( list ) {
					if ( stack ) {
						if ( stack.length ) {
							fire( stack.shift() );
						}
					} else if ( memory ) {
						list = [];
					} else {
						self.disable();
					}
				}
			},
			// Actual Callbacks object
			self = {
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
						// First, we save the current length
						var start = list.length;
						(function add( args ) {
							jQuery.each( args, function( _, arg ) {
								var type = jQuery.type( arg );
								if ( type === "function" ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && type !== "string" ) {
									// Inspect recursively
									add( arg );
								}
							});
						})( arguments );
						// Do we need to add the callbacks to the
						// current firing batch?
						if ( firing ) {
							firingLength = list.length;
						// With memory, if we're not firing then
						// we should call right away
						} else if ( memory ) {
							firingStart = start;
							fire( memory );
						}
					}
					return this;
				},
				// Remove a callback from the list
				remove: function() {
					if ( list ) {
						jQuery.each( arguments, function( _, arg ) {
							var index;
							while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
								list.splice( index, 1 );
								// Handle firing indexes
								if ( firing ) {
									if ( index <= firingLength ) {
										firingLength--;
									}
									if ( index <= firingIndex ) {
										firingIndex--;
									}
								}
							}
						});
					}
					return this;
				},
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
				},
				// Remove all callbacks from the list
				empty: function() {
					list = [];
					firingLength = 0;
					return this;
				},
				// Have the list do nothing anymore
				disable: function() {
					list = stack = memory = undefined;
					return this;
				},
				// Is it disabled?
				disabled: function() {
					return !list;
				},
				// Lock the list in its current state
				lock: function() {
					stack = undefined;
					if ( !memory ) {
						self.disable();
					}
					return this;
				},
				// Is it locked?
				locked: function() {
					return !stack;
				},
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( list && ( !fired || stack ) ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						if ( firing ) {
							stack.push( args );
						} else {
							fire( args );
						}
					}
					return this;
				},
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	jQuery.extend({

		Deferred: function( func ) {
			var tuples = [
					// action, add listener, listener list, final state
					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
					[ "notify", "progress", jQuery.Callbacks("memory") ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					then: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
						return jQuery.Deferred(function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {
								var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
								// deferred[ done | fail | progress ] for forwarding actions to newDefer
								deferred[ tuple[1] ](function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
									}
								});
							});
							fns = null;
						}).promise();
					},
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 3 ];

				// promise[ done | fail | progress ] = list.add
				promise[ tuple[1] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(function() {
						// state = [ resolved | rejected ]
						state = stateString;

					// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
				}

				// deferred[ resolve | reject | notify ]
				deferred[ tuple[0] ] = function() {
					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
					return this;
				};
				deferred[ tuple[0] + "With" ] = list.fireWith;
			});

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( subordinate /* , ..., subordinateN */ ) {
			var i = 0,
				resolveValues = slice.call( arguments ),
				length = resolveValues.length,

				// the count of uncompleted subordinates
				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

				// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

				// Update function for both resolve and progress values
				updateFunc = function( i, contexts, values ) {
					return function( value ) {
						contexts[ i ] = this;
						values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( values === progressValues ) {
							deferred.notifyWith( contexts, values );
						} else if ( !( --remaining ) ) {
							deferred.resolveWith( contexts, values );
						}
					};
				},

				progressValues, progressContexts, resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if ( length > 1 ) {
				progressValues = new Array( length );
				progressContexts = new Array( length );
				resolveContexts = new Array( length );
				for ( ; i < length; i++ ) {
					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
						resolveValues[ i ].promise()
							.done( updateFunc( i, resolveContexts, resolveValues ) )
							.fail( deferred.reject )
							.progress( updateFunc( i, progressContexts, progressValues ) );
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if ( !remaining ) {
				deferred.resolveWith( resolveContexts, resolveValues );
			}

			return deferred.promise();
		}
	});


	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	};

	jQuery.extend({
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.triggerHandler ) {
				jQuery( document ).triggerHandler( "ready" );
				jQuery( document ).off( "ready" );
			}
		}
	});

	/**
	 * The ready event handler and self cleanup method
	 */
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );
		jQuery.ready();
	}

	jQuery.ready.promise = function( obj ) {
		if ( !readyList ) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called after the browser event has already occurred.
			// We once tried to use readyState "interactive" here, but it caused issues like the one
			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
			if ( document.readyState === "complete" ) {
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed, false );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed, false );
			}
		}
		return readyList.promise( obj );
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				len ? fn( elems[0], key ) : emptyGet;
	};


	/**
	 * Determines whether an object can have data
	 */
	jQuery.acceptData = function( owner ) {
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};


	function Data() {
		// Support: Android<4,
		// Old WebKit does not have Object.preventExtensions/freeze method,
		// return new empty object instead with no [[set]] accessor
		Object.defineProperty( this.cache = {}, 0, {
			get: function() {
				return {};
			}
		});

		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;
	Data.accepts = jQuery.acceptData;

	Data.prototype = {
		key: function( owner ) {
			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return the key for a frozen object.
			if ( !Data.accepts( owner ) ) {
				return 0;
			}

			var descriptor = {},
				// Check if the owner object already has a cache key
				unlock = owner[ this.expando ];

			// If not, create one
			if ( !unlock ) {
				unlock = Data.uid++;

				// Secure it in a non-enumerable, non-writable property
				try {
					descriptor[ this.expando ] = { value: unlock };
					Object.defineProperties( owner, descriptor );

				// Support: Android<4
				// Fallback to a less secure definition
				} catch ( e ) {
					descriptor[ this.expando ] = unlock;
					jQuery.extend( owner, descriptor );
				}
			}

			// Ensure the cache object
			if ( !this.cache[ unlock ] ) {
				this.cache[ unlock ] = {};
			}

			return unlock;
		},
		set: function( owner, data, value ) {
			var prop,
				// There may be an unlock assigned to this node,
				// if there is no entry for this "owner", create one inline
				// and set the unlock as though an owner entry had always existed
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];

			// Handle: [ owner, key, value ] args
			if ( typeof data === "string" ) {
				cache[ data ] = value;

			// Handle: [ owner, { properties } ] args
			} else {
				// Fresh assignments by object are shallow copied
				if ( jQuery.isEmptyObject( cache ) ) {
					jQuery.extend( this.cache[ unlock ], data );
				// Otherwise, copy the properties one-by-one to the cache object
				} else {
					for ( prop in data ) {
						cache[ prop ] = data[ prop ];
					}
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			// Either a valid cache is found, or will be created.
			// New caches will be created and the unlock returned,
			// allowing direct access to the newly created
			// empty data object. A valid owner object must be provided.
			var cache = this.cache[ this.key( owner ) ];

			return key === undefined ?
				cache : cache[ key ];
		},
		access: function( owner, key, value ) {
			var stored;
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					((key && typeof key === "string") && value === undefined) ) {

				stored = this.get( owner, key );

				return stored !== undefined ?
					stored : this.get( owner, jQuery.camelCase(key) );
			}

			// [*]When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i, name, camel,
				unlock = this.key( owner ),
				cache = this.cache[ unlock ];

			if ( key === undefined ) {
				this.cache[ unlock ] = {};

			} else {
				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {
					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat( key.map( jQuery.camelCase ) );
				} else {
					camel = jQuery.camelCase( key );
					// Try the string as a key before any manipulation
					if ( key in cache ) {
						name = [ key, camel ];
					} else {
						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ?
							[ name ] : ( name.match( rnotwhite ) || [] );
					}
				}

				i = name.length;
				while ( i-- ) {
					delete cache[ name[ i ] ];
				}
			}
		},
		hasData: function( owner ) {
			return !jQuery.isEmptyObject(
				this.cache[ owner[ this.expando ] ] || {}
			);
		},
		discard: function( owner ) {
			if ( owner[ this.expando ] ) {
				delete this.cache[ owner[ this.expando ] ];
			}
		}
	};
	var data_priv = new Data();

	var data_user = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /([A-Z])/g;

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = data === "true" ? true :
						data === "false" ? false :
						data === "null" ? null :
						// Only convert to a number if it doesn't change the string
						+data + "" === data ? +data :
						rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
				} catch( e ) {}

				// Make sure we set the data so it isn't changed later
				data_user.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function( elem ) {
			return data_user.hasData( elem ) || data_priv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return data_user.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			data_user.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to data_priv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return data_priv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			data_priv.remove( elem, name );
		}
	});

	jQuery.fn.extend({
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = data_user.get( elem );

					if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice(5) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						data_priv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each(function() {
					data_user.set( this, key );
				});
			}

			return access( this, function( value ) {
				var data,
					camelKey = jQuery.camelCase( key );

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
					// Attempt to get data from the cache
					// with the key as-is
					data = data_user.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to get data from the cache
					// with the key camelized
					data = data_user.get( elem, camelKey );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, camelKey, undefined );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each(function() {
					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = data_user.get( this, camelKey );

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					data_user.set( this, camelKey, value );

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if ( key.indexOf("-") !== -1 && data !== undefined ) {
						data_user.set( this, key, value );
					}
				});
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each(function() {
				data_user.remove( this, key );
			});
		}
	});


	jQuery.extend({
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = data_priv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = data_priv.access( elem, type, jQuery.makeArray(data) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return data_priv.get( elem, key ) || data_priv.access( elem, key, {
				empty: jQuery.Callbacks("once memory").add(function() {
					data_priv.remove( elem, [ type + "queue", key ] );
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[0], type );
			}

			return data === undefined ?
				this :
				this.each(function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[0] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				});
		},
		dequeue: function( type ) {
			return this.each(function() {
				jQuery.dequeue( this, type );
			});
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = data_priv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	});
	var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHidden = function( elem, el ) {
			// isHidden might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
			return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
		};

	var rcheckableType = (/^(?:checkbox|radio)$/i);



	(function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Safari<=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Safari<=5.1, Android<4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE<=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	})();
	var strundefined = typeof undefined;



	support.focusinBubbles = "onfocusin" in window;


	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !(events = elemData.events) ) {
				events = elemData.events = {};
			}
			if ( !(eventHandle = elemData.handle) ) {
				eventHandle = elemData.handle = function( e ) {
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join(".")
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !(handlers = events[ type ]) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle, false );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = data_priv.hasData( elem ) && data_priv.get( elem );

			if ( !elemData || !(events = elemData.events) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnotwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[t] ) || [];
				type = origType = tmp[1];
				namespaces = ( tmp[2] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				delete elemData.handle;
				data_priv.remove( elem, "events" );
			}
		},

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf(".") >= 0 ) {
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.namespace_re = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === (elem.ownerDocument || document) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
					jQuery.acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		dispatch: function( event ) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( event );

			var i, j, ret, matched, handleObj,
				handlerQueue = [],
				args = slice.call( arguments ),
				handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
								.apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( (event.result = ret) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, matches, sel, handleObj,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			// Black-hole SVG <use> instance trees (#13180)
			// Avoid non-left-click bubbling in Firefox (#3861)
			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.disabled !== true || event.type !== "click" ) {
						matches = [];
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matches[ sel ] === undefined ) {
								matches[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) >= 0 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matches[ sel ] ) {
								matches.push( handleObj );
							}
						}
						if ( matches.length ) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if ( delegateCount < handlers.length ) {
				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function( event, original ) {

				// Add which for key events
				if ( event.which == null ) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function( event, original ) {
				var eventDoc, doc, body,
					button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if ( event.pageX == null && original.clientX != null ) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if ( !event.which && button !== undefined ) {
					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
				}

				return event;
			}
		},

		fix: function( event ) {
			if ( event[ jQuery.expando ] ) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i, prop, copy,
				type = event.type,
				originalEvent = event,
				fixHook = this.fixHooks[ type ];

			if ( !fixHook ) {
				this.fixHooks[ type ] = fixHook =
					rmouseEvent.test( type ) ? this.mouseHooks :
					rkeyEvent.test( type ) ? this.keyHooks :
					{};
			}
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

			event = new jQuery.Event( originalEvent );

			i = copy.length;
			while ( i-- ) {
				prop = copy[ i ];
				event[ prop ] = originalEvent[ prop ];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if ( !event.target ) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome<28
			// Target should not be a text node (#504, #13143)
			if ( event.target.nodeType === 3 ) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
		},

		special: {
			load: {
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {
				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {
				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		},

		simulate: function( type, elem, event, bubble ) {
			// Piggyback on a donor event to simulate a different one.
			// Fake originalEvent to avoid donor's stopPropagation, but if the
			// simulated event prevents default then we do the same on the donor.
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true,
					originalEvent: {}
				}
			);
			if ( bubble ) {
				jQuery.event.trigger( e, null, elem );
			} else {
				jQuery.event.dispatch.call( elem, e );
			}
			if ( e.isDefaultPrevented() ) {
				event.preventDefault();
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	};

	jQuery.Event = function( src, props ) {
		// Allow instantiation without the 'new' keyword
		if ( !(this instanceof jQuery.Event) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
					// Support: Android<4.0
					src.returnValue === false ?
				returnTrue :
				returnFalse;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && e.preventDefault ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && e.stopPropagation ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && e.stopImmediatePropagation ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// Support: Chrome 15+
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mousenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	});

	// Support: Firefox, Chrome, Safari
	// Create "bubbling" focus and blur events
	if ( !support.focusinBubbles ) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
				};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = data_priv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						data_priv.remove( doc, fix );

					} else {
						data_priv.access( doc, fix, attaches );
					}
				}
			};
		});
	}

	jQuery.fn.extend({

		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
			var origFn, type;

			// Types can be a map of types/handlers
			if ( typeof types === "object" ) {
				// ( types-Object, selector, data )
				if ( typeof selector !== "string" ) {
					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for ( type in types ) {
					this.on( type, selector, data, types[ type ], one );
				}
				return this;
			}

			if ( data == null && fn == null ) {
				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if ( fn == null ) {
				if ( typeof selector === "string" ) {
					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {
					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if ( fn === false ) {
				fn = returnFalse;
			} else if ( !fn ) {
				return this;
			}

			if ( one === 1 ) {
				origFn = fn;
				fn = function( event ) {
					// Can use an empty set, since event contains the info
					jQuery().off( event );
					return origFn.apply( this, arguments );
				};
				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
			}
			return this.each( function() {
				jQuery.event.add( this, types, fn, data, selector );
			});
		},
		one: function( types, selector, data, fn ) {
			return this.on( types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each(function() {
				jQuery.event.remove( this, types, fn, selector );
			});
		},

		trigger: function( type, data ) {
			return this.each(function() {
				jQuery.event.trigger( type, data, this );
			});
		},
		triggerHandler: function( type, data ) {
			var elem = this[0];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	});


	var
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
		rtagName = /<([\w:]+)/,
		rhtml = /<|&#?\w+;/,
		rnoInnerhtml = /<(?:script|style|link)/i,
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptType = /^$|\/(?:java|ecma)script/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

		// We have to close these tags to support XHTML (#13200)
		wrapMap = {

			// Support: IE9
			option: [ 1, "<select multiple='multiple'>", "</select>" ],

			thead: [ 1, "<table>", "</table>" ],
			col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

			_default: [ 0, "", "" ]
		};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	// Support: 1.x compatibility
	// Manipulating tables requires a tbody
	function manipulationTarget( elem, content ) {
		return jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

			elem.getElementsByTagName("tbody")[0] ||
				elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
			elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			data_priv.set(
				elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
			);
		}
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( data_priv.hasData( src ) ) {
			pdataOld = data_priv.access( src );
			pdataCur = data_priv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( data_user.hasData( src ) ) {
			udataOld = data_user.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			data_user.set( dest, udataCur );
		}
	}

	function getAll( context, tag ) {
		var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
				context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
				[];

		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
			jQuery.merge( [ context ], ret ) :
			ret;
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	jQuery.extend({
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		buildFragment: function( elems, context, scripts, selection ) {
			var elem, tmp, tag, wrap, contains, j,
				fragment = context.createDocumentFragment(),
				nodes = [],
				i = 0,
				l = elems.length;

			for ( ; i < l; i++ ) {
				elem = elems[ i ];

				if ( elem || elem === 0 ) {

					// Add nodes directly
					if ( jQuery.type( elem ) === "object" ) {
						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

					// Convert non-html into a text node
					} else if ( !rhtml.test( elem ) ) {
						nodes.push( context.createTextNode( elem ) );

					// Convert html into DOM nodes
					} else {
						tmp = tmp || fragment.appendChild( context.createElement("div") );

						// Deserialize a standard representation
						tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
						wrap = wrapMap[ tag ] || wrapMap._default;
						tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

						// Descend through wrappers to the right content
						j = wrap[ 0 ];
						while ( j-- ) {
							tmp = tmp.lastChild;
						}

						// Support: QtWebKit, PhantomJS
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, tmp.childNodes );

						// Remember the top-level container
						tmp = fragment.firstChild;

						// Ensure the created nodes are orphaned (#12392)
						tmp.textContent = "";
					}
				}
			}

			// Remove wrapper from fragment
			fragment.textContent = "";

			i = 0;
			while ( (elem = nodes[ i++ ]) ) {

				// #4087 - If origin and destination elements are the same, and this is
				// that element, do not do anything
				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
					continue;
				}

				contains = jQuery.contains( elem.ownerDocument, elem );

				// Append to fragment
				tmp = getAll( fragment.appendChild( elem ), "script" );

				// Preserve script evaluation history
				if ( contains ) {
					setGlobalEval( tmp );
				}

				// Capture executables
				if ( scripts ) {
					j = 0;
					while ( (elem = tmp[ j++ ]) ) {
						if ( rscriptType.test( elem.type || "" ) ) {
							scripts.push( elem );
						}
					}
				}
			}

			return fragment;
		},

		cleanData: function( elems ) {
			var data, elem, type, key,
				special = jQuery.event.special,
				i = 0;

			for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
				if ( jQuery.acceptData( elem ) ) {
					key = elem[ data_priv.expando ];

					if ( key && (data = data_priv.cache[ key ]) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
						if ( data_priv.cache[ key ] ) {
							// Discard any remaining `private` data
							delete data_priv.cache[ key ];
						}
					}
				}
				// Discard any remaining `user` data
				delete data_user.cache[ elem[ data_user.expando ] ];
			}
		}
	});

	jQuery.fn.extend({
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each(function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					});
			}, null, value, arguments.length );
		},

		append: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			});
		},

		prepend: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			});
		},

		before: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			});
		},

		after: function() {
			return this.domManip( arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			});
		},

		remove: function( selector, keepData /* Internal Use Only */ ) {
			var elem,
				elems = selector ? jQuery.filter( selector, this ) : this,
				i = 0;

			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( getAll( elem ) );
				}

				if ( elem.parentNode ) {
					if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
						setGlobalEval( getAll( elem, "script" ) );
					}
					elem.parentNode.removeChild( elem );
				}
			}

			return this;
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; (elem = this[i]) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			});
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = value.replace( rxhtmlTag, "<$1></$2>" );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var arg = arguments[ 0 ];

			// Make the changes, replacing each context element with the new content
			this.domManip( arguments, function( elem ) {
				arg = this.parentNode;

				jQuery.cleanData( getAll( this ) );

				if ( arg ) {
					arg.replaceChild( elem, this );
				}
			});

			// Force removal if there was no new content (e.g., from empty arguments)
			return arg && (arg.length || arg.nodeType) ? this : this.remove();
		},

		detach: function( selector ) {
			return this.remove( selector, true );
		},

		domManip: function( args, callback ) {

			// Flatten any nested arrays
			args = concat.apply( [], args );

			var fragment, first, scripts, hasScripts, node, doc,
				i = 0,
				l = this.length,
				set = this,
				iNoClone = l - 1,
				value = args[ 0 ],
				isFunction = jQuery.isFunction( value );

			// We can't cloneNode fragments that contain checked, in WebKit
			if ( isFunction ||
					( l > 1 && typeof value === "string" &&
						!support.checkClone && rchecked.test( value ) ) ) {
				return this.each(function( index ) {
					var self = set.eq( index );
					if ( isFunction ) {
						args[ 0 ] = value.call( this, index, self.html() );
					}
					self.domManip( args, callback );
				});
			}

			if ( l ) {
				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
				first = fragment.firstChild;

				if ( fragment.childNodes.length === 1 ) {
					fragment = first;
				}

				if ( first ) {
					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
					hasScripts = scripts.length;

					// Use the original fragment for the last item instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for ( ; i < l; i++ ) {
						node = fragment;

						if ( i !== iNoClone ) {
							node = jQuery.clone( node, true, true );

							// Keep references to cloned scripts for later restoration
							if ( hasScripts ) {
								// Support: QtWebKit
								// jQuery.merge because push.apply(_, arraylike) throws
								jQuery.merge( scripts, getAll( node, "script" ) );
							}
						}

						callback.call( this[ i ], node, i );
					}

					if ( hasScripts ) {
						doc = scripts[ scripts.length - 1 ].ownerDocument;

						// Reenable scripts
						jQuery.map( scripts, restoreScript );

						// Evaluate executable scripts on first document insertion
						for ( i = 0; i < hasScripts; i++ ) {
							node = scripts[ i ];
							if ( rscriptType.test( node.type || "" ) &&
								!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

								if ( node.src ) {
									// Optional AJAX dependency, but won't run scripts if not present
									if ( jQuery._evalUrl ) {
										jQuery._evalUrl( node.src );
									}
								} else {
									jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
								}
							}
						}
					}
				}
			}

			return this;
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	});


	var iframe,
		elemdisplay = {};

	/**
	 * Retrieve the actual display of a element
	 * @param {String} name nodeName of the element
	 * @param {Object} doc Document object
	 */
	// Called only from within defaultDisplay
	function actualDisplay( name, doc ) {
		var style,
			elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

			// getDefaultComputedStyle might be reliably used only on attached element
			display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

				// Use of this method is a temporary fix (more like optimization) until something better comes along,
				// since it was removed from specification and supported only in FF
				style.display : jQuery.css( elem[ 0 ], "display" );

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
	 * Try to determine the default display value of an element
	 * @param {String} nodeName
	 */
	function defaultDisplay( nodeName ) {
		var doc = document,
			display = elemdisplay[ nodeName ];

		if ( !display ) {
			display = actualDisplay( nodeName, doc );

			// If the simple way fails, read from inside an iframe
			if ( display === "none" || !display ) {

				// Use the already-created iframe if possible
				iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[ 0 ].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay( nodeName, doc );
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[ nodeName ] = display;
		}

		return display;
	}
	var rmargin = (/^margin/);

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {
			// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			if ( elem.ownerDocument.defaultView.opener ) {
				return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
			}

			return window.getComputedStyle( elem, null );
		};



	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
		}

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// Support: iOS < 6
			// A tribute to the "awesome hack by Dean Edwards"
			// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?
			// Support: IE
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply( this, arguments );
			}
		};
	}


	(function() {
		var pixelPositionVal, boxSizingReliableVal,
			docElem = document.documentElement,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		if ( !div.style ) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
			"position:absolute";
		container.appendChild( div );

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computePixelPositionAndBoxSizingReliable() {
			div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
				"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
				"border:1px;padding:1px;width:4px;position:absolute";
			div.innerHTML = "";
			docElem.appendChild( container );

			var divStyle = window.getComputedStyle( div, null );
			pixelPositionVal = divStyle.top !== "1%";
			boxSizingReliableVal = divStyle.width === "4px";

			docElem.removeChild( container );
		}

		// Support: node.js jsdom
		// Don't assume that getComputedStyle is a property of the global object
		if ( window.getComputedStyle ) {
			jQuery.extend( support, {
				pixelPosition: function() {

					// This test is executed only once but we still do memoizing
					// since we can use the boxSizingReliable pre-computing.
					// No need to check if the test was already performed, though.
					computePixelPositionAndBoxSizingReliable();
					return pixelPositionVal;
				},
				boxSizingReliable: function() {
					if ( boxSizingReliableVal == null ) {
						computePixelPositionAndBoxSizingReliable();
					}
					return boxSizingReliableVal;
				},
				reliableMarginRight: function() {

					// Support: Android 2.3
					// Check if div with explicit width and no margin-right incorrectly
					// gets computed margin-right based on width of container. (#3333)
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// This support function is only executed once so no memoizing is needed.
					var ret,
						marginDiv = div.appendChild( document.createElement( "div" ) );

					// Reset CSS: box-sizing; display; margin; border; padding
					marginDiv.style.cssText = div.style.cssText =
						// Support: Firefox<29, Android 2.3
						// Vendor-prefix box-sizing
						"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
						"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
					marginDiv.style.marginRight = marginDiv.style.width = "0";
					div.style.width = "1px";
					docElem.appendChild( container );

					ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

					docElem.removeChild( container );
					div.removeChild( marginDiv );

					return ret;
				}
			});
		}
	})();


	// A method for quickly swapping in/out CSS properties to get correct calculations.
	jQuery.swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};


	var
		// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
		rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( style, name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in style ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
			origName = name,
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in style ) {
				return name;
			}
		}

		return origName;
	}

	function setPositiveNumber( elem, value, subtract ) {
		var matches = rnumsplit.exec( value );
		return matches ?
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i = extra === ( isBorderBox ? "border" : "content" ) ?
			// If we already have the right measurement, avoid augmentation
			4 :
			// Otherwise initialize for horizontal or vertical properties
			name === "width" ? 1 : 0,

			val = 0;

		for ( ; i < 4; i += 2 ) {
			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {
				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {
				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {
			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test(val) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	function showHide( elements, show ) {
		var display, elem, hidden,
			values = [],
			index = 0,
			length = elements.length;

		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			values[ index ] = data_priv.get( elem, "olddisplay" );
			display = elem.style.display;
			if ( show ) {
				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if ( !values[ index ] && display === "none" ) {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if ( elem.style.display === "" && isHidden( elem ) ) {
					values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
				}
			} else {
				hidden = isHidden( elem );

				if ( display !== "none" || !hidden ) {
					data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for ( index = 0; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
				elem.style.display = show ? values[ index ] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && (ret = rrelNum.exec( value )) ) {
					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number, add 'px' to the (except for certain CSS properties)
				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
					value += "px";
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
					style[ name ] = value;
				}

			} else {
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each([ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
						jQuery.swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						}) :
						getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var styles = extra && getStyles( elem );
				return setPositiveNumber( elem, value, extra ?
					augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					) : 0
				);
			}
		};
	});

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
		function( elem, computed ) {
			if ( computed ) {
				return jQuery.swap( elem, { "display": "inline-block" },
					curCSS, [ elem, "marginRight" ] );
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split(" ") : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		},
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each(function() {
				if ( isHidden( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			});
		}
	});


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || "swing";
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				if ( tween.elem[ tween.prop ] != null &&
					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		}
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
		rrun = /queueHooks$/,
		animationPrefilters = [ defaultPrefilter ],
		tweeners = {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value ),
					target = tween.cur(),
					parts = rfxnum.exec( value ),
					unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

					// Starting value computation is required for potential unit mismatches
					start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
						rfxnum.exec( jQuery.css( tween.elem, prop ) ),
					scale = 1,
					maxIterations = 20;

				if ( start && start[ 3 ] !== unit ) {
					// Trust units reported by jQuery.css
					unit = unit || start[ 3 ];

					// Make sure we update the tween properties later on
					parts = parts || [];

					// Iteratively approximate from a nonzero starting point
					start = +target || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*.
						// Use string for doubling so we don't accidentally see scale as unchanged below
						scale = scale || ".5";

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

					// Update scale, tolerating zero or NaN from tween.cur(),
					// break the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}

				// Update tween properties
				if ( parts ) {
					start = tween.start = +start || +target || 0;
					tween.unit = unit;
					// If a +=/-= token was provided, we're doing a relative animation
					tween.end = parts[ 1 ] ?
						start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
						+parts[ 2 ];
				}

				return tween;
			} ]
		};

	// Animations created synchronously will run synchronously
	function createFxNow() {
		setTimeout(function() {
			fxNow = undefined;
		});
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4 ; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( (tween = collection[ index ].call( animation, prop, value )) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		/* jshint validthis: true */
		var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHidden( elem ),
			dataShow = data_priv.get( elem, "fxshow" );

		// Handle queue: false promises
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function() {
				// Ensure the complete handler is called before this completes
				anim.always(function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Height/width overflow pass
		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css( elem, "display" );

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ?
				data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

			if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
				style.display = "inline-block";
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}

		// show/hide pass
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.exec( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

			// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if ( !jQuery.isEmptyObject( orig ) ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = data_priv.access( elem, "fxshow", {} );
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}
			if ( hidden ) {
				jQuery( elem ).show();
			} else {
				anim.done(function() {
					jQuery( elem ).hide();
				});
			}
			anim.done(function() {
				var prop;

				data_priv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			});
			for ( prop in orig ) {
				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = tween.start;
					if ( hidden ) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

		// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
			style.display = display;
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = animationPrefilters.length,
			deferred = jQuery.Deferred().always( function() {
				// Don't match elem in the :animated selector
				delete tick.elem;
			}),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
					// Support: Android 2.3
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ]);

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise({
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, { specialEasing: {} }, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length ; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			}),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length ; index++ ) {
			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			})
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.split(" ");
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length ; index++ ) {
				prop = props[ index ];
				tweeners[ prop ] = tweeners[ prop ] || [];
				tweeners[ prop ].unshift( callback );
			}
		},

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				animationPrefilters.unshift( callback );
			} else {
				animationPrefilters.push( callback );
			}
		}
	});

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHidden ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate({ opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || data_priv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each(function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = data_priv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			});
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each(function() {
				var index,
					data = data_priv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;

	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		clearInterval( timerId );
		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	};


	(function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: iOS<=5.1, Android<=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE<=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android<=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE<=11+
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();


	var nodeHook, boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each(function() {
				jQuery.removeAttr( this, name );
			});
		}
	});

	jQuery.extend({
		attr: function( elem, name, value ) {
			var hooks, ret,
				nType = elem.nodeType;

			// don't get/set attributes on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === strundefined ) {
				return jQuery.prop( elem, name, value );
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[ name ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
			}

			if ( value !== undefined ) {

				if ( value === null ) {
					jQuery.removeAttr( elem, name );

				} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
					return ret;

				} else {
					elem.setAttribute( name, value + "" );
					return value;
				}

			} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				ret = jQuery.find.attr( elem, name );

				// Non-existent attributes return null, we normalize to undefined
				return ret == null ?
					undefined :
					ret;
			}
		},

		removeAttr: function( elem, value ) {
			var name, propName,
				i = 0,
				attrNames = value && value.match( rnotwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( (name = attrNames[i++]) ) {
					propName = jQuery.propFix[ name ] || name;

					// Boolean attributes get special treatment (#10870)
					if ( jQuery.expr.match.bool.test( name ) ) {
						// Set corresponding property to false
						elem[ propName ] = false;
					}

					elem.removeAttribute( name );
				}
			}
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		};
	});




	var rfocusable = /^(?:input|select|textarea|button)$/i;

	jQuery.fn.extend({
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each(function() {
				delete this[ jQuery.propFix[ name ] || name ];
			});
		}
	});

	jQuery.extend({
		propFix: {
			"for": "htmlFor",
			"class": "className"
		},

		prop: function( elem, name, value ) {
			var ret, hooks, notxml,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

			if ( notxml ) {
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
					ret :
					( elem[ name ] = value );

			} else {
				return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
					ret :
					elem[ name ];
			}
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {
					return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
						elem.tabIndex :
						-1;
				}
			}
		}
	});

	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			}
		};
	}

	jQuery.each([
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	});




	var rclass = /[\t\r\n\f]/g;

	jQuery.fn.extend({
		addClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = typeof value === "string" && value,
				i = 0,
				len = this.length;

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).addClass( value.call( this, j, this.className ) );
				});
			}

			if ( proceed ) {
				// The disjunction here is for better compressibility (see removeClass)
				classes = ( value || "" ).match( rnotwhite ) || [];

				for ( ; i < len; i++ ) {
					elem = this[ i ];
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						" "
					);

					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim( cur );
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, clazz, j, finalValue,
				proceed = arguments.length === 0 || typeof value === "string" && value,
				i = 0,
				len = this.length;

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( j ) {
					jQuery( this ).removeClass( value.call( this, j, this.className ) );
				});
			}
			if ( proceed ) {
				classes = ( value || "" ).match( rnotwhite ) || [];

				for ( ; i < len; i++ ) {
					elem = this[ i ];
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( elem.className ?
						( " " + elem.className + " " ).replace( rclass, " " ) :
						""
					);

					if ( cur ) {
						j = 0;
						while ( (clazz = classes[j++]) ) {
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = value ? jQuery.trim( cur ) : "";
						if ( elem.className !== finalValue ) {
							elem.className = finalValue;
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each(function( i ) {
					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
				});
			}

			return this.each(function() {
				if ( type === "string" ) {
					// Toggle individual class names
					var className,
						i = 0,
						self = jQuery( this ),
						classNames = value.match( rnotwhite ) || [];

					while ( (className = classNames[ i++ ]) ) {
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( type === strundefined || type === "boolean" ) {
					if ( this.className ) {
						// store className if set
						data_priv.set( this, "__className__", this.className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
				}
			});
		},

		hasClass: function( selector ) {
			var className = " " + selector + " ",
				i = 0,
				l = this.length;
			for ( ; i < l; i++ ) {
				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
					return true;
				}
			}

			return false;
		}
	});




	var rreturn = /\r/g;

	jQuery.fn.extend({
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[0];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?
						// Handle most common string cases
						ret.replace(rreturn, "") :
						// Handle cases where value is null/undef or number
						ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each(function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function( elem ) {
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
						// Support: IE10-11+
						// option.text throws exceptions (#14686, #14858)
						jQuery.trim( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one" || index < 0,
						values = one ? null : [],
						max = one ? index + 1 : options.length,
						i = index < 0 ?
							max :
							one ? index : 0;

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// IE6-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
								// Don't return options that are disabled or in a disabled optgroup
								( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
								( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];
						if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});




	// Return jQuery for attributes-only inclusion


	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	});

	jQuery.fn.extend({
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		},

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
		}
	});


	var nonce = jQuery.now();

	var rquery = (/\?/);



	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function( data ) {
		return JSON.parse( data + "" );
	};


	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE9
		try {
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rhash = /#.*$/,
		rts = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
		rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Document location
		ajaxLocation = window.location.href,

		// Segment location into parts
		ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

			if ( jQuery.isFunction( func ) ) {
				// For each dataType in the dataTypeExpression
				while ( (dataType = dataTypes[i++]) ) {
					// Prepend if requested
					if ( dataType[0] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

					// Otherwise append
					} else {
						(structure[ dataType ] = structure[ dataType ] || []).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			});
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

			// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s[ "throws" ] ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: ajaxLocation,
			type: "GET",
			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /xml/,
				html: /html/,
				json: /json/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,
				// URL without anti-cache param
				cacheURL,
				// Response headers
				responseHeadersString,
				responseHeaders,
				// timeout handle
				timeoutTimer,
				// Cross-domain detection vars
				parts,
				// To know if global events are to be dispatched
				fireGlobals,
				// Loop variable
				i,
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
				// Callbacks context
				callbackContext = s.context || s,
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks("once memory"),
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
				// The jqXHR state
				state = 0,
				// Default abort message
				strAbort = "canceled",
				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( state === 2 ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( (match = rheaders.exec( responseHeadersString )) ) {
									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return state === 2 ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						var lname = name.toLowerCase();
						if ( !state ) {
							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( !state ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( state < 2 ) {
								for ( code in map ) {
									// Lazy-add the new callback in a way that preserves old ones
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							} else {
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR ).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
				.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

			// A cross-domain request is in order when we have a protocol:host:port mismatch
			if ( s.crossDomain == null ) {
				parts = rurl.exec( s.url.toLowerCase() );
				s.crossDomain = !!( parts &&
					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
				);
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if ( s.cache === false ) {
					s.url = rts.test( cacheURL ) ?

						// If there is already a '_' parameter, set its value
						cacheURL.replace( rts, "$1_=" + nonce++ ) :

						// Otherwise add one to the end
						cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for ( i in { success: 1, error: 1, complete: 1 } ) {
				jqXHR[ i ]( s[ i ] );
			}

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = setTimeout(function() {
						jqXHR.abort("timeout");
					}, s.timeout );
				}

				try {
					state = 1;
					transport.send( requestHeaders, done );
				} catch ( e ) {
					// Propagate exception as error if not done
					if ( state < 2 ) {
						done( -1, e );
					// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Called once
				if ( state === 2 ) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	});

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			return jQuery.ajax({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			});
		};
	});


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};


	jQuery.fn.extend({
		wrapAll: function( html ) {
			var wrap;

			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapAll( html.call(this, i) );
				});
			}

			if ( this[ 0 ] ) {

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map(function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each(function( i ) {
					jQuery( this ).wrapInner( html.call(this, i) );
				});
			}

			return this.each(function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			});
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each(function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
			});
		},

		unwrap: function() {
			return this.parent().each(function() {
				if ( !jQuery.nodeName( this, "body" ) ) {
					jQuery( this ).replaceWith( this.childNodes );
				}
			}).end();
		}
	});


	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
	};
	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};




	var r20 = /%20/g,
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
					// Treat each array item as a scalar.
					add( prefix, v );

				} else {
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
				}
			});

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {
			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	};

	jQuery.fn.extend({
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map(function() {
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			})
			.filter(function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			})
			.map(function( i, elem ) {
				var val = jQuery( this ).val();

				return val == null ?
					null :
					jQuery.isArray( val ) ?
						jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						}) :
						{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			}).get();
		}
	});


	jQuery.ajaxSettings.xhr = function() {
		try {
			return new XMLHttpRequest();
		} catch( e ) {}
	};

	var xhrId = 0,
		xhrCallbacks = {},
		xhrSuccessStatus = {
			// file protocol always yields status code 0, assume 200
			0: 200,
			// Support: IE9
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	// Support: IE9
	// Open requests must be manually aborted on unload (#5280)
	// See https://support.microsoft.com/kb/2856746 for more info
	if ( window.attachEvent ) {
		window.attachEvent( "onunload", function() {
			for ( var key in xhrCallbacks ) {
				xhrCallbacks[ key ]();
			}
		});
	}

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function( options ) {
		var callback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;

					xhr.open( options.type, options.url, options.async, options.username, options.password );

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								delete xhrCallbacks[ id ];
								callback = xhr.onload = xhr.onerror = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
									complete(
										// file: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
										// Support: IE9
										// Accessing binary-data responseText throws an exception
										// (#11426)
										typeof xhr.responseText === "string" ? {
											text: xhr.responseText
										} : undefined,
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					xhr.onerror = callback("error");

					// Create the abort callback
					callback = xhrCallbacks[ id ] = callback("abort");

					try {
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});




	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /(?:java|ecma)script/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery("<script>").prop({
						async: true,
						charset: s.scriptCharset,
						src: s.url
					}).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	});




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function() {
				// Restore preexisting value
				window[ callbackName ] = overwritten;

				// Save back as free
				if ( s[ callbackName ] ) {
					// make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});




	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );
		}

		var selector, type, response,
			self = this,
			off = url.indexOf(" ");

		if ( off >= 0 ) {
			selector = jQuery.trim( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax({
				url: url,

				// if "type" variable is undefined, then "GET" method will be used
				type: type,
				dataType: "html",
				data: params
			}).done(function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			}).complete( callback && function( jqXHR, status ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			});
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	});




	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};




	var docElem = window.document.documentElement;

	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {
				options = options.call( elem, i, curOffset );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend({
		offset: function( options ) {
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each(function( i ) {
						jQuery.offset.setOffset( this, options, i );
					});
			}

			var docElem, win,
				elem = this[ 0 ],
				box = { top: 0, left: 0 },
				doc = elem && elem.ownerDocument;

			if ( !doc ) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if ( !jQuery.contains( docElem, elem ) ) {
				return box;
			}

			// Support: BlackBerry 5, iOS 3 (original iPhone)
			// If we don't have gBCR, just use 0,0 rather than error
			if ( typeof elem.getBoundingClientRect !== strundefined ) {
				box = elem.getBoundingClientRect();
			}
			win = getWindow( doc );
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {
				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		offsetParent: function() {
			return this.map(function() {
				var offsetParent = this.offsetParent || docElem;

				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || docElem;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : window.pageXOffset,
						top ? val : window.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length, null );
		};
	});

	// Support: Safari<7+, Chrome<37+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	});


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {
						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable, null );
			};
		});
	});


	// The number of elements contained in the matched element set
	jQuery.fn.size = function() {
		return this.length;
	};

	jQuery.fn.andSelf = jQuery.fn.addBack;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( typeof noGlobal === strundefined ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;

	}));


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(global) {(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
	var manager = require('./lib/core/manager');
	var domUtils = require('./lib/utils/dom');
	var drawingUtils = require('./lib/utils/drawing');
	var mathUtils = require('./lib/utils/math');
	var extend = require('extend');

	/************************************************
	*  INSTANTIATE NX MANAGER AND CREATE ELEMENTS   *
	************************************************/

	window.nx = new manager();
	window.nx.onload = function() {};
	window.nx = extend(window.nx,domUtils)
	window.nx = extend(window.nx,drawingUtils)
	window.nx = extend(window.nx,mathUtils)

	/* this onload function turns canvases into nexus elements,
	 * using the canvas's id as its var name */

	window.onload = function() {

	  nx.addStylesheet();

	  // get all canvases on the page and add them to the manager
	  var allcanvi = document.getElementsByTagName("canvas");
	  for (i=0;i<allcanvi.length;i++) nx.transform(allcanvi[i]);

	  if (nx.isTouchDevice) {
	    document.addEventListener("touchmove", nx.blockMove, true);
	    document.addEventListener("touchstart", nx.blockMove, true);
	  }
	  
	  nx.onload();

	  nx.startPulse();
	  
	};
	},{"./lib/core/manager":2,"./lib/utils/dom":4,"./lib/utils/drawing":5,"./lib/utils/math":6,"extend":48}],2:[function(require,module,exports){

	/** 
	  @title NexusUI API
	  @overview NexusUI is a JavaScript toolkit for easily creating musical interfaces in web browsers. Interfaces are rendered on HTML5 canvases and are ideal for web audio projects, mobile apps, or for sending OSC to external audio applications like Max.
	  @author Ben Taylor, Jesse Allison, Yemin Oh, Sbastien Piquemal
	  @copyright &copy; 2011-2014
	  @license MIT
	 */ 
	 

	var timingUtils = require('../utils/timing');
	var EventEmitter = require('events').EventEmitter;
	var util = require('util');
	var transmit = require('../utils/transmit');
	//var WAAClock = require('waaclock');


	var manager = module.exports = function() {

	/** 

	  @class nx
	  @description Central nexusUI manager with shared utility functions for all nexusUI objects
	  
	*/

	  EventEmitter.apply(this)

	  /**@property {object} widgets Contains all interface widgets (e.g. nx.widgets.dial1, nx.widgets.toggle1) */
	  this.widgets = new Object();

	  this.elemTypeArr = new Array();
	  this.aniItems = new Array();
	  /*  @property {boolean} showLabels Whether or not to draw an automatic text label on each interface component. */
	  this.showLabels = false;
	  this.starttime = new Date().getTime();
	  if (transmit) {
	    /**  
	    @method sendsTo 
	    @param {string or function} [destination] Protocol for transmitting data from interfaces (i.e. "js", "ajax", "ios", "max", or "node"). Also accepts custom functions.
	    ```js
	    nx.sendsTo("ajax")

	    // or

	    nx.sendsTo(function(data) {
	         //define a custom transmission function
	    })
	    ```
	    */
	    this.sendsTo = transmit.setGlobalTransmit;
	    /**  
	    @method setAjaxPath 
	    @param {string} [path] If sending via AJAX, define the path to ajax destination
	    */
	    this.setAjaxPath = transmit.setAjaxPath;
	    /**  @property {string} destination NexusUI's transmission protocol (i.e. "js" or "ajax"). Defaults to "js". We recommend setting this property using nx.sendsTo() which ensures that all widgets receive this setting. */
	    this.destination = "js";
	    /**  @property {string} ajaxPath If sending via AJAX, the destination path. Defaults to "lib/nexusOSCRelay.php". We recommend setting this property using nx.setAjaxPath() which ensures that all widgets receive this setting. */
	    this.ajaxPath = "lib/nexusOSCRelay.php";
	  }

	  /** @property {boolean} isTouchDevice Returns true if page is loaded on a touch device. */
	  this.isTouchDevice = ('ontouchstart' in document.documentElement)? true:false;
	  this.metas = document.getElementsByTagName('meta');

	  /**  @property {boolean} globalWidgets Whether or not to instantiate a global variable for each widget (i.e. button1). Defaults to true. Designers of other softwares who wish to keep nexusUI entirely encapsulated in the nx object may set this property to false. In that case, all widgets are accessible in nx.widgets */
	  this.globalWidgets = true;

	  this.font = "gill sans";
	  this.fontSize = 14;
	  this.fontWeight = "bold";

	  this.context = new(window.AudioContext || window.webkitAudioContext)()
	 
	  this.sys = navigator.userAgent.toLowerCase();
	  this.isAndroid = this.sys.indexOf("android") > -1;
	  this.isMobile = this.sys.indexOf("mobile") > -1;

	  /**  @property {integer} throttlePeriod Throttle time in ms (for nx.throttle). */
	  this.throttlePeriod = 20;

	}

	util.inherits(manager, EventEmitter)


	/** 
	  @method add 
	  Adds a NexusUI element to the webpage. This will create an HTML5 canvas and draw the interface on it.
	  @param {string} [type] NexusUI widget type (i.e. "dial").
	  @param {object} [settings] (Optional.) Extra settings for the new widget. This settings object may have any of the following properties: x (integer in px), y, w (width), h (height), name (widget's OSC name and canvas ID), parent (the ID of the element you wish to add the canvas into). If no settings are provided, the element will be at default size and appended to the body of the HTML document.
	  */
	manager.prototype.add = function(type, args) {
	  //args may have optional properties: x, y, w, h, name, parent

	  if(type) {
	      var canv = document.createElement("canvas");
	      canv.setAttribute('nx', type);
	      if (args) {
	        if (args.x || args.y) {
	           canv.style.position = "absolute";
	        }
	        if (args.x) {
	           canv.style.left = args.x + "px";
	        }
	        if (args.y) {
	           canv.style.top = args.y + "px";
	        }
	        if (args.w) {
	           canv.style.width = args.w;
	           if (typeof args.w != "string")
	             canv.width = args.w;
	        }
	        if (args.h) {
	           canv.style.height = args.h;
	           if (typeof args.h != "string")
	             canv.height = args.h;
	        }
	        if (args.parent) {
	          var parent;
	          if (typeof args.parent === "string") {
	            parent = document.getElementById(args.parent);
	          } else if (args.parent instanceof HTMLElement){
	            parent = args.parent;
	          } else if (args.parent instanceof jQuery){
	            parent = args.parent[0];            
	          }
	        }
	        if (args.name) {
	           canv.id = args.name
	        }
	      }
	      if (!parent) {
	        var parent = document.body
	      }
	      parent.appendChild(canv);
	      return this.transform(canv);
	  }
	}

	/** @method transform 
	Transform an existing canvas into a NexusUI widget.
	@param {string} [canvasID] The ID of the canvas to be transformed.
	@param {string} [type] (Optional.) Specify which type of widget the canvas will become. If no type is given, the canvas must have an nx attribute with a valid widget type.
	*/
	manager.prototype.transform = function(canvas, type) {
	  for (var key in nx.widgets) {
	    if (nx.widgets[key].canvasID == canvas.id) {
	      return;
	    }
	  }
	  if (type) {
	    var nxType = type;
	  } else {
	    var nxType = canvas.getAttribute("nx");
	  }

	  if (!nxType) {
	    return;
	  }
	  var elemCount = 0;
	  var newObj;

	  /* find out how many of the same elem type have come before
	    i.e. nx.elemTypeArr will look like [ dial, dial, toggle, toggle ]
	    allowing you to count how many dials already exist on the page
	    and give your new dial the appropriate index and id: dial3 */

	  for (j=0;j<this.elemTypeArr.length;j++) {
	    if (this.elemTypeArr[j] === nxType) {
	      elemCount++;
	    }
	  }

	  // add your new nexus element type to the element list
	  this.elemTypeArr.push(nxType);

	  // check to see if it has a pre-given ID
	  // and use that as its id if so
	  if (!canvas.id) {
	    var idNum = elemCount + 1;
	    canvas.id = nxType + idNum;
	  }

	  if(nxType) {
	    try {
	      var newObj = new (require('../widgets')[nxType])(canvas.id);
	    } catch (err) {
	      console.log("creation of " + nxType + " failed");
	      return;
	    }
	  }

	  newObj.type = nxType;

	  this.widgets[newObj.canvasID] = newObj;
	  if (this.globalWidgets) {
	    window[newObj.canvasID] = this.widgets[newObj.canvasID]
	  }

	  newObj.init();
	  return newObj;
	}

	/** @method transmit 
	The "output" instructions for sending a widget's data to another application or to a JS callback. Inherited by each widget and executed when each widget is interacted with or its value changes. Set using nx.sendsTo() to ensure that all widgets inherit the new function correctly.
	@param {object} [data] The data to be transmitted. Each property of the object will become its own OSC message. (This works with objects nested to up to 2 levels).
	*/

	manager.prototype.transmit = function(data, passive) {
	  //console.log(passive + " manager.transmit")
	    this.makeOSC(this.emit, data, passive);
	    this.emit('*',data, passive);
	} 

	/** 
	  @method colorize
	  @param {string} [aspect] Which part of ui to change, i.e. "accent" "fill", "border"
	  @param {string} [color] Hex or rgb color code
	  Change the color of all nexus objects, by aspect ([fill, accent, border, accentborder]
	  
	  ```js
	  nx.colorize("#00ff00") // changes the accent color by default
	  nx.colorize("border", "#000000") // changes the border color
	  ```

	**/
	manager.prototype.colorize = function(aspect, newCol) {
	  
	  if (!newCol) {
	    // just sending in a color value colorizes the accent
	    newCol = aspect;
	    aspect = "accent";
	  }
	  
	  this.colors[aspect] = newCol;
	  
	  for (var key in this.widgets) {
	    this.widgets[key].colors[aspect] = newCol;
	    this.widgets[key].draw();
	  }
	}
	  

	/** @method setThrottlePeriod 
	Set throttle time of nx.throttle, which controls rapid network transmissions of widget data.
	@param {integer} [throttle time] Throttle time in milliseconds. 
	*/
	manager.prototype.setThrottlePeriod = function(newThrottle) {
	  this.throttlePeriod = newThrottle;
	  for (var key in this.widgets) {
	    this.widgets[key].throttlePeriod = this.throttlePeriod;
	  }
	}



	  /*  
	   *    GUI
	   */

	/**  @property {object} colors The interface's color settings. Set with nx.colorize(). */
	manager.prototype.colors = { 
	  "accent": "#ff5500", 
	  "fill": "#eeeeee", 
	  "border": "#bbbbbb",
	  "black": "#000000",
	  "white": "#FFFFFF"
	};
	  
	/**  @method startPulse 
	  Start an animation interval for animated widgets (calls nx.pulse() every 30 ms). Executed by default when NexusUI loads.
	*/
	manager.prototype.startPulse = function() {
	  this.pulseInt = setInterval("nx.pulse()", 30);
	}

	/**  @method stopPulse 
	  Stop the animation pulse interval.
	*/
	manager.prototype.stopPulse = function() {
	  clearInterval(this.pulseInt);
	}

	/**  @method pulse 
	  Animation pulse which executes all functions stored in the nx.aniItems array.
	*/
	manager.prototype.pulse = function() {
	  for (var i=0;i<this.aniItems.length;i++) {
	    this.aniItems[i]();
	  }
	} 

	manager.prototype.addAni = function(fn) {

	}

	manager.prototype.removeAni = function(fn) {
	  this.aniItems.splice(this.aniItems.indexOf(fn));
	}
	  
	manager.prototype.addStylesheet = function() {
	  var htmlstr = '<style>'
	    + 'select {'
	    + 'width: 150px;'
	    + 'padding: 5px 5px;'
	    + 'font-size: 16px;'
	    + 'color:#666666;'
	    + 'border: solid 0px #CCC;'
	    + 'border-radius: 5;'
	    + 'outline: black;'
	    + 'cursor:pointer;'
	    + 'background-color:#EEE;'
	    + 'font-family:gill sans;'
	    + '}'
	    + ''
	    // + 'input[type=text]::-moz-selection { background: transparent; }'
	    // + 'input[type=text]::selection { background: transparent; }'   
	    // + 'input[type=text]::-webkit-selection { background: transparent; }' 
	    + ''
	    + 'canvas { '
	    // + 'cursor:pointer;'
	    + 'border-radius:5px;'
	    + 'moz-border-radius:5px;'
	    + 'webkit-border-radius:5px;'
	    + 'box-sizing:border-box;'
	    + '-moz-box-sizing:border-box;'
	    + '-webkit-box-sizing:border-box;'
	    + '}'
	    + ''
	    // + 'input[type=text] { '
	    // + 'cursor:pointer;'
	    // + 'border-radius:5px;'
	    // + 'moz-border-radius:5px;'
	    // + 'webkit-border-radius:5px;'
	    // + 'box-sizing:border-box;'
	    // + '-moz-box-sizing:border-box;'
	    // + '-webkit-box-sizing:border-box;'
	    // + '}'
	    + '</style>';

	  document.head.innerHTML = document.head.innerHTML + htmlstr
	}

	/**  @method setViewport
	    Set mobile viewport scale (similar to a zoom)
	    @param {integer} [scale] Zoom ratio (i.e. 0.5, 1, 2) */
	manager.prototype.setViewport = function(scale) {
	  for (i=0; i<this.metas.length; i++) {
	    if (this.metas[i].name == "viewport") {
	      this.metas[i].content = "minimum-scale="+scale+", maximum-scale="+scale;
	    }
	  }
	}

	/*  @method setLabels
	    Tell all widgets whether or not draw text labels on widgets
	    @param {boolean} [on/off] true to add labels, false to remove labels
	 */
	manager.prototype.setLabels = function(onoff) {
	  if (onoff=="on") {
	    this.showLabels = true;
	  } else {
	    this.showLabels = false;
	  }
	  for (var key in this.widgets) {
	    this.widgets[key].draw()
	  }
	}

	manager.prototype.setProp = function(prop,val) {
	  if (prop && val) {
	    nx[prop] = val;
	    for (var key in this.widgets) {
	      this.widgets[key][prop] = val;
	      this.widgets[key].draw()
	    } 
	  }
	}

	manager.prototype.blockMove = function(e) {
	  if (e.target.attributes["nx"]) {
	     e.preventDefault();
	     if (this.isAndroid) {
	       e.stopPropagation ? e.stopPropagation() : false;
	     }
	  }
	}
	},{"../utils/timing":7,"../utils/transmit":8,"../widgets":17,"events":43,"util":47}],3:[function(require,module,exports){
	var EventEmitter = require('events').EventEmitter;
	var util = require('util');
	var domUtils = require('../utils/dom');
	var drawingUtils = require('../utils/drawing');
	var timingUtils = require('../utils/timing');
	var transmit = require('../utils/transmit');



	var widget = module.exports = function (target) {
	  EventEmitter.apply(this)
	  this.preClick = this.preClick.bind(this)
	  this.preMove = this.preMove.bind(this)
	  this.preRelease = this.preRelease.bind(this)
	  this.preTouch = this.preTouch.bind(this)
	  this.preTouchMove = this.preTouchMove.bind(this)
	  this.preTouchRelease = this.preTouchRelease.bind(this)

	/** 

	  @class widget
	  All NexusUI interface widgets inherit from the widget class. The properties and methods of the widget class are usable by any NexusUI interface.
	  
	*/

	  /**  @property {string} canvasID ID attribute of the interface's HTML5 canvas */
	  this.canvasID = target;
	  /**  @property {string} oscPath OSC prefix for this interface. By default this is populated using the canvas ID (i.e. an ID of dial1 has OSC path /dial1) */
	  this.oscPath = "/"+target;
	  if (!document.getElementById(target)) {
	    var newcanv = document.createElement("canvas")
	    newcanv.id = target;
	    document.body.appendChild(newcanv)
	  }
	  /**
	   * @property {string} type The type of NexusUI widget (i.e. "dial", "toggle", "slider"). Set automatically at creation.
	   */
	  this.type = undefined;
	  /**  @property {DOM element} canvas The widget's HTML5 canvas */
	  this.canvas = document.getElementById(target);
	  /**  @property {HTML5 drawing context} context The canvas's drawing context */
	  this.context = this.canvas.getContext("2d");

	  this.checkPercentage();
	  this.canvas.className = this.canvas.className ? this.canvas.className += " nx" : "nx"

	  this.canvas.height = window.getComputedStyle(document.getElementById(target), null).getPropertyValue("height").replace("px","");
	  this.canvas.width = window.getComputedStyle(document.getElementById(target), null).getPropertyValue("width").replace("px","");
	  /**  @property {integer} height The widget canvas's computed height in pixels */
	  this.height = parseInt(window.getComputedStyle(document.getElementById(target), null).getPropertyValue("height").replace("px",""));
	  /**  @property {integer} width The widget canvas's computed width in pixels */
	  this.width = parseInt(window.getComputedStyle(document.getElementById(target), null).getPropertyValue("width").replace("px",""));
	  if (!this.defaultSize) {
	    /**  @property {object} defaultSize The widget's default size if not defined with HTML/CSS style. (Has properties 'width' and 'height', both in pixels) */
	    this.defaultSize = { width: 100, height: 100 };
	  }
	  if (this.width==300 && this.height==150) {
	    this.canvas.width = this.defaultSize.width*2;
	    this.canvas.height = this.defaultSize.height*2;
	    this.width = this.defaultSize.width;
	    this.height = this.defaultSize.height;
	  } else {
	  	var proxyw = this.width;
	  	var proxyh = this.height;
	  	this.canvas.width = proxyw*2;
	    this.canvas.height = proxyh*2;
	    this.width = proxyw;
	    this.height = proxyh;
	  }
	  this.canvas.style.width = this.canvas.width/2+"px";
	  this.canvas.style.height = this.canvas.height/2+"px";
	  this.context.scale(2,2)

	  /**  @property {object} offset The widget's computed offset from the top left of the document. (Has properties 'top' and 'left', both in pixels) */
	  this.offset = domUtils.findPosition(this.canvas);
	  /**  @property {object} center The center of the widget's canvas. A 100x100 widget would have a center at 50x50. (Has properties 'x' and 'y', both in pixels) */
	  this.center = {
	    x: this.width/2, 
	    y: this.height/2
	  };
	  //drawing
	  /**  @property {integer} lineWidth The default line width for drawing (default is 2 pixels). In many widgets, this is overwritten to suite the widget. However it does dictate the border width on most widgets. */
	  this.lineWidth = 2;
	  this.context.lineWidth = this.lineWidth;
	  /**  @property {object} colors A widget's individual color scheme. Inherited from nx.colors. (Has properties "accent", "fill", "border", "black", and "white") */
	  this.colors = new Object();
	  // define colors individually so they are not pointers to nx.colors
	  // this way each object can have its own color scheme
	  this.colors.accent = nx.colors.accent;
	  this.colors.fill = nx.colors.fill;
	  this.colors.border = nx.colors.border;
	  this.colors.accentborder = nx.colors.accentborder;
	  this.colors.black = nx.colors.black;
	  this.colors.white = nx.colors.white; 
	  this.colors.highlight = nx.colors.highlight;
	  //interaction
	  /**  @property {object} clickPos The most recent mouse/touch position when interating with a widget. (Has properties x and y) */
	  this.clickPos = {x: 0, y: 0};
	  /**  @property {array} clickPos.touches If multitouch, an array of touch positions  */
	  this.clickPos.touches = new Array();
	  /**  @property {boolean} clicked Whether or not the widget is currently clicked  */
	  this.clicked = false;
	  this.value = 0;
	    /**
	      @property {object} val An object containing the core interactive values of the widget, which are also the widget's data output. 
	    */
	  this.val = new Object();
	  this.pval = new Object();
	  this.nodePos = new Array();
	  /**  @property {object} deltaMove Difference between the current touch/mouse position and the previous touch/mouse position, in pixels.   */
	  this.deltaMove = new Object();
	  this.throttlePeriod = nx.throttlePeriod;
	  this.throttle = timingUtils.throttle;
	  /**  @property {boolean} label Whether or not to draw a text label this widget.   */
	  this.label = false;
	  this.hasMoved = false;
	  //recording
	  /**  @property {boolean} isRecording Whether or not this widget's output is being recorded to a "remix" widget */
	  this.isRecording = false;
	  this.tapeNum = 0;
	  this.recorder = null;
	  //transmission
	  if (transmit) {
	    /**  @method sendsTo
	    Set the transmission protocol for this widget individually 
	    @param {string or function} [destination] Protocol for transmitting data from this widget (i.e. "js", "ajax", "ios", "max", or "node"). Also accepts custom functions.
	    ```js
	    dial1.sendsTo("ajax")

	    // or

	    dial1.sendsTo(function(data) {
	         //define a custom transmission function
	    })
	    ```  
	    */
	    this.sendsTo = transmit.setWidgetTransmit;
	    this.destination = "js";
	  }
	  this.events = new Object();

	  // Setup interaction
	  if (nx.isTouchDevice) {
	    this.canvas.ontouchstart = this.preTouch;
	    this.canvas.ontouchmove = this.preTouchMove;
	    this.canvas.ontouchend = this.preTouchRelease;
	  } else {
	    this.canvas.addEventListener('mousedown', this.preClick, false);
	  }

	  this.fontSize = nx.fontSize;
	  this.fontWeight = nx.fontWeight;
	  this.font = nx.font;

	  this.clickCB = false;
	  this.releaseCB = false;

	  this.actuated = true;

	}
	util.inherits(widget, EventEmitter)

	/**  @method transmit
	    The "output" instructions for sending the widget's data to another application or to a JS callback. Inherited from nx.transmit and executed when each widget is interacted with or during animation. Set using .sendsTo() to use our built-in transmission defintions.
	    @param {object} [data] The data to be transmitted. Each property of the object will become its own OSC message if sending via "ajax" or "max7" protocols. (This works with objects nested to up to 2 levels).
	*/
	widget.prototype.transmit = nx.transmit;

	/**  @method makeOSC
	    Loops through an object (i.e. a widget's data), creates OSC path/value pairs, and executes a callback function with these two arguments.
	    @param {function} [callback] A function defining the action to be taken with each OSC path/value pair. This function should have two parameters, path (string) and data (type depends on widget data type).
	    @param {object} [data] The data as an object, to be broken into individual OSC messages.
	*/
	widget.prototype.makeOSC = function(action, data) {
	    this.action = action;
	    if ((typeof data == "object") && (data !== null)) {
	      for (var key in data) {
	        if ((typeof data[key] == "object") && (data[key] !== null)) {
	          for (var key2 in data[key]) {
	              this.action(key+"/"+key2, data[key][key2])
	          }
	        } else {
	            this.action(key, data[key])
	        }
	      }
	    } else if (typeof data == "number" || typeof data == "string") {
	        this.action('value', data)
	    }
	}

	// getoffset is useful as an API for others
	// otherwise they would have to write
	// dial1.offset = utils.findPosition()
	// now it is simply:
	// dial1.getOffset()

	/**  @method getOffset
	    Recalculate the computed offset of the widget's canvas and store it in widget.offset. This is useful if a widget has been moved after being created.
	    */
	widget.prototype.getOffset = function() {
	  this.offset = domUtils.findPosition(this.canvas)
	}

	widget.prototype.preClick = function(e) {
	  this.actuated = true;
	  this.offset = domUtils.findPosition(this.canvas)
	  document.addEventListener("mousemove", this.preMove, false);
	  document.addEventListener("mouseup", this.preRelease, false);
	  this.clickPos = domUtils.getCursorPosition(e, this.offset);
	  this.clicked = true;
	  this.deltaMove.x = 0;
	  this.deltaMove.y = 0;
	  this.hasMoved = false;
	  this.clickCB ? this.clickCB() : null;
	  this.click(e);
	  document.body.style.userSelect = "none";
	  document.body.style.mozUserSelect = "none";
	  document.body.style.webkitUserSelect = "none";
	}

	widget.prototype.preMove = function(e) {
	  this.actuated = true;
	  var newClickPos = domUtils.getCursorPosition(e, this.offset);
	  this.deltaMove.y = newClickPos.y - this.clickPos.y;
	  this.deltaMove.x = newClickPos.x - this.clickPos.x;
	  this.clickPos = newClickPos;
	  this.hasMoved = true;
	  this.move(e);
	}

	widget.prototype.preRelease = function(e) {
	  this.actuated = true;
	  document.removeEventListener("mousemove", this.preMove, false);
	  document.removeEventListener("mouseup", this.preRelease, false);
	  this.clicked = false;
	  this.releaseCB ? this.releaseCB() : null;
	  this.release();
	  document.body.style.userSelect = "text";
	  document.body.style.mozUserSelect = "text";
	  document.body.style.webkitUserSelect = "text";
	}

	widget.prototype.preTouch = function(e) {
	  this.actuated = true;
	  this.clickPos = domUtils.getTouchPosition(e, this.offset);
	  this.clicked = true;
	  this.deltaMove.x = 0;
	  this.deltaMove.y = 0;
	  this.hasMoved = false;
	  this.touch(e);
	}

	widget.prototype.preTouchMove = function(e) {
	  if (this.clicked) {
	    this.actuated = true;
	    var newClickPos = domUtils.getTouchPosition(e, this.offset);
	    this.deltaMove.y = newClickPos.y - this.clickPos.y;
	    this.deltaMove.x = newClickPos.x - this.clickPos.x;
	    this.clickPos = newClickPos;
	    this.hasMoved = true;
	    this.touchMove(e);
	  }
	}

	widget.prototype.preTouchRelease = function(e) {
	  this.actuated = true;
	  if (e.targetTouches.length>=1) {
	    var newClickPos = domUtils.getTouchPosition(e, this.offset);
	    this.clickPos = newClickPos;
	  } else {
	    this.clicked = false;
	  }
	  this.touchRelease();
	}


	/**  @method init
	     Initialize or re-initialize the widget. Defined separately within each widget.
	    */

	/**  @method draw
	    Draw the widget onto the canvas.
	    */
	widget.prototype.draw = function() {
	}


	/**  @method click
	    Executes when the widget is clicked on
	    */
	widget.prototype.click = function() {
	}


	/**  @method move
	    Executes on drag (mouse moves while clicked).
	    */
	widget.prototype.move = function() {
	}


	/**  @method release
	    Executes when the mouse releases after having clicked on the widget.
	    */
	widget.prototype.release = function() {
	}

	/**  @method touch
	    Executes when the widget is touched on a touch device.
	    */
	widget.prototype.touch = function() {
	  this.click();
	}

	/**  @method touchMove
	    Executes on drag (touch then move) on a touch device
	    */
	widget.prototype.touchMove = function() {
	  this.move();
	}

	/**  @method touchRelease
	    Executes when the touch releases after having touched the widget.
	    */
	widget.prototype.touchRelease = function() {
	  this.release();
	}

	widget.prototype.adjustSizeIfDefault = function() {
	  if (this.width==300 && this.height==150) {
	    this.canvas.width = this.defaultSize.width;
	    this.canvas.height = this.defaultSize.height;
	    this.width = this.defaultSize.width;
	    this.height = this.defaultSize.height;
	  }
	}

	widget.prototype.makeRoundedBG = function() {
	  this.bgLeft = this.lineWidth;
	  this.bgRight = this.width - this.lineWidth;
	  this.bgTop = this.lineWidth;
	  this.bgBottom = this.height - this.lineWidth;
	  this.bgHeight = this.bgBottom - this.lineWidth;
	  this.bgWidth = this.bgRight - this.lineWidth; 
	  
	  drawingUtils.makeRoundRect(this.context, this.bgLeft, this.bgTop, this.bgWidth, this.bgHeight);
	}

	/**  @method erase
	    Erase the widget's canvas.
	    */
	widget.prototype.erase = function() {
	  this.context.clearRect(0,0,this.width,this.height);
	}

	widget.prototype.hideCursor = function() {
	  this.canvas.style.cursor = "none";
	}

	widget.prototype.showCursor = function() {
	  this.canvas.style.cursor = "auto";
	}

	// allow us to get the constructor function name programatically
	//i.e. if element is a dial, this function will return "dial"
	//deprecated
	widget.prototype.getName = function() {
	  return "deprecated -- use widget.type instead"
	}

	/** @method set
	Manually set a widget's value (that is, set any properties of a widget's .val). See widget.val or the .val property of individual widgets for more info. 
	@param {object} [data] Parameter/value pairs in object notation.
	@param {boolean} [transmit] (optional) Whether or not to transmit new value after being set.
	Sets the value of an object. 

	```js
	  position1.set({
	  &nbsp;  x: 100,
	  &nbsp;  y: 250
	  })
	```

	An optional second argument decides whether the object then transmits its new value.
	```js
	  button1.set({
	  &nbsp;  press: 100
	  }, true)
	```
	*/
	widget.prototype.set = function(data, transmit) {

	  this.actuated = false;

	  if (typeof this.val == "object" && this.val !== "null") {
	    if (typeof data == "object" && data !== "null") {
	      for (var key in data) {
	        this.val[key] = data[key];
	      }
	    }
	  } else if (typeof this.val == "string" || typeof this.val == "number") {
	    if (typeof data == "object" && data !== "null") {
	      this.val = data["value"];
	      this.draw();
	    } else if (typeof data == "string" || typeof data == "number") {
	      this.val = data;
	    }
	  }
	  this.draw();

	  if (transmit) {
	    this.transmit(this.val,true)
	  }
	}

	/**  @method destroy
	    Remove the widget object, canvas, and all related event listeners from the document.
	    */
	widget.prototype.destroy = function() {
	  var type = nx.elemTypeArr.indexOf(this.getName())
	  nx.elemTypeArr.splice(type,1)

	  this.canvas.ontouchmove = null;
	  this.canvas.ontouchend = null;
	  this.canvas.onclick = null;
	  this.canvas.onmousemove = null;
	  this.canvas.onmouseoff = null;
	  document.removeEventListener("mousemove", this.preMove, false);
	  document.removeEventListener("mouseup", this.preRelease, false);

	  var elemToKill = document.getElementById(this.canvasID)
	  if (elemToKill) {
	    elemToKill.parentNode.removeChild(elemToKill);
	  }

	  this.customDestroy();

	  var id = this.canvasID
	  delete nx.widgets[id];
	  delete window[id];

	}

	widget.prototype.customDestroy = function() {

	}

	widget.prototype.wrapText = function(text, x, y, maxWidth, lineHeight) {
	  if (text) {
	    var words = text.split(' ');
	    var line = '';

	    for(var n = 0; n < words.length; n++) {
	      var testLine = line + words[n] + ' ';
	      var metrics = this.context.measureText(testLine);
	      var testWidth = metrics.width;
	      if (testWidth > maxWidth && n > 0) {
	        this.context.fillText(line, x, y);
	        line = words[n] + ' ';
	        y += lineHeight;
	      }
	      else {
	        line = testLine;
	      }
	    }
	    this.context.fillText(line, x, y);
	  }
	}

	widget.prototype.drawLabel = function() {
	  if (this.showLabels) {
	    with(this.context) {
	      globalAlpha = 0.9;
	      fillStyle = this.colors.fill;
	      fillRect(this.width-100,this.height-20,100,20);
	      globalAlpha = 1;
	      beginPath();
	      fillStyle = this.colors.border;
	      font = "bold 15px courier";
	      textAlign = "center";
	      fillText(this.oscPath,this.width-50,this.height-5);
	      textAlign = "left";
	      closePath();
	    }
	  }
	}

	/**  @method saveCanv
	     Download the widget's current graphical state as an image (png).
	    */
	widget.prototype.saveCanv = function() {
	  var data = this.canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
	  window.location.href = data
	}
	//MODIFIED BY KARL
	widget.prototype.setFont = function() {
	  with (this.context) {
	        textAlign = "center";
	        textBaseline = "middle";
	        font = this.fontWeight+" 1.1em 'Abel'";
	        fillStyle = "#0affea";
	        globalAlpha = 0.7;
	  }
	}


	/* Percentage width support */


	widget.prototype.checkPercentage = function() {
	  var wstr = this.canvas.style.width;
	  var hstr = this.canvas.style.height;
	  if (wstr.indexOf("%") >= 0 || hstr.indexOf("%") >= 0) {
	    this.percent = {
	      w: (wstr.indexOf("%") >= 0) ? wstr.replace("%","") : false,
	      h: (hstr.indexOf("%") >= 0) ? hstr.replace("%","") : false
	    }
	    this.stretch();
	  }
	}

	widget.prototype.stretch = function() {
	  window.addEventListener("resize", function(e) {
	    if (this.percent.w) {
	      var newWidth = window.getComputedStyle(this.canvas.parentNode, null).getPropertyValue("width").replace("px","");
	      newWidth *= this.percent.w/100
	    } else {
	      var newWidth = false;
	    }
	    if (this.percent.h) {
	      var newHeight = window.getComputedStyle(this.canvas.parentNode, null).getPropertyValue("height").replace("px","");
	      newHeight *= this.percent.h/100 
	    } else {
	      var newHeight = false;
	    }
	    this.resize(newWidth,newHeight);
	  }.bind(this))
	}

	widget.prototype.resize = function(w,h) {

	  this.canvas.width = w ? w*2 : this.canvas.width;
	  this.canvas.height = h ? h*2 : this.canvas.height;
	  this.width =  w ? w : this.width;
	  this.height = h ? h : this.height;
	  this.canvas.style.width = this.width+"px";
	  this.canvas.style.height = this.height+"px";
	  this.context.scale(2,2)

	  this.center = {
	    x: this.width/2,
	    y: this.height/2
	  };

	  this.init();
	  this.draw();
	  
	}
	},{"../utils/dom":4,"../utils/drawing":5,"../utils/timing":7,"../utils/transmit":8,"events":43,"util":47}],4:[function(require,module,exports){

	/** @class utils 
	  Shared utility functions. These functions are exposed as methods of nx in NexusUI projects, i.e. .mtof() here can be accessed in your project with nx.mtof().
	*/


	/** @method findPosition 
	    Returns the offset of an HTML element. Returns an object with 'top' and 'left' properties.
	    @param {DOM element} [element] 
	    ```js
	    var button1Offset = nx.findPosition(button1.canvas)
	    ```
	*/
	exports.findPosition = function(element) {
	  var body = document.body,
	      win = document.defaultView,
	      docElem = document.documentElement,
	      box = document.createElement('div');
	  box.style.paddingLeft = box.style.width = "1px";
	  body.appendChild(box);
	  var isBoxModel = box.offsetWidth == 2;
	  body.removeChild(box);
	  box = element.getBoundingClientRect();
	  var clientTop  = docElem.clientTop  || body.clientTop  || 0,
	      clientLeft = docElem.clientLeft || body.clientLeft || 0,
	      scrollTop  = win.pageYOffset || isBoxModel && docElem.scrollTop  || body.scrollTop,
	      scrollLeft = win.pageXOffset || isBoxModel && docElem.scrollLeft || body.scrollLeft;
	  return {
	    top : box.top  + scrollTop  - clientTop,
	    left: box.left + scrollLeft - clientLeft
	  };
	}

	exports.getCursorPosition = function(e, canvas_offset) {
	  var x;
	  var y;
	  if (e.pageX != undefined && e.pageY != undefined) {
	    x = e.pageX;
	    y = e.pageY;
	  } else {
	    x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
	    y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
	  }
	  x -= canvas_offset.left;
	    y -= canvas_offset.top;
	  var click_position = {x: x, y: y};
	  click_position.touches = [ {x: x, y: y } ];
	  return click_position;
	}

	exports.getTouchPosition = function(e, canvas_offset) {
	  var x;
	  var y;
	  x = e.targetTouches[0].pageX;
	  y = e.targetTouches[0].pageY;
	  x -= canvas_offset.left;
	    y -= canvas_offset.top;
	  var click_position = {x: x, y: y};

	  click_position.touches = new Array();
	  for (var i=0;i<e.targetTouches.length;i++) {
	     click_position.touches.push({
	      x: e.targetTouches[i].pageX - canvas_offset.left,
	      y: e.targetTouches[i].pageY - canvas_offset.top
	    });
	  }
	  click_position.changed = new Array();
	  for (var i=0;i<e.changedTouches.length;i++) {
	     click_position.changed.push({
	      x: e.changedTouches[i].pageX - canvas_offset.left,
	      y: e.changedTouches[i].pageY - canvas_offset.top
	    });
	  }
	  return click_position;
	}
	},{}],5:[function(require,module,exports){
	var math = require('./math')

	/** @method randomColor
	    Returns a random color string in rgb format
	*/
	exports.randomColor = function() {
	  return "rgb(" + math.random(250) + "," + math.random(250) + "," + math.random(250) + ")";
	}

	/** @method hexToRgb
	    Converts a hex color code to rgb format
	    @param {color code} [hex] Input color code in hex format
	    @param {float} [alpha] Color alpha level
	*/
	exports.hexToRgb = function(hex, a) {
	  // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	  hex = hex.replace(shorthandRegex, function(m, r, g, b) {
	      return r + r + g + g + b + b;
	  });

	  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	  if (!a) {
	    a = 0.5;
	  }
	  
	  var r = parseInt(result[1], 16);
	  var g = parseInt(result[2], 16);
	  var b = parseInt(result[3], 16);

	  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
	}

	exports.isInside = function(clickedNode,currObject) {
	  if (clickedNode.x > currObject.x && clickedNode.x < (currObject.x+currObject.w) && clickedNode.y > currObject.y && clickedNode.y < (currObject.y+currObject.h)) {
	    return true;
	  } else {
	    return false; 
	  }
	}

	exports.makeRoundRect = function(ctx,xpos,ypos,wid,hgt,depth) {
	  var x1 = xpos;
	  var y1 = ypos;
	  var x2 = wid+x1;
	  var y2 = hgt+y1;
	  if (!depth) {
	    depth = 2;
	  }
	  
	  ctx.beginPath();
	  ctx.moveTo(x1+depth, y1); //TOP LEFT
	  ctx.lineTo(x2-depth, y1); //TOP RIGHT
	  ctx.quadraticCurveTo(x2, y1, x2, y1+depth);
	  ctx.lineTo(x2, y2-depth); //BOTTOM RIGHT
	  ctx.quadraticCurveTo(x2, y2, x2-depth, y2);
	  ctx.lineTo(x1+depth, y2); //BOTTOM LEFT
	  ctx.quadraticCurveTo(x1, y2, x1, y2-depth);
	  ctx.lineTo(x1, y1+depth); //TOP LEFT
	  ctx.quadraticCurveTo(x1, y1, x1+depth, y1);
	  ctx.closePath();
	}

	exports.text = function(context, text, position) {
	  if (!position) {
	    position = [10 , 10];
	  }
	  with(context) {
	    beginPath();
	    font = "bold 12px sans-serif";
	    fillText(text,position[0],position[1]);
	    closePath();
	  }
	}
	},{"./math":6}],6:[function(require,module,exports){


	/** @method toPolar 
	    Receives cartesian coordinates and returns polar coordinates as an object with 'radius' and 'angle' properties.
	    @param {float} [x] 
	    @param {float} [y] 
	    ```js
	    var ImOnACircle = nx.toPolar({ x: 20, y: 50 }})
	    ```
	*/
	exports.toPolar = function(x,y) {
	  var r = Math.sqrt(x*x + y*y);

	  var theta = Math.atan2(y,x);
	  if (theta < 0.) {
	    theta = theta + (2 * Math.PI);
	  }
	  return {radius: r, angle: theta};
	}

	/** @method toCartesian 
	    Receives polar coordinates and returns cartesian coordinates as an object with 'x' and 'y' properties.
	    @param {float} [radius] 
	    @param {float} [angle] 
	*/
	exports.toCartesian = function(radius, angle){
	  var cos = Math.cos(angle);
	  var sin = Math.sin(angle);
	  return {x: radius*cos, y: radius*sin*-1};
	}


	/** @method clip 
	    Limits a number to within low and high values.
	    @param {float} [input value] 
	    @param {float} [low limit] 
	    @param {float} [high limit] 
	    ```js
	    nx.clip(5,0,10) // returns 5
	    nx.clip(15,0,10) // returns 10
	    nx.clip(-1,0,10) // returns 0
	    ```
	*/
	exports.clip = function(value, low, high) {
	  return Math.min(high, Math.max(low, value));
	}

	/** @method prune 
	    Limits a float to within a certain number of decimal places
	    @param {float} [input value] 
	    @param {integer} [max decimal places] 
	    ```js
	    nx.prine(1.2345, 3) // returns 1.234
	    nx.prune(1.2345, 1) // returns 1.2
	    ```
	*/

	exports.prune = function(data, scale) {
	  if (typeof data === "number") {
	    data = parseFloat(data.toFixed(scale));
	  } else if (data instanceof Array) {
	    for (var i=0;i<data.length;i++) {
	      if (typeof data[i]=="number") {
	        data[i] = parseFloat(data[i].toFixed(scale));
	      }
	    }
	  }
	  return data;
	}


	/** @method scale 
	    Scales an input number to a new range of numbers
	    @param {float} [input value] 
	    @param {float} [low1]  input range (low)
	    @param {float} [high1] input range (high)
	    @param {float} [low2] output range (low)
	    @param {float} [high2] output range (high)
	    ```js
	    nx.scale(5,0,10,0,100) // returns 50
	    nx.scale(5,0,10,1,2) // returns 1.5
	    ```
	*/
	exports.scale = function(inNum, inMin, inMax, outMin, outMax) {
	  return (((inNum - inMin) * (outMax - outMin)) / (inMax - inMin)) + outMin;  
	}

	/** @method invert 
	    Equivalent to nx.scale(input,0,1,1,0). Inverts a normalized (0-1) number. 
	    @param {float} [input value]  
	    ```js
	    nx.invert(0.25) // returns 0.75
	    nx.invert(0) // returns 1
	    ```
	*/
	exports.invert = function (inNum) {
	  return exports.scale(inNum, 1, 0, 0, 1);
	}

	exports.bounce = function(posIn, borderMin, borderMax, delta) {
	  if (posIn > borderMin && posIn < borderMax) {
	    return delta;
	  } else if (posIn <= borderMin) {
	    return Math.abs(delta); 
	  } else if (posIn >= borderMax) {
	    return Math.abs(delta) * (-1);
	  }
	}


	/** @method mtof 
	    MIDI to frequency conversion. Returns frequency in Hz.
	    @param {float} [MIDI] MIDI value to convert
	    ```js
	    nx.mtof(69) // returns 440
	    ```
	*/
	exports.mtof = function(midi) {
	  return Math.pow(2, ((midi-69)/12)) * 440;
	}


	/** @method random 
	    Returns a random integer between 0 a given scale parameter.
	    @param {float} [scale] Upper limit of random range.
	    ```js
	    nx.random(10) // returns a random number from 0 to 9.
	    ```
	*/
	exports.random = function(scale) {
	  return Math.floor(Math.random() * scale);
	}


	exports.interp = function(loc,min,max) {
	  return loc * (max - min) + min;  
	}

	exports.lphistory = {}


	exports.lp = function(tag,value,limit) {

	  if (!this.lphistory[tag]) {
	    this.lphistory[tag] = []
	  }

	  var total = 0;

	  this.lphistory[tag].push(value)

	  if (this.lphistory[tag].length>limit) {
	    this.lphistory[tag].splice(0,1)
	  }

	  for (var i=0;i<this.lphistory[tag].length;i++) {
	    total += this.lphistory[tag][i]
	  }

	  var newvalue = total / this.lphistory[tag].length;

	  return newvalue;
	}


	exports.lp2 = function(value,limit) {

	  var total = 0;
	  for (var i=0;i<this.lphistory.length;i++) {
	    total += this.lphistory[i]
	  }
	  total += value;

	  var newvalue = total / ( this.lphistory.length + 1 )

	  this.lphistory.push(newvalue)

	  if (this.lphistory.length>limit) {
	    this.lphistory.splice(0,1)
	  }

	  return newvalue;
	}


	exports.lp3 = function(value,pvalue,limit) {

	  var total = value + pvalue * limit;
	  newvalue = total / (limit + 1)

	  return newvalue;
	}
	},{}],7:[function(require,module,exports){


	exports.throttle = function(func, wait) {
	  var timeout;
	  return function() {
	    var context = this, args = arguments;
	    if (!timeout) {
	      // the first time the event fires, we setup a timer, which 
	      // is used as a guard to block subsequent calls; once the 
	      // timer's handler fires, we reset it and create a new one
	      timeout = setTimeout(function() {
	        timeout = null;
	        try {
	          func.apply(context, args);
	        } catch (err) {
	          console.log(err);
	        }
	      }, wait);
	    }
	  }
	}
	},{}],8:[function(require,module,exports){
	exports.defineTransmit = function(protocol) {
	  
	  var newTransmit;

	  if (typeof(protocol)=="function") {
	    return protocol;
	  } else {
	    switch (protocol) {
	      case 'js':
	        newTransmit = function(data,passive) {
	          this.makeOSC(this.emit, data, passive);
	          this.emit('*',data, passive);
	        }
	        return newTransmit
	      
	      case 'ajax':
	        newTransmit = function(data) {
	          this.makeOSC(exports.ajaxTransmit, data);
	        }
	        return newTransmit
	      
	      case 'node':
	        newTransmit = function(data) {
	          this.makeOSC(exports.nodeTransmit, data);
	        }
	        return newTransmit
	      
	      case 'ios':
	        newTransmit = function(data) {
	          
	        }
	        return newTransmit
	      
	      case 'max':
	        newTransmit = function(data) {
	          this.makeOSC(exports.maxTransmit, data);
	        }
	        return newTransmit

	      case 'wc':
	        newTransmit = function(data, passive) {
	          this.emit('internal',data, passive);
	        }
	        return newTransmit
	    }
	  }
	}

	exports.setGlobalTransmit = function(protocol) {
	  var newTransmit = exports.defineTransmit(protocol)
	  this.transmit = newTransmit
	  this.destination = protocol
	  for (var key in nx.widgets) {
	    this.widgets[key].transmit = newTransmit;
	    this.widgets[key].destination = protocol;
	  }
	}

	exports.setWidgetTransmit = function(protocol) {
	  var newTransmit = exports.defineTransmit(protocol)
	  this.transmit = newTransmit
	  this.destination = protocol
	}


	exports.ajaxTransmit = function(subPath, data) {

	    var oscPath = subPath=='value' ? this.oscPath : this.oscPath+"/"+subPath;
	     
	    xmlhttp=new XMLHttpRequest();
	    xmlhttp.open("POST",nx.ajaxPath,true);
	    xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
	    xmlhttp.send('oscName='+oscPath+'&data='+data);

	}

	exports.setAjaxPath = function(path) {
	  this.ajaxPath = path;
	}

	exports.nodeTransmit = function(subPath, data) {
	   
	    var msg = {
	      oscName: subPath=='value' ? this.oscPath : this.oscPath+"/"+subPath,
	      value: data
	    }
	    socket.emit('nx', msg)

	}

	exports.maxTransmit = function (subPath, data) {
	    var oscPath = subPath=='value' ? this.oscPath : this.oscPath+"/"+subPath;
	    window.max.outlet(oscPath + " " + data);
	}
	},{}],9:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class banner      
		"Powered by NexusUI" tag with a link to our website. Use it if you want to share the positive vibes of NexusUI. Thanks for using!
		```html
		<canvas nx="banner"></canvas>
		```
		<canvas nx="banner" style="margin-left:25px"></canvas>
	*/

	var banner = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 40 };
		widget.call(this, target);
		
		//unique attributes
		/** @property {string} message1 The first line of text on the banner. */
		this.message1 = "Powered By";
		/** @property {string} message2 The second line of text on the banner. */
		this.message2 = "NexusUI";
		/** @property {string} link The URL the banner will link to. */
		this.link = "http://www.nexusosc.com";
		/** @property {boolean} isLink Whether or not the banner is a hyperlink. Defaults to true. */
		this.isLink = true;
	}
	util.inherits(banner, widget);

	banner.prototype.init = function() {
		this.draw();
	}

	banner.prototype.draw = function() {
		with (this.context) {

			globalAlpha = 0.1;
			fillStyle = this.colors.accent;
			beginPath();
				moveTo(0,10);
				lineTo(10,this.height/2+5);
				lineTo(0,this.height);
				lineTo(30,this.height);
				lineTo(30,10);
				fill();
				moveTo(this.width-30,10);
				lineTo(this.width-30,this.height);
				lineTo(this.width,this.height);
				lineTo(this.width-10,this.height/2+5);
				lineTo(this.width,10);
				fill();
			closePath();
			globalAlpha = 1;

			fillStyle = this.colors.accent;
			fillRect(15,0,this.width-30,this.height-10);
			
			fillStyle = this.colors.white;
			font = this.fontWeight + " " +this.height/5+"px "+this.font;
			textAlign = "center";
			fillText(this.message1, this.width/2, this.height/3.3);
			fillText(this.message2, this.width/2, (this.height/3.3)*2);

			fillStyle = this.colors.black;
			beginPath();
				moveTo(15,this.height-10);
				lineTo(30,this.height);
				lineTo(30,this.height-10);
				lineTo(15,this.height-10);
				fill();
				moveTo(this.width-15,this.height-10);
				lineTo(this.width-30,this.height);
				lineTo(this.width-30,this.height-10);
				lineTo(this.width-15,this.height-10);
				fill();
			closePath();
		
		}
	}

	banner.prototype.click = function() {
		if (this.isLink) {
			window.location = this.link;
		}
	}
	},{"../core/widget":3,"util":47}],10:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');
	var drawing = require('../utils/drawing');

	var button = module.exports = function(target) {

	/** 
		
		@public
		@class button 

		Touch button with three modes of interaction ("toggle", "impulse", and "aftertouch").
		```html
		<canvas nx="button"></canvas>
		```
		<canvas nx="button" style="margin-left:25px"></canvas>
	*/

		this.defaultSize = { width: 50, height: 50 };
		widget.call(this, target);

		/** 
			@property {object}  val  Main value set and output, with sub-properties:
			| &nbsp; | data
			| --- | ---
			| *press* | 0 (clicked) or 1 (unclicked)
			| *x* | 0-1 float of x-position of click ("aftertouch" mode only)
			| *y* | 0-1 float of y-position of click ("aftertouch" mode only) 
			
			When the widget is interacted with, val is sent as the output data for the widget.
			```js 
			button1.on('*', function(data) {
				// some code using data.press, data.x, and data.y
			});
			```
			Or, if NexusUI is outputting OSC (e.g. if nx.sendsTo("ajax")), val will be broken into OSC messages: 
			```html 
			/button1/press 1
			/button1/x 37
			/button1/y 126
			```
			*/
		this.val = {
			press: 0
		}
		
		/** @property {string}  mode  Interaction mode. Options:
		<b>impulse</b> &nbsp; 1 on click <br>
		<b>toggle</b> &nbsp;  1 on click, 0 on release<br>
		<b>aftertouch</b> &nbsp; 1, x, y on click; x, y on move; 0, x, y on release _(default)_ <br> 
		```js 
		button1.mode = "aftertouch" 
		```
		*/
		this.mode = "aftertouch";

		this.lockResize = true;

		this.image = null;
		this.imageHover = null;
		this.imageTouch = null;

		this.subval = new Object();

		this.init();

	}
	util.inherits(button, widget);

	button.prototype.init = function() {
		this.center = {
			x: this.width/2,
			y: this.height/2
		}
		this.radius = (Math.min(this.center.x, this.center.y)-this.lineWidth/2)
		this.draw();
	}

	button.prototype.draw = function() {

		this.erase();
		
		with (this.context) {
			
			if (this.image !== null) {
				// Image Button
				if (!this.val.press) {
					// Draw Image if not touched
					drawImage(this.image, 0, 0);
				} else {
					if (!this.imageTouch) {

						drawImage(this.image, 0, 0);

						// No touch image, apply highlighting
						globalAlpha = 0.5;
						fillStyle = this.colors.accent;
						fillRect (0, 0, this.width, this.height);
						globalAlpha = 1;
						
					} else {
						// Draw Touch Image
						drawImage(this.imageTouch, 0, 0);
					}
				}
				
			} else {
		
				// Regular Button
				if (!this.val.press) {
					fillStyle = this.colors.fill;
				} else if (this.val.press) {
					fillStyle = this.colors.accent;
				}

				beginPath();
					arc(this.center.x, this.center.y, this.radius, 0, Math.PI*2, true);
					fill();	  
				closePath();

				if (this.val.press && this.mode=="aftertouch") {

					var x = nx.clip(this.clickPos.x,this.width*.2,this.width/1.3)
					var y = nx.clip(this.clickPos.y,this.height*.2,this.height/1.3)

					var gradient = this.context.createRadialGradient(x,y,this.width/6,this.center.x,this.center.y,this.radius*1.3);
					gradient.addColorStop(0,this.colors.accent);
					gradient.addColorStop(1,"white");

					strokeStyle = gradient;
					lineWidth = this.width/20;

					beginPath()
						arc(this.center.x, this.center.y, this.radius-this.width/40, 0, Math.PI*2, true);
						stroke()
					closePath()


				}
			}

			this.drawLabel();
			
		}
	}

	button.prototype.click = function(e) {
		if (drawing.isInside(this.clickPos,{x: this.center.x-this.radius, y:this.center.y-this.radius, w:this.radius*2, h:this.radius*2})) {
			this.val["press"] = 1;
			if (this.mode=="aftertouch") {
				this.val["x"] = this.clickPos.x;
				this.val["y"] = this.clickPos.y;
			}
			this.transmit(this.val);
			this.draw();
		}
	}

	button.prototype.move = function () {
		// use to track movement on the button
		if (this.mode=="aftertouch") {
			this.val["x"] = this.clickPos.x;
			this.val["y"] = this.clickPos.y;
			this.subval["x"] = this.clickPos.x;
			this.subval["y"] = this.clickPos.y;
			this.transmit(this.subval);
			this.draw();
		}
	}

	button.prototype.release = function() {
		this.val["press"] = 0;
		if (this.mode=="toggle" || this.mode=="aftertouch") { 
			this.transmit(this.val);
		}
		this.draw();
	}


	/** @method setImage 
		Turns the button into an image button with custom image. Sets the default (unclicked) button image.
		@param {string} [src] Image source */
	button.prototype.setImage = function(image) {
		this.image = new Image();
		this.image.onload = function() { this.draw() }
		this.image.src = image;
	}

	button.prototype.setHoverImage = function(image) {
		this.imageHover = new Image();
		this.imageHover.onload = function() { this.draw() }
		this.imageHover.src = image;
	}

	/** @method setTouchImage 
		Sets the image that will show when the button is clicked.
		@param {string} [src] Image source */
	button.prototype.setTouchImage = function(image) {
		this.imageTouch = new Image();
		this.imageTouch.onload = this.draw();
		this.imageTouch.src = image;
	}
	},{"../core/widget":3,"../utils/drawing":5,"util":47}],11:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class colors      
		Color picker that outputs RBG values
		```html
		<canvas nx="colors"></canvas>
		```
		<canvas nx="colors" style="margin-left:25px"></canvas>
	*/
					
	var colors = module.exports = function (target) {
		
		this.defaultSize = { width: 100, height: 100 };	
		widget.call(this, target);

		this.init();
		
	}
	util.inherits(colors, widget);

	colors.prototype.init = function() {

		/* new tactic */

		this.gradient1 = this.context.createLinearGradient(0,0,this.width,0)
	 	this.gradient1.addColorStop(0, '#F00'); 
	 	this.gradient1.addColorStop(0.17, '#FF0'); 
	 	this.gradient1.addColorStop(0.34, '#0F0'); 
	 	this.gradient1.addColorStop(0.51, '#0FF'); 
	 	this.gradient1.addColorStop(0.68, '#00F'); 
	 	this.gradient1.addColorStop(0.85, '#F0F'); 
	 	this.gradient1.addColorStop(1, '#F00'); 

		this.gradient2 = this.context.createLinearGradient(0,0,0,this.height)
	 	this.gradient2.addColorStop(0, 'rgba(0,0,0,255)'); 
	 	this.gradient2.addColorStop(0.49, 'rgba(0,0,0,0)'); 
	 	this.gradient2.addColorStop(0.51, 'rgba(255,255,255,0)'); 
	 	this.gradient2.addColorStop(0.95, 'rgba(255,255,255,255)'); 

		this.draw();
	}

	colors.prototype.draw = function() {
		this.erase();

		with(this.context) {
			fillStyle = this.gradient1;
			fillRect(0,0,this.width,this.height)
			fillStyle = this.gradient2;
			fillRect(0,0,this.width,this.height)
		}

		this.drawLabel();
	}

	colors.prototype.drawColor = function() {
		with(this.context) {
			fillStyle = "rgb("+this.val.r+","+this.val.g+","+this.val.b+")"
			fillRect(0,this.height * 0.95,this.width,this.height* 0.05)

		}
	}

	colors.prototype.click = function(e) {
		if (this.clickPos.x > 0 && this.clickPos.y > 0 && this.clickPos.x < this.width && this.clickPos.y < this.height) {
			var imgData = this.context.getImageData(this.clickPos.x*2,this.clickPos.y*2,1,1);
		} else {
			return;
		}
		

		/** @property {object}  val  RGB color value at mouse position. <br> This is also the widget's data output (See <a href="#nexusui-api-widget-widgetval">widget.val</a>). <br> Properties:
		| &nbsp; | data
		| --- | ---
		| *r* | red value 0-256
		| *g* | green value 0-256
		| *b* | blue value 0-256 
		```js 
		colors1.on('*', function(data) {
			// some code using data.r, data.g, and data.b
		}
		```
		*/

		this.val = {
			r: imgData.data[0], 
			g: imgData.data[1], 
			b: imgData.data[2]
		}
		this.transmit(this.val);
		this.drawColor();
	}


	colors.prototype.move = function(e) {
		this.click(e);
	}
	},{"../core/widget":3,"util":47}],12:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class comment      
		Text comment
		```html
		<canvas nx="comment"></canvas>
		```
		<canvas nx="comment" style="margin-left:25px"></canvas>
	*/

	var comment = module.exports = function (target) {
		
		this.defaultSize = { width: 75, height: 25 };
		widget.call(this, target);

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *text* | text of comment area (as string)
			```js 
			comment1.val.text = "This is my comment"
			comment1.draw()
			```
		*/
		
		this.val = {
			text: "comment"
		}
		this.sizeSet = false;

		this.init();
	}
	util.inherits(comment, widget);

	/** @method setSize
		Set the font size of the comment text
		@param {integer} [size] Text size in pixels
	*/
	comment.prototype.setSize = function(size) {
		this.size = size;
		this.sizeSet = true;
		this.draw();
	}

	comment.prototype.init = function() {
		this.draw();
	}

	comment.prototype.draw = function() {
		if (!this.sizeSet) {
			this.size = Math.sqrt((this.width * this.height) / (this.val.text.length));
		}

		this.erase();
		with (this.context) {
			
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
			
			beginPath();
			moveTo(0,this.height);
			lineTo(this.width,this.height);
			closePath();
			
			fillStyle = this.colors.black;
			textAlign = "left";
			font = this.size+"px Gill Sans";
		}
		this.wrapText(this.val.text, 6, 3+this.size, this.width-6, this.size);
	}
	},{"../core/widget":3,"util":47}],13:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class crossfade      
		Crossfade for panning or mixing
		```html
		<canvas nx="crossfade"></canvas>
		```
		<canvas nx="crossfade" style="margin-left:25px"></canvas>
	*/

	var crossfade = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 30 };
		widget.call(this, target);

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *value* | Crossfade value (float -1 to 1)
		*/
		this.val.value = 0.7

		this.label = "";

		this.init();
	}
	util.inherits(crossfade, widget);

	crossfade.prototype.init = function() {

		if (this.canvas.getAttribute("label")!=null) {
			this.label = this.canvas.getAttribute("label");
		}

		this.draw();
	}

	crossfade.prototype.draw = function() {
		
		this.erase();
			
		with (this.context) {

			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);

			
			if (nx.showLabels) {
				this.setFont();
				fillText(this.label, this.width/2, this.height/2);
				globalAlpha = 1;
			
			}

			var x1 = this.width/2;
			var y1 = 0;
			var x2 = (this.val.value/2)*this.width;
			var y2 = this.height;
		   
		
			fillStyle = this.colors.accent;
			fillRect(x1,y1,x2,y2);

			fillRect(x1-1,y1,2,y2);

		}
	}

	crossfade.prototype.click = function() {
		this.move();
	}

	crossfade.prototype.move = function() {
		var x = nx.scale(this.clickPos.x/this.width,0,1,-1,1)
		this.val.value = math.prune(math.clip(x, -1, 1),3)
		this.draw();
		this.transmit(this.val);
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],14:[function(require,module,exports){
	var math = require('../utils/math');
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class dial      
		Circular dial
		```html
		<canvas nx="dial"></canvas>
		```
		<canvas nx="dial" style="margin-left:25px"></canvas>
	*/

	var dial = module.exports = function(target) {
		
		this.defaultSize = { width: 50, height: 50 };
		widget.call(this, target);
		
		//define unique attributes
		this.circleSize;
		this.handleLength;

		/** @property {object}  val
		    | &nbsp; | data
			| --- | ---
			| *value* | Current value of dial as float 0-1
		*/
		this.val = {
			value: 0
		}
		/** @property {float}  responsivity    How much the dial increments on drag. Default: 0.004<br>
		*/
		this.responsivity = 0.004;
		
		this.aniStart = 0;
		this.aniStop = 1;
		this.aniMove = 0.01;

		this.lockResize = true;

		this.init();
		
	}

	util.inherits(dial, widget);

	dial.prototype.init = function() {

		this.circleSize = (Math.min(this.center.x, this.center.y));
		this.handleLength = this.circleSize;
		this.mindim = Math.min(this.width,this.height)
		
		if (this.mindim<101) {
			this.handleLength--;
		}

		if (this.mindim<101 || this.mindim<101) {
			this.accentWidth = this.lineWidth * 1;
		} else {
			this.accentWidth = this.lineWidth * 2;
		}
		
		this.draw();
		
		return 1;
	}

	dial.prototype.draw = function() {
		var dial_angle = (((1.0 - this.val.value) * 2 * Math.PI) + (1.5 * Math.PI));
		var dial_position = (this.val.value + 0.25) * 2 * Math.PI
		var point = math.toCartesian(this.handleLength, dial_angle);

		this.erase();
		
		with (this.context) {
			
			fillStyle = this.colors.fill;
			
			//draw main circle
			beginPath();
				arc(this.center.x, this.center.y, this.circleSize-1, 0, Math.PI*2, true);
				fill();
			closePath();

			//draw color fill
			beginPath();
				lineWidth = this.accentWidth;
				arc(this.center.x, this.center.y, this.circleSize, Math.PI* 0.5, dial_position, false);
				lineTo(this.center.x,this.center.y);
				globalAlpha = 0.1;
				fillStyle = this.colors.accent;
				fill();
				globalAlpha = 1;
			closePath(); 

			//draw round accent
			beginPath();
				lineWidth = this.accentWidth;
				arc(this.center.x, this.center.y, this.circleSize-this.lineWidth , Math.PI* 0.5, dial_position, false);
				strokeStyle = this.colors.accent;
				stroke();
			closePath(); 
		
			//draw bar accent
			beginPath();
				lineWidth = this.accentWidth;
				strokeStyle = this.colors.accent;
				moveTo(this.center.x, this.center.y);
				lineTo(point.x + this.center.x, point.y + this.center.y);
				stroke();
			closePath(); 
			
			//draw circle in center
			beginPath();
				fillStyle = this.colors.accent;
				arc(this.center.x, this.center.y, this.circleSize/8, 0, Math.PI*2, false);
				fill();
			closePath(); 
			
		}

		this.drawLabel();
	}


	dial.prototype.click = function(e) {
		this.val.value = math.prune(this.val.value, 4)
		this.transmit(this.val);
		this.draw();
		this.aniStart = this.val.value;
	}


	dial.prototype.move = function() {	
		this.val.value = math.clip((this.val.value - (this.deltaMove.y * this.responsivity)), 0, 1);
		this.val.value = math.prune(this.val.value, 4)
		this.transmit(this.val);
		
		this.draw();
	}


	dial.prototype.release = function() {
		this.aniStop = this.val.value;
	}

	/** @method animate 
		Animates the dial
		@param {string} [type] Type of animation. Currently accepts "bounce" (bounces between mousedown and mouserelease points) or "none" */
	dial.prototype.animate = function(aniType) {
		
		switch (aniType) {
			case "bounce":
				nx.aniItems.push(this.aniBounce.bind(this));
				break;
			case "none":
				nx.aniItems.splice(nx.aniItems.indexOf(this.aniBounce));
				break;
		}
		
	}

	dial.prototype.aniBounce = function() {
		if (!this.clicked) {
			this.val.value += this.aniMove;
			if (this.aniStop < this.aniStart) {
				this.stopPlaceholder = this.aniStop;
				this.aniStop = this.aniStart;
				this.aniStart = this.stopPlaceholder;
			}
			this.aniMove = math.bounce(this.val.value, this.aniStart, this.aniStop, this.aniMove);	
			this.draw();
			this.val.value = math.prune(this.val.value, 4)
			this.transmit(this.val);
		}
	}


	},{"../core/widget":3,"../utils/math":6,"util":47}],15:[function(require,module,exports){
	var startTime = 0;

	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class envelope      
		Multi-point line ramp generator
		```html
		<canvas nx="envelope"></canvas>
		```
		<canvas nx="envelope" style="margin-left:25px"></canvas>
	*/

	var envelope = module.exports = function (target) {
		this.defaultSize = { width: 200, height: 100 };
		widget.call(this, target);
		
		this.nodeSize = 1;
		/** @property {boolean} active Whether or not the envelope is currently animating. */
		this.active = false;
		/** @property {integer} duration The envelope's duration in ms. */
		this.duration = 1000; // 1000 ms
		/** @property {boolean} looping Whether or not the envelope loops. */
		this.looping = false


		this.scanIndex = 0

		//define unique attributes
		
		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *amp* | amplitude at current point of ramp (float 0-1)
			| *index* | current progress through ramp (float 0-1)
			| *points* | array containing x/y coordinates of each node.
		*/

		this.val = {
			index: 0,
			amp: 0,
			points: [
				{
					x: 0.1,
					y: 0.4
				},
				{
					x: 0.35,
					y: 0.6
				},
				{
					x: 0.65,
					y: 0.2
				},
				{
					x: 0.9,
					y: 0.4
				}
			]
		}

		// Index of which node was clicked
		var selectedNode = null;

		nx.aniItems.push(this.pulse.bind(this));

		this.init();
	}

	util.inherits(envelope, widget);

	envelope.prototype.init = function() {
		this.mindim = this.width < this.height ? this.width : this.height;
		this.draw();
	}

	envelope.prototype.draw = function() {
		this.erase();
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
			fillStyle = this.colors.accent;
			var centerx = this.mindim/10
			var centery = this.height-this.mindim/10
			beginPath()
				moveTo(centerx,centery)
				arc(centerx,centery,this.mindim/10,Math.PI*1.5,Math.PI*2*this.val.index+Math.PI*1.5,false);
				fill()
			closePath()

			// draw all the points
			var drawingX = [];
			var drawingY = [];

			for (var i = 0; i < this.val.points.length; i++) {
				drawingX[i] = this.val.points[i].x * this.width;
				drawingY[i] = (1 - this.val.points[i].y) * this.height;

				//stay within right/left bounds
				if (drawingX[i]<(this.bgLeft+this.nodeSize)) {
					drawingX[i] = this.bgLeft + this.nodeSize;
				} else if (drawingX[i]>(this.bgRight-this.nodeSize)) {
					drawingX[i] = this.bgRight - this.nodeSize;
				}
				//stay within top/bottom bounds
				if (drawingY[i]<(this.bgTop+this.nodeSize)) {
					drawingY[i] = this.bgTop + this.nodeSize;
				} else if (drawingY[i]>(this.bgBottom-this.nodeSize)) {
					drawingY[i] = this.bgBottom - this.nodeSize;
				}
			}

			// draw rectangles
			for (var j = 0; j < drawingX.length; j++) {
				var size = this.mindim/25;
				beginPath()
				arc(drawingX[j],drawingY[j],size,0,Math.PI*2,false);
				fillStyle = this.colors.accent
				fill()
				closePath()
			}


			// draw shape
			beginPath();
				strokeStyle = this.colors.accent;
				moveTo(-5,this.height);
				lineTo(-5,(1-this.val.points[0].y)*this.height);

				// draw each line
				for (var j = 0; j < drawingX.length; j++) {
					lineTo(drawingX[j],drawingY[j]);
				}

				lineTo(this.width+5,(1-this.val.points[this.val.points.length-1].y)*this.height);
				lineTo(this.width+5,this.height);
				stroke();
				globalAlpha = 0.2;
				fillStyle = this.colors.accent;
				fill();
				globalAlpha = 1
			closePath();
		


		}
		
		this.drawLabel();
	}

	envelope.prototype.scaleNode = function(nodeIndex) {
		var i = nodeIndex;
		var prevX = 0;
		var nextX = this.width;
		
		var actualX = this.val.points[i].x;
		var actualY = (this.height - this.val.points[i].y);
		var clippedX = math.clip(actualX/this.width, 0, 1);
		var clippedY = math.clip(actualY/this.height, 0, 1);

		this.val.points[i].x = math.prune(clippedX, 3);
		this.val.points[i].y = math.prune(clippedY, 3);

		// find x value of nodes to the right and left
		if (i > 0) {
			prevX = this.val.points[i-1].x;
		}
		if (this.val.points.length > i+1) {
			nextX = this.val.points[i+1].x;
		}

		if (this.val.points[i].x < prevX) {
			this.val.points.splice(i-1, 0, this.val.points.splice(i, 1)[0])
			i = i-1;
			selectedNode = i;
		}

		if (this.val.points[i].x > nextX) {
			this.val.points.splice(i+1, 0, this.val.points.splice(i, 1)[0])
			i = i+1;
			selectedNode = i;
		}

	}

	envelope.prototype.click = function() {

		// find nearest node and set selectedNode (index)
		selectedNode = this.findNearestNode(this.clickPos.x/this.width, this.clickPos.y/this.height, this.val.points);

		this.transmit(this.val);
		this.draw();
	}

	envelope.prototype.move = function() {
		if (this.clicked) {
			this.val.points[selectedNode].x = this.clickPos.x;
			this.val.points[selectedNode].y = this.clickPos.y;
			this.scaleNode(selectedNode);
			this.transmit(this.val);
			this.draw();
		}
	}

	envelope.prototype.release = function() {

		if (!this.hasMoved) {
			this.val.points.splice(selectedNode,1)
		}

		this.draw();

		// reset the selectedNode
		selectedNode = null;
	}

	// update index and amp
	envelope.prototype.pulse = function() {
		if (this.active) {

			// calculate index based on audio context
			var percentDone = (nx.context.currentTime - startTime) / (this.duration/1000);
			if (percentDone >= 1) {
				if (this.looping) {
					percentDone -= 1;
					startTime += this.duration/1000;
					this.val.index = 0
					this.scanIndex = 0
				} else {
					this.stop();
				}
				
			}
			this.val.index = percentDone;
		
			if (this.val.index > this.val.points[this.val.points.length-1].x) {
				this.val.amp = this.val.points[this.val.points.length-1].y
			} else if (this.val.index < this.val.points[0].x) {
				this.val.amp = this.val.points[0].y
			} else {

				while (percentDone > this.val.points[this.scanIndex].x) {
					this.scanIndex++;
				}

				var nextPX = this.val.points[this.scanIndex].x;
				var prevPX = this.val.points[this.scanIndex-1].x;
				var nextPY = this.val.points[this.scanIndex].y;
				var prevPY = this.val.points[this.scanIndex-1].y;
			
				this.val.amp = math.interp((this.val.index-prevPX)/(nextPX - prevPX),prevPY,nextPY);

			}
		
			this.transmit(this.val);
			this.draw();
		}
	}

	/** @method start
		Start ramp from beginning. If set to loop, will loop the ramp until stopped. */
	envelope.prototype.start = function() {
		this.active = true;
		this.val.index = 0;
		
		// set startTime
		startTime = nx.context.currentTime;
	}

	/** @method stop
		Stop the ramp and set progress to 0. */
	envelope.prototype.stop = function() {
		this.active = false;
		this.val.index = 0;
		this.draw();
	}

	envelope.prototype.findNearestNode = function(x, y, nodes) {
		var nearestIndex = null;
		var nearestDist = 1000;
		var before = false;
		y = 1 - y;
		for (var i = 0; i<nodes.length; i++) {
			var distance = Math.sqrt(  Math.pow( (nodes[i].x - x), 2), Math.pow((nodes[i].y - (-y)), 2) );

			if (distance < nearestDist) {
				nearestDist = distance;
				nearestIndex = i;
				before = x > nodes[i].x
			}
		}

		if (nearestDist>.1) {
			if (before) { nearestIndex++ }
			this.val.points.splice(nearestIndex,0,{
				x: this.clickPos.x/this.width,
				y: (this.height-this.clickPos.y)/this.height
			})
			//nearestIndex++;
		}

		return nearestIndex;
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],16:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class ghost (alpha) 
		Interface gesture capture / playback (in development)    
		
		```html
		<canvas nx="ghost"></canvas>
		```
		<canvas nx="ghost" style="margin-left:25px"></canvas>
	*/

	var ghost = module.exports = function(target) {
		
		this.defaultSize = { width: 100, height: 50 };
		widget.call(this, target);
		
		//define unique attributes
		this.recording = false;
		this.playing = false;
		this.maxLength = 2000;
		this.components = new Array();
		this.buffer = new Array();
		//this.moment is for the record head
		this.moment = 0;
		//this.needle is for the playback head
		this.needle = 0;
		this.val = new Object();
		this.rate = 1;
		this.start = 0;
		this.end = 1;
		this.size = 0;
		this.looping = true;
		this.boundLog = this.log.bind(this)
		this.direction = 1;
		//settings
		this.noise = 0;
		this.loopstart = 0;
		this.loopend = 0;
		this.mode = "linear";   // linear,bounce,random,wander,pattern/dream
		//init
		this.init();

		this.boundAdv = this.advance.bind(this);
		nx.aniItems.push(this.boundAdv)

	}

	util.inherits(ghost, widget);


	ghost.prototype.init = function() {
		this.draw();
	}

	ghost.prototype.watch = function() {
	}
		
		//sets a new component to be recorded
	ghost.prototype.connect = function(target) {
		var compIndex = this.components.length;
		this.components.push(target);
		target.tapeNum = compIndex;
		target.isRecording = true;
		target.recorder = this;
		this.buffer[compIndex] = new Object();
		for (var key in target.val) {
			this.buffer[compIndex][key] = new Array();
		}
		
	}
		
		//the actual recording function
	ghost.prototype.write = function(index, val) {
		if (this.moment>=this.maxLength) {
			this.stop();
		}
		for (var key in val) {
			if (this.buffer[index][key]) {
				// if an array or object, must make a copy, otherwise it is a reference to the original and will not record properly
				if (typeof val[key] == "object") {
					if (Array.isArray(val[key])) {
					//	this.buffer[index][key][this.moment] = val[key].slice()
					//	above line should work, but is still only a reference, not a copy
						this.buffer[index][key][this.moment] = JSON.parse(JSON.stringify(val[key]))
					} else {
						this.buffer[index][key][this.moment] = {}
						for (var subkey in val[key]) {
							this.buffer[index][key][this.moment][subkey] = val[key][subkey]
						}
					}
				} else {
					this.buffer[index][key][this.moment] = val[key];
				}
			}
		}
		this.draw();
	}
		

	ghost.prototype.draw = function() {

		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height)
		}

		var quad = this.width/4;
		var quad2 = this.width-quad;
		
		if (!this.recording) {
			with (this.context) {
				fillStyle = "#e33";
				beginPath()
				arc(quad,this.height/2,quad*0.8,0,Math.PI*2)
				fill()
				closePath();
				textAlign = "center"
				textBaseline = "middle"
				font = "normal "+this.height/6+"px courier"
				fillStyle = this.colors.fill
				fillText("rec",quad,this.height/2)
			}
		} else {
			with (this.context) {
				fillStyle = "#e33";
				fillRect(quad*0.4,quad*0.4,quad*1.2,quad*1.2)
			}
		}
		
		if (!this.playing) {
			with (this.context) {
				fillStyle = this.colors.border
				beginPath()
				arc(quad2,this.height/2,quad*0.8,0,Math.PI*2)
				fill()
				closePath()
				textAlign = "center"
				textBaseline = "middle"
				font = "normal "+this.height/6+"px courier"
				fillStyle = this.colors.fill
				fillText("play",quad2,this.height/2)
			}
		} else {
			with (this.context) {
				strokeStyle = this.colors.border
				lineWidth = this.width/30
				beginPath()
				arc(quad2,this.height/2,quad*0.8,0,Math.PI*2)
				stroke()
				closePath()
				var sec = ~~(this.needle/30)
				textAlign = "center"
				textBaseline = "middle"
				font = "normal "+this.height/3+"px courier"
				fillStyle = this.colors.border
				fillText(sec,quad2,this.height/2+2)
			}
		}
	}

	ghost.prototype.record = function() {
		if (!this.playing) {
			this.components = new Array();
			for (var key in nx.widgets) {
				this.connect(nx.widgets[key]);
			}
		}
		this.moment = 0;
		nx.aniItems.push(this.boundLog)
		this.recording = true;
	}

	ghost.prototype.log = function() {
		for (var i=0;i<this.components.length;i++) {
			var sender = this.components[i];
			this.write(this.components[i].tapeNum,this.components[i].val);
		}
		this.moment++;
	}

	ghost.prototype.stop = function() {
		nx.removeAni(this.boundLog);
		this.size = this.moment;
		this.recording = false;
		this.draw();
	}


	ghost.prototype.scan = function(x) {
		// loop through the widgets that were recorded
		for (var i=0;i<this.components.length;i++) {
			//sender is the current widget we're looking at
			var sender = this.components[i];
			//loop through the widget's gesture buffer
			for (var key in this.buffer[sender.tapeNum]) {

				if (this.buffer[sender.tapeNum][key]) {

					//create a new val object
					var val = new Object();
					//make sure we're not looking out of bounds of the buffer
					var max = this.buffer[sender.tapeNum][key][~~this.needle+1] ? this.buffer[sender.tapeNum][key][~~this.needle+1] : this.buffer[sender.tapeNum][key][~~this.needle]

					if (this.buffer[sender.tapeNum][key][~~this.needle-this.direction] != undefined && this.buffer[sender.tapeNum][key][~~this.needle] != this.buffer[sender.tapeNum][key][~~this.needle-this.direction]) {
						
						// if it's a number, interpolate
						if (typeof this.buffer[sender.tapeNum][key][~~this.needle] == "number") {
							// create the value pair
							val[key] = nx.interp(this.needle - ~~this.needle, this.buffer[sender.tapeNum][key][~~this.needle], max)
							val[key] += Math.random() * this.noise - this.noise/2;
							val[key] = nx.clip(val[key],0,1)
							//set the widget with the value from the buffer
							sender.set(val, true)
						} else {
							// otherwise, transfer the closest val as is
							val[key] = this.buffer[sender.tapeNum][key][~~this.needle]
							sender.set(val, true)
							
						}




					}
				}
			}
		}
	}



	//this.moment is for the record head
	//this.needle is for the playback head

	ghost.prototype.play = function(rate,start,end) {
		rate ? this.rate = rate : false;
		if (start) {
			this.needle = this.moment-1;
			this.start = start;
		} else {
			this.needle = this.moment-1;
			this.start = 0;
		} 
		if (this.mode=="linear") {
			this.direction = 1;
		}
		end ? this.end = end : this.end = 1
		this.playing = true;
	}

	ghost.prototype.pause = function() {
		this.playing = false;
	}

	ghost.prototype.loop = function() {
		
	}

	ghost.prototype.advance = function() {
		if (this.playing) {
			if (this.mode == "linear" || this.mode == "bounce") {
				this.needle += this.rate*this.direction;
			} else if (this.mode=="random") {
				this.needle = nx.random((this.end-this.start)*this.size)+this.start*this.size;
			} else if (this.mode=="wander") {
				var dir = 3
				this.needle > this.size*0.75 ? dir-- : null;
				this.needle < this.size*0.25 ? dir++ : null;
				this.needle += this.rate*this.direction * (nx.random(dir)-1);
			}

			if (this.needle/this.size < this.end && this.needle/this.size > this.start) {
				this.scan();
			} else if (this.looping) {
				if (this.mode=="linear") {
					this.needle = this.start*this.size + 1;
				} else {
					this.direction = this.direction * -1
				}
			} else {
				this.playing = false;
			}
			this.draw();
		}
	}
		

	ghost.prototype.click = function(e) {
		if (this.clickPos.x<this.width/2) {
			if (this.recording) {
				this.stop()
			} else {
				this.record()
			}
		} else {
			if (this.playing) {
				this.pause();
			} else {
				this.play();
			}
			this.draw();
		}
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],17:[function(require,module,exports){
	module.exports = {
	  banner: require('./banner'),
	  button: require('./button'),
	  colors: require('./colors'),
	  comment: require('./comment'),
	  crossfade: require('./crossfade'),
	  dial: require('./dial'),
	  envelope: require('./envelope'),
	  ghost: require('./ghost'),
	  joints: require('./joints'),
	  keyboard: require('./keyboard'),
	  matrix: require('./matrix'),
	  message: require('./message'),
	  meter: require('./meter'),
	  metro: require('./metro'),
	  metroball: require('./metroball'),
	  motion: require('./motion'),
	  mouse: require('./mouse'),
	  multislider: require('./multislider'),
	  multitouch: require('./multitouch'),
	  number: require('./number'),
	  position: require('./position'),
	  range: require('./range'),
	  select: require('./select'),
	  slider: require('./slider'),
	  string: require('./string'),
	  tabs: require('./tabs'),
	  text: require('./text'),
	  tilt: require('./tilt'),
	  toggle: require('./toggle'),
	  typewriter: require('./typewriter'),
	  vinyl: require('./vinyl'),
	  waveform: require('./waveform'),
	  windows: require('./windows')
	}
	},{"./banner":9,"./button":10,"./colors":11,"./comment":12,"./crossfade":13,"./dial":14,"./envelope":15,"./ghost":16,"./joints":18,"./keyboard":19,"./matrix":20,"./message":21,"./meter":22,"./metro":23,"./metroball":24,"./motion":25,"./mouse":26,"./multislider":27,"./multitouch":28,"./number":29,"./position":30,"./range":31,"./select":32,"./slider":33,"./string":34,"./tabs":35,"./text":36,"./tilt":37,"./toggle":38,"./typewriter":39,"./vinyl":40,"./waveform":41,"./windows":42}],18:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class joints      
		2D slider with connections to several points; a proximity-based multislider.
		```html
		<canvas nx="joints"></canvas>
		```
		<canvas nx="joints" style="margin-left:25px"></canvas>
	*/

	var joints = module.exports = function (target) {
		this.defaultSize = { width: 150, height: 150 };
		widget.call(this, target);
		
		/* @property {integer} nodeSize The size of the proximity points in pixels */
		this.nodeSize = this.width/14; 
		this.values = [0,0];

		/** @property {object}  val  
			| &nbsp; | data
			| --- | ---
			| *x* | x position of touch/mouse
			| *y* | y position of touch/mouse
			| *node0* | nearness to first node if within range (float 0-1)
			| *node1* | nearness to second node if within range (float 0-1)
			| *node2* | nearness to third node if within range (float 0-1)
			| etc... | &nbsp;
			
		*/
		this.val = {
			x: 0.35,
			y: 0.35,
			node1: 0
		}
		/** @property {array} joints An array of objects with x and y properties detailing coordinates of each proximity node.
		```js
			// The widget will now have only 2 proximity points, instead of 8
			joints1.joints = [
			&nbsp; { x: 20 , y: 100 },
			&nbsp; { x: 75 , y: 150 }
			]
		```
		 */
		this.joints = [
			{ x: this.width/1.2 , y: this.height/1.2 },
			{ x: this.width/2 , y: this.height/1.3 },
			{ x: this.width/4.2 , y: this.height/1.1 },
			
			{ x: this.width/1.4 , y: this.height/2.2 },
			{ x: this.width/2.1 , y: this.height/1.8 },
			{ x: this.width/5 , y: this.height/2.4 },
			
			{ x: this.width/2.8 , y: this.height/6 },
			{ x: this.width/6 , y: this.height/3.7 }
		
		]
		this.threshold = this.width / 3;
	}
	util.inherits(joints, widget);

	joints.prototype.init = function() {
		this.draw();
	}

	joints.prototype.draw = function() {
		this.erase();

		this.drawingX = this.val.x * this.width;
		this.drawingY = this.val.y * this.height;

		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
			if (this.val.x != null) {
				this.drawNode();
			}
			else {
				fillStyle = this.colors.border;
				font = "14px courier";
				fillText(this.default_text, 10, 20);
			}	
			fillStyle = this.colors.accent;
			strokeStyle = this.colors.border;
			for (var i in this.joints) {
				beginPath();
					arc(this.joints[i].x, this.joints[i].y, this.nodeSize/2, 0, Math.PI*2, true);					
					fill();
				closePath();
				var cnctX = Math.abs(this.joints[i].x-this.drawingX);
				var cnctY = Math.abs(this.joints[i].y-this.drawingY);
				var strength = cnctX + cnctY;
				if (strength < this.threshold) {
					beginPath();
						moveTo(this.joints[i].x, this.joints[i].y);
						lineTo(this.drawingX,this.drawingY);
						strokeStyle = this.colors.accent;
						lineWidth = math.scale( strength, 0, this.threshold, this.nodeSize/2, 5 );
						stroke();
					closePath();
					var scaledstrength = math.scale( strength, 0, this.threshold, 1, 0 );
					this.val["node"+i] = scaledstrength;
				}
			}
		}
		
		this.drawLabel();
	}

	joints.prototype.drawNode = function() {
		//stay within right/left bounds
		if (this.drawingX<(this.nodeSize)) {
			this.drawingX = this.nodeSize;
		} else if (this.drawingX>(this.width-this.nodeSize)) {
			this.drawingX = this.width - this.nodeSize;
		}
		//stay within top/bottom bounds
		if (this.drawingY < this.nodeSize) {
			this.drawingY = this.nodeSize;
		} else if (this.drawingY>(this.height-this.nodeSize)) {
			this.drawingY = this.height - this.nodeSize;
		}

		with (this.context) {
			globalAlpha=1;
			beginPath();
				fillStyle = this.colors.accent;
				strokeStyle = this.colors.border;
				lineWidth = this.lineWidth;
				arc(this.drawingX, this.drawingY, this.nodeSize, 0, Math.PI*2, true);					
				fill();
			closePath();
		}
	}

	joints.prototype.click = function() {
		this.val = new Object();
		this.val.x = this.clickPos.x/this.width;
		this.val.y = this.clickPos.y/this.height;
		this.draw();
		this.transmit(this.val);
		this.connections = new Array();
	    
	}

	joints.prototype.move = function() {
		this.val = new Object();
		if (this.clicked) {
			this.val.x = this.clickPos.x/this.width;
			this.val.y = this.clickPos.y/this.height;
			this.draw();
			this.transmit(this.val);
			this.connections = new Array();
		}
	}


	joints.prototype.release = function() {
			this.anix = this.deltaMove.x/this.width;
			this.aniy = (this.deltaMove.y)/this.height;
		
	}

	/** @method animate
		Add simple physics to the widget
		@param {string} [type] Currently accepts "bounce" or "none".
	*/

	joints.prototype.animate = function(aniType) {
		
		switch (aniType) {
			case "bounce":
				nx.aniItems.push(this.aniBounce.bind(this));
				break;
			case "none":
				nx.aniItems.splice(nx.aniItems.indexOf(this.aniBounce));
				break;
		}
		
	}

	joints.prototype.anix = 0;
	joints.prototype.aniy = 0;

	joints.prototype.aniBounce = function() {
		if (!this.clicked && this.val.x) {
			this.val.x += (this.anix);
			this.val.y += (this.aniy);
			this.anix = math.bounce(this.val.x, 0.1, 0.9, this.anix);
			this.aniy = math.bounce(this.val.y, 0.1, 0.9, this.aniy);
			this.draw();
			this.transmit(this.val);
		}
	}

	},{"../core/widget":3,"../utils/math":6,"util":47}],19:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');
	var drawing = require('../utils/drawing');
	var math = require('../utils/math');

	/** 
		@class keyboard      
		Piano keyboard which outputs MIDI
		```html
		<canvas nx="keyboard"></canvas>
		```
		<canvas nx="keyboard" style="margin-left:25px"></canvas>
	*/

	var keyboard = module.exports = function (target) {

		this.defaultSize = { width: 300, height: 75 };
		widget.call(this, target);

		/** @property {integer} octaves  Number of octaves on the keyboard 
			```js
				//This key pattern would put a black key between every white key
				keyboard1.octaves = 1
				keyboard1.init()
			```

		*/
		
		this.octaves = 3;

		this.white = {
			width:0,
			height:0
		}
		this.black = {
			width:0,
			height:0
		}
		this.wkeys = new Array();
		this.bkeys = new Array();

		/** @property {array} keypattern Array of 'w' and 'b' denoting the pattern of white and black keys. This can be customized! The pattern can be any number of keys, however each black key must be surrounded by two white keys.
		```js
			//This key pattern would put a black key between every white key
			keyboard1.keypattern = ['w','b','w','b','w','b','w','b','w','b','w','b']
			keyboard1.init()

			//This key pattern uses only white keys
			keyboard2.keypattern = ['w','w','w','w','w','w','w','w','w','w','w','w']
			keyboard2.init()
		```


		 */
		this.keypattern = ['w','b','w','b','w','w','b','w','b','w','b','w']
		this.keys = new Array();
		/** @property {integer} midibase The MIDI note value of the lowest note on the keyboard. Defaults to 48. */
		this.midibase = 48;
		this.lineWidth = 1;

		//to enable multitouch
		this.fingers = [
			{ 
				key: -1,
				pkey: -1

			}
		]
		this.multitouch = false; // will auto switch to true if experiences 2 simultaneous touches
		this.oneleft = false;

		/** @property {string} mode Play mode. Currently accepts "button" (default) or "sustain" in which each key acts as a toggle. */	
		this.mode = "button" // modes: "button", "sustain" and, possibly in future, "aftertouch"

		// for each key: x, y, w, h, color, on, note

		/** @property {object}  val   Core interactive values and data output
			| &nbsp; | data
			| --- | ---
			| *on* | 0 if noteon, 1 if noteoff
			| *note* | MIDI value of key pressed
			| *midi* | paired MIDI message as a string - example "20 0" - This is to allow for simultaneous arrival of the MIDI pair if sent as an OSC message. 
		*/
		this.val = {
			on: 0,
			note: 0,
			midi: "0 0"
		};

		this.init();
		
	}
	util.inherits(keyboard, widget);

	keyboard.prototype.init = function() {

		//recap from header
		this.white = {
			width:0,
			height:0
		}
		this.black = {
			width:0,
			height:0
		}
		this.wkeys = new Array();
		this.bkeys = new Array();

		/** @property {array} keys Array of key objects. This may be of use in combination with the keyboard.toggle method. */
		this.keys = new Array();

		//new stuff
		this.white.num = 0;
		for (var i=0;i<this.keypattern.length;i++) {
			this.keypattern[i]=='w' ? this.white.num++ : null;
		}
		this.white.num *= this.octaves;

		this.white.width = this.width/this.white.num
		this.white.height = this.height

		this.black.width = this.white.width*0.6
		this.black.height = this.height*0.6

		for (var i=0;i<this.keypattern.length*this.octaves;i++) {
			this.keys[i] = {
				note: i+this.midibase,
				on: false
			}
			switch (this.keypattern[i%this.keypattern.length]) {
				case 'w':
					this.keys[i].x =  this.wkeys.length*this.white.width,
					this.keys[i].y = 0,
					this.keys[i].w = this.white.width,
					this.keys[i].h = this.white.height,
					this.keys[i].type = 'w';
					this.keys[i].index = i;
					this.wkeys.push(this.keys[i]);

					break;
				case 'b':
					this.keys[i].x = this.wkeys.length*this.white.width - this.black.width/2,
					this.keys[i].y = 0,
					this.keys[i].w = this.black.width,
					this.keys[i].h = this.black.height,
					this.keys[i].type = 'b';
					this.keys[i].index = i;
					this.bkeys.push(this.keys[i]);
					break;
			}
		}


		this.draw();
	}

	keyboard.prototype.draw = function() {

		with (this.context) {
			strokeStyle = this.colors.border;
			lineWidth = 1;
				
			for (var i in this.wkeys) {
				fillStyle = this.wkeys[i].on ? this.colors.border : this.colors.fill
				strokeRect(this.wkeys[i].x,0,this.white.width,this.white.height);
				fillRect(this.wkeys[i].x,0,this.white.width,this.white.height);
			}
			for (var i in this.bkeys) {
				fillStyle = this.bkeys[i].on ? this.colors.border : this.colors.black
				fillRect(this.bkeys[i].x,0,this.black.width,this.black.height);
			}
			//strokeRect(0,0,this.width,this.height);
		}
		this.drawLabel();
	}

	/** @method toggle
		Manually toggle a key on or off, and transmit the new state.
		@param {object} [key]  A key object (from the .keys array) to be turned on or off
		@param {boolean} [on/off]  (Optional) Whether the key should be turned on (true) or off (false). If this parameter is left out, the key will switch to its opposite state.
		```js
		// Turns the first key on
		keyboard1.toggle( keyboard1.keys[0], true );
		```
	*/
	keyboard.prototype.toggle = function(key, data) {
		if (this.mode=="button") {
			if (key) {
				if (data) {
					key.on = data;
				} else {
					key.on = !key.on;
				}

				var on = key.on ? 1 : 0;
				var amp = math.invert(this.clickPos.y/this.height) * 128;
				amp = math.prune(math.clip(amp,5,128),0);

				this.val = { 
					on: on*amp,
					note: key.note,
					midi: key.note + " " + on
				};
				this.transmit(this.val);
				this.draw();
			}
		} else if (this.mode=="sustain") {
			if (key) {
				if (data) {
					key.on = data;
				} else {
					key.on = !key.on;
				}

				var on = key.on ? 1 : 0;
				var amp = math.invert(this.clickPos.y/this.height) * 128;
				amp = math.prune(math.clip(amp,5,128),0);

				this.val = { 
					on: on*amp,
					note: key.note,
					midi: key.note + " " + on
				};
				this.transmit(this.val);
				this.draw();
			}

		}

	}

	keyboard.prototype.whichKey = function (x, y){

		for (var i in this.bkeys) {
			if (drawing.isInside({"x":x,"y":y}, this.bkeys[i])) {
				return this.bkeys[i]
			}
		}

		var keyx = ~~(x/this.white.width);
		if (keyx>=this.wkeys.length) { keyx = this.wkeys.length-1 }
		if (keyx<0) { keyx = 0 }
		return this.wkeys[keyx];
	}

	keyboard.prototype.click = function(e) {

		if (this.clickPos.touches.length>1 || this.multitouch) {
			this.multitouch = true;
			if (this.clickPos.touches.length>=2 && this.oneleft) {
				this.oneleft = false;
			}
			this.keysinuse = new Array();
			for (var j=0;j<this.clickPos.touches.length;j++) {
				this.fingers[j] = {
					key: this.whichKey(this.clickPos.touches[j].x, this.clickPos.touches[j].y)
				}
				if (!this.fingers[j].key.on) {
					this.toggle(this.fingers[j].key, true)
				}
				this.keysinuse.push(this.fingers[j].key.index)
			}
			for (var j=0;j<this.keys.length;j++) {
				if (this.keys[j].on  && this.keysinuse.indexOf(this.keys[j].index)<0) {
					this.toggle(this.keys[j], false);
				}
			}
		} else {
			this.fingers[0].pkey = this.fingers[0].key;
			this.fingers[0].key = this.whichKey(this.clickPos.x, this.clickPos.y);
			this.toggle(this.fingers[0].key)
		}

	}

	keyboard.prototype.move = function(e) {
		if (this.clickPos.touches.length>1 || this.multitouch) {
			this.keysinuse = new Array();
			for (var j=0;j<this.clickPos.touches.length;j++) {
				this.fingers[j] = {
					key: this.whichKey(this.clickPos.touches[j].x, this.clickPos.touches[j].y)
				}
				if (!this.fingers[j].key.on) {
					this.toggle(this.fingers[j].key, true)
				}
				this.keysinuse.push(this.fingers[j].key.index)
			}
			for (var j=0;j<this.keys.length;j++) {
				if (this.keys[j].on  && this.keysinuse.indexOf(this.keys[j].index)<0) {
					this.toggle(this.keys[j], false);
				}
			}
		} else {
			this.fingers[0].pkey = this.fingers[0].key;
			this.fingers[0].key = this.whichKey(this.clickPos.x, this.clickPos.y);
			if (this.fingers[0].key && this.fingers[0].key.index != this.fingers[0].pkey.index) {
				this.toggle(this.fingers[0].pkey, false);
				this.toggle(this.fingers[0].key, true);
			}
		}
	}

	keyboard.prototype.release = function(e) {
		if (this.clickPos.touches.length>1 || this.multitouch) {
			this.keysinuse = new Array();
			for (var j=0;j<this.clickPos.touches.length;j++) { 
				if (this.oneleft && this.clickPos.touches.length==1) {
					break;
				}
				this.fingers[j] = {
					key: this.whichKey(this.clickPos.touches[j].x, this.clickPos.touches[j].y)
				}
				this.keysinuse.push(this.fingers[j].key.index)
			}
			for (var j=0;j<this.keys.length;j++) {
				if (this.keys[j].on  && this.keysinuse.indexOf(this.keys[j].index)<0) {
					this.toggle(this.keys[j], false);
				}
			}
			if (this.clickPos.touches.length==1) { this.oneleft = true }
		} else {
			if (this.mode=="button") {
				this.toggle(this.fingers[0].key, false);
			}
		}
	}








	},{"../core/widget":3,"../utils/drawing":5,"../utils/math":6,"util":47}],20:[function(require,module,exports){
	var math = require('../utils/math');
	var drawing = require('../utils/drawing');
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class matrix      
		Matrix of toggles, with sequencer functionality.
		```html
		<canvas nx="matrix"></canvas>
		```
		<canvas nx="matrix" style="margin-left:25px"></canvas>
	*/


	var matrix = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 100 };
		widget.call(this, target);
		

		/** @property {integer}  row   Number of rows in the matrix
		```js
			matrix1.row = 2;
			matrix1.init()
		```
		*/
		this.row = 4;

		/** @property {integer}  col   Number of columns in the matrix
		```js
			matrix1.col = 10;
			matrix1.init()
		```
		*/
		this.col = 4;
		
		this.cellHgt;
		this.cellWid;

		/** @property {array}  matrix   Nested array of matrix values. Cells can be manually altered using .matrix (see code), however this will *not* cause the new value to be transmit. See .setCell() to set/transmit cell values.
		```js
			//Turn on the cell at row 1 column 2
			matrix1.matrix[1][2] = 1
			matrix1.draw()


			//Turn off the cell at row 3 column 0
			matrix1.matrix[3][0] = 0
			matrix1.draw()
		```
		*/
		this.matrix;

		/** @property {object}  val   Core values and data output
			| &nbsp; | data
			| --- | ---
			| *row* | Current row being changed
			| *col* | Current column being changed
			| *level* | Whether cell is on or off (0 or 1)
			| *list * | Array of values in highlighted column (if sequencing)
		*/
		this.val = {
			row: 0,
			col: 0,
			level: 0,
			list: new Array()
		}

		//for mouse logic
		this.cur;
		this.prev;

		/** @property {boolean}  erasing   Whether or not mouse clicks will erase cells. Set to true automatically if you click on an "on" cell. */
		this.erasing = false;

		/** @property {integer}  place   When sequencing, the current column. */
		this.place = null;

		this.starttime;
		this.lastbeat;
		this.thisframe = 0;
		this.lastframe = 0;
		this.context.lineWidth = 1;

		this.sequencing = false;

		/** @property {integer}  cellBuffer  How much padding between matrix cells, in pixels */
		this.cellBuffer = 4;
		
		/** @property {string}  sequenceMode  Sequence pattern (currently accepts "linear" which is default, or "random") */
		this.sequenceMode = "linear"; // "linear" or "random". future options would be "wander" (drunk) or "markov"

		/** @property {integer}  bpm   Beats per minute (if sequencing)
		```js
			matrix1.bpm = 120;
		```
		*/
		this.bpm = 120;
		this.pbpm = this.bpm

		this.starttime = nx.starttime;

		this.init();
		
	}
	util.inherits(matrix, widget);



	matrix.prototype.init = function() {


		this.pmatrix = this.matrix ? this.matrix : false;

		this.matrix = null;
		// generate 2D matrix array
		this.matrix = new Array(this.col)
		for (var i=0;i<this.col;i++) {
			this.matrix[i] = new Array(this.row)
			for (var j=0;j<this.row;j++) {
				this.matrix[i][j] = this.pmatrix ? this.pmatrix[i] ? this.pmatrix[i][j] : 0 : 0; // set value of each matrix cell
			}
		}

		this.draw();

	  	this.life = this.unboundlife.bind(this)
		
	}

	matrix.prototype.draw = function() {

		this.erase();

		this.cellWid = this.width/this.col;
		this.cellHgt = this.height/this.row;

		for (var i=0;i<this.row;i++){
			for (var j=0;j<this.col;j++) {
				var st_x = j*this.cellWid // starting point(left)
				j==0 ? st_x += 0 : null;
				var st_y = i*this.cellHgt; // starting point(top)
				i==0 ? st_y += 0 : null;
				var boxwid = this.cellWid;
				var boxhgt = this.cellHgt;

				
				with (this.context) {
					strokeStyle = this.colors.border;
					lineWidth = this.cellBuffer;
					if (this.matrix[j][i] > 0) {
						fillStyle = this.colors.accent;
					} else {
						fillStyle = this.colors.fill;
					}
					fillRect(st_x+this.cellBuffer/2, st_y+this.cellBuffer/2, boxwid-this.cellBuffer, boxhgt-this.cellBuffer);
				
					// sequencer highlight
					if (this.place == j) {
						globalAlpha = 0.4;
						fillStyle = this.colors.border;
						fillRect(st_x, st_y, boxwid, boxhgt);
						globalAlpha = 1;
					}

				}
			} 
		}

		this.drawLabel();
	}



	matrix.prototype.click = function(e) {

		this.cur = {
			col: ~~(this.clickPos.x/this.cellWid),
			row: ~~(this.clickPos.y/this.cellHgt)
		}

		if (this.matrix[this.cur.col][this.cur.row]) {
			this.matrix[this.cur.col][this.cur.row] = 0;
			this.erasing = true;
		} else {
			this.matrix[this.cur.col][this.cur.row] = 1;
			this.erasing = false;
		}

		this.cur.value = this.matrix[this.cur.col][this.cur.row]
		this.prev = this.cur;

	//	var data = this.matrix[this.cur.col];
	//	data = data.join();
	//	data = data.replace(/\,/g," ");

		this.val = {
			row: this.cur.row,
			col: this.cur.col,
			level: this.cur.value
		}

		this.transmit(this.val);
		this.draw();
	}

	matrix.prototype.move = function(e) {
		if (this.clicked) {
			
			this.cur = {
				col: ~~(this.clickPos.x/this.cellWid),
				row: ~~(this.clickPos.y/this.cellHgt)
			}

			if (this.cur.row < this.row && this.cur.col < this.col && this.cur.row >= 0 && this.cur.col >=0) {
				if (this.cur.col!=this.prev.col || this.cur.row != this.prev.row) {
					if (this.erasing) {
						this.matrix[this.cur.col][this.cur.row] = 0;
					} else {
						this.matrix[this.cur.col][this.cur.row] = 1;
					}

					this.cur.value = this.matrix[this.cur.col][this.cur.row]
					this.prev = this.cur;

					this.val = {
						row: this.cur.row,
						col: this.cur.col,
						level: this.cur.value
					}

					this.transmit(this.val);
					this.draw();
				}
			}

		}
	}


	/** @method setCell
	Manually set an individual cell on/off and transmit the new value.
	@param {integer} [col] The column of the cell to be turned on/off
	@param {integer} [row] The row of the cell to be turned on/off
	@param {boolean} [on/off] Whether the cell should be turned on/off

	```js
		// Turns cell on at column 1 row 3
		matrix1.setCell(1,3,true);
	```
	*/
	matrix.prototype.setCell = function(col,row,on) {

		var value = on ? 1 : 0;
		this.matrix[col][row] = value

		this.val = {
			row: row,
			col: col,
			level: value
		}

		this.transmit(this.val);
		this.draw();

	}

	/** @method sequence
	@param {float} [bpm] Beats per minute of the pulse
	Turns the matrix into a sequencer.

	```js
		matrix1.sequence(240);
	```
	*/
	matrix.prototype.sequence = function(bpm) {

		if (bpm) {
			this.bpm = bpm;
		}	
		this.sequencing = true;
		requestAnimationFrame(this.seqStep.bind(this));

	}

	matrix.prototype.setBPM = function(bpm) {
		this.bpm = bpm
		//console.log(bpm)
		//nx.interval.bpm(this.pulse,bpm)
	}

	/** @method stop
	Stops the matrix sequencer.

	```js
		matrix1.stop();
	```
	*/
	matrix.prototype.stop = function() {
		this.sequencing = false;
	}

	matrix.prototype.seqStep = function() {

		if (this.bpm == 0) { this.bpm = 1 }

		//current time
		var now = new Date().getTime();

		//delta time since start
		var dt = now - this.starttime;

		if (this.bpm != this.pbpm) {

			//frame + decimal since last beat, in old bpm
			var timeP = (dt/(60000/this.pbpm))

			// scale to new bpm
			dt = timeP * (60000/this.bpm)

			//adjust the starttime reference point
			this.starttime = now - dt

			//calculate new frame #
			this.thisframe = ~~(dt/(60000/this.bpm));

		} else {

		    //this.thisframe is a constantly ascending integer counter
		    //to compare with this.lastframe to determine when to increment this.place
		    //this.thisframe IS NOT the current column.
		    //the current column is this.place, which is set conditionally below.
			this.thisframe = ~~(dt/(60000/this.bpm));

		}

		this.pbpm = this.bpm;

	    if (this.thisframe != this.lastframe) {

			this.lastbeat = now;

			if (this.sequenceMode=="linear") {
				this.place++;
			} else if (this.sequenceMode=="random") {
				this.place = math.random(this.col);
			}
			if (this.place>=this.col) {
				this.place = 0;
			}

			if (this.place==null) {
				this.place = 0;
			}

			this.jumpToCol(this.place);

	    }

		this.lastframe = this.thisframe;
	    if (this.sequencing) {
			requestAnimationFrame(this.seqStep.bind(this));
		}  
	}

	/** @method jumpToCol
	Jump to a certain column of the matrix, highlight it, and output its values as an array. Column numbers start at 0.

	```js
		matrix1.jumpToCol(1);
	```
	*/

	matrix.prototype.jumpToCol = function(place) {
			this.place = place
			this.val = {
				list: this.matrix[this.place]
			}
			this.transmit(this.val);
			this.draw();
	}


	matrix.prototype.customDestroy = function() {
		this.stop();
	}

	matrix.prototype.unboundlife = function() {
	  if (!this.clicked) {
	  this.newmatrix = []
	  for (var i=0;i<this.col;i++) {
	    this.newmatrix[i] = []
	    for (var j=0;j<this.row;j++) {
	      var total = 0
	      if (i-1 >= 0) {
	        total += this.matrix[i-1][j-1] ? this.matrix[i-1][j-1] : 0
	        total += this.matrix[i-1][j] ? this.matrix[i-1][j] : 0
	        total += this.matrix[i-1][j+1] ? this.matrix[i-1][j+1] : 0
	      }
	      total += this.matrix[i][j-1] ? this.matrix[i][j-1] : 0
	      total += this.matrix[i][j+1] ? this.matrix[i][j+1] : 0
	      if (i+1 < this.col) {
	        total += this.matrix[i+1][j-1] ? this.matrix[i+1][j-1] : 0
	        total += this.matrix[i+1][j] ? this.matrix[i+1][j] : 0
	        total += this.matrix[i+1][j+1] ? this.matrix[i+1][j+1] : 0
	      }

	      if (this.matrix[i][j]) {
	        if (total < 2) {
	          this.newmatrix[i][j] = 0
	        } else if (total ==2 || total == 3) {
	          this.newmatrix[i][j] = 1
	        } else if (total > 3) {
	          this.newmatrix[i][j] = 0
	        }
	      } else if (!this.matrix[i][j] && total == 3) {
	        this.newmatrix[i][j] = 1
	      } else {
	        this.newmatrix[i][j] = this.matrix[i][j]
	      }
	    }
	  }
	  this.matrix = this.newmatrix
	  }
	  this.transmit({ grid: this.matrix})
	  this.draw()
	}

	/** @method life
	Alters the matrix according to Conway's Game of Life. Matrix.life() constitutes one tick through the game. To simulate the game, you might use setInterval.

	```js
	  //one tick
	  matrix1.life();

	  //repeated ticks at 80ms
	  setInterval(matrix1.life,80)
	```
	*/
	matrix.prototype.life = function() { 
	  return false;
	}

	},{"../core/widget":3,"../utils/drawing":5,"../utils/math":6,"util":47}],21:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class message      
		Send a string of text.
		```html
		<canvas nx="message"></canvas>
		```
		<canvas nx="message" style="margin-left:25px"></canvas>
	*/

	var message = module.exports = function (target) {
		
		this.defaultSize = { width: 100, height: 30 };
		widget.call(this, target);
		

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *value* | Text of message, as string
		*/

		this.val = {
			value: "send a message"
		}

		/** @property {integer} size Text size in px */
		this.size = 14;
		
	}
	util.inherits(message, widget);

	message.prototype.init = function() {
		if (this.canvas.getAttribute("label")) {
			this.val.value = this.canvas.getAttribute("label");
		}
		//this.size = Math.sqrt((this.width * this.height) / (this.val.message.length));
		this.draw();
	}

	message.prototype.draw = function() {
		this.erase();
		with (this.context) {
			if (this.clicked) {
				fillStyle = this.colors.border;
			} else {
				fillStyle = this.colors.fill;
			}
			fillRect(0,0,this.width,this.height)
			
			if (this.clicked) {
				fillStyle = this.colors.black;
			} else {
				fillStyle = this.colors.black;
			}
			textAlign = "left";
			font = this.size+"px "+nx.font;
		}
		this.wrapText(this.val.value, 5, 1+this.size, this.width-6, this.size);
	}

	message.prototype.click = function(e) {
		this.draw();
		this.transmit(this.val);
	}

	message.prototype.release = function(e) {
		this.draw();
	}
	},{"../core/widget":3,"util":47}],22:[function(require,module,exports){
	var util = require('util');
	var drawing = require('../utils/drawing');
	var widget = require('../core/widget');

	/** 
	    
	    @public
	    @class meter 

	    Decibel level meter.

	    ```html
	    <canvas nx="meter"></canvas>
	    ```
	    <canvas nx="meter" style="margin-left:25px"></canvas>
	*/

	var meter = module.exports = function(target) {

	    // to update, eventually (note to self)
	    // possibly a less-frequent animation request, to lighten the graphics load
	    // option for stereo meter? i.e. optional third .setup(ctx,s1,s2) argument

	    this.defaultSize = { width: 20, height: 50 };
	    widget.call(this, target);

	    this.val = {
	        level: 0
	    }
	    this.dataArray;
	    this.bars = 10;

	    this.init();

	}
	util.inherits(meter, widget);


	meter.prototype.init = function(){
	   this.bar = {
	        x: 0,
	        y: 0,
	        w: this.width,
	        h: this.height/this.bars
	    }
	    with (this.context) {
	        fillStyle = this.colors.fill;
	        fillRect(0,0,this.width, this.height);
	    }
	}



	/** @method setup  
	    Connect the meter to an audio source and start the meter's graphics.
	    @param {audio context} [context] The audio context hosting the source node
	    @param {audio node} [source] The audio source node to analyze
	    */
	meter.prototype.setup = function(actx,source){
	    this.actx = actx;   
	    this.source = source;

	    this.analyser = this.actx.createAnalyser();
	    this.analyser.smoothingTimeConstant = 0.85;
	    this.analyser.fftsize = 1024;
	    this.bufferLength = this.analyser.frequencyBinCount;
	    this.dataArray = new Uint8Array(this.bufferLength);
	    this.source.connect(this.analyser);
	    
	    this.draw();
	}

	meter.prototype.draw = function(){
	    
	    if(this.dataArray) {
	        this.analyser.getByteTimeDomainData(this.dataArray);

	        var max = Math.max.apply(null, this.dataArray);
	        var min = Math.min.apply(null, this.dataArray);
	        var amp = max - min;
	        amp /= 240

	        //converts amps to db
	        var db = 20 * (Math.log(amp) / Math.log(10))

	        with (this.context){
	            fillStyle = this.colors.fill;
	            fillRect(0,0,this.width, this.height);

	            //scales: -40 to +10 db range => a number of bars
	            var dboffset = Math.floor((db + 40) / (50/this.bars) );
	           
	            for (var i = 0; i<this.bars; i++) {

	                // 0+ db is red
	                if(i >= this.bars*.8) {
	                    fillStyle = 'rgb(255,0,0)';

	                // -5 to 0 db is yellow
	                } else if (i < this.bars*.8 && i >= this.bars*.69) {
	                    fillStyle = 'rgb(255,255,0)';

	                // -40 to -5 db is green
	                } else if (i < this.bars*.69) {
	                    fillStyle = 'rgb(0,255,0)';
	                }

	                // draw bar
	                if (i<dboffset)
	                    fillRect(1,this.height-this.bar.h*i,this.width-2,this.bar.h-1);

	            }
	        }
	    }

	    window.requestAnimationFrame(this.draw.bind(this));
	    
	}
	    
	    
	},{"../core/widget":3,"../utils/drawing":5,"util":47}],23:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class metro      
		Bouncing ball metronome
		```html
		<canvas nx="metro"></canvas>
		```
		<canvas nx="metro" style="margin-left:25px"></canvas>
	*/

	var metro = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 20 };
		widget.call(this, target);

		//define unique attributes
		
		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *beat* | Which side the ball is bouncing on (0 if left, 1 if right)
		*/
		this.val = {
			beat: 0
		}

		this.x = 10;
		this.y = 10;
		this.loc = 10;
		this.nodeSize = 10;
		/** @property {float} speed Speed of the ball (default 1) */
		this.speed = 1;
		this.direction = 1;
		/** @property {string} orientation Orientation of metro. Default is "horizontal". */
		this.orientation = "horizontal"
		this.boundary = this.width

		nx.aniItems.push(this.advance.bind(this));
		this.active = true;
		
		this.init();
	}
	util.inherits(metro, widget);

	metro.prototype.init = function() {
		this.nodeSize = Math.min(this.width,this.height)/2;
		if (this.width<this.height) {
			this.orientation = "vertical"
			this.boundary = this.height
		} else {
			this.orientation = "horizontal"
			this.boundary = this.width
		}
		this.x = this.nodeSize;
		this.y = this.nodeSize;
		this.loc = this.nodeSize;

		this.draw();

	}

	metro.prototype.draw = function() {
		this.erase()
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height); 

			beginPath();
			fillStyle = this.colors.accent;
			arc(this.x, this.y, this.nodeSize, 0, Math.PI*2, true);					
			fill();
			closePath();
		}
		
		this.drawLabel();
	}

	metro.prototype.click = function() {
	}

	metro.prototype.move = function() {
		if (this.clicked) {
			this.speed -= (this.deltaMove.y / 50);
		}
	}

	metro.prototype.release = function() {
	}

	metro.prototype.advance = function() {
		if (this.speed>=0) {
			this.loc += this.speed * this.direction;
		} else {
			this.loc += this.speed * this.direction;
		}
		if (this.loc-this.nodeSize<0 || this.loc+this.nodeSize>this.boundary) {
			this.val.beat = math.scale(this.direction,-1,1,0,1)
			this.transmit(this.val);
			this.direction *= -1
		}
		if (this.orientation == "vertical") {
			this.y = this.loc
		} else {
			this.x = this.loc
		}
		this.draw();
	}

	metro.prototype.customDestroy = function() {
		nx.removeAni(this.advance.bind(this))
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],24:[function(require,module,exports){
	var math = require('../utils/math');
	var drawing = require('../utils/drawing');
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class metroball
		Bouncy-balls for rhythms
		```html
		<canvas nx="metroball"></canvas>
		```
		<!-- <canvas nx="metroball" style="margin-left:25px"></canvas> -->
	*/


	var metroball = module.exports = function (target) {
		this.defaultSize = { width: 300, height: 200 };
		widget.call(this, target);
		
		
		//define unique attributes
		this.CurrentBalls = new Array();
		this.ballpos = new Object();
		this.clickField = null;
		this.globalMetro;
		this.tempo = 1;
		this.tempoMarker = 150;
		this.quantize = false;
		this.tiltLR;
		this.tiltFB;
		this.z;

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *x* | x position of the bouncing ball
			| *side* | 0 or 1 int (which side is hit)
			| *ball* | Which ball is doing the bouncing
			| *all* | All three values together in a string
		*/
		this.val = {
			x: false,
			side: false,
			ball: false,
			all: false
		}

		nx.aniItems.push(this.metro.bind(this));

		this.init();
	}
	util.inherits(metroball, widget);

	metroball.prototype.init = function() {
		//this.metro();
		this.draw()
	}

	metroball.prototype.metro = function() {
		with (this.context) {
			clearRect(0,0, this.width, this.height);
		}
		this.drawSpaces();
		this.drawBalls();
		this.drawLabel();
	}

	metroball.prototype.drawSpaces = function() {
		
		with (this.context) {

			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height)
			
			fillStyle=this.colors.border;
			fillRect(0,0,this.width,this.height/4)

			font="normal "+this.height/8+"px "+nx.font;
			textAlign = "center";
			textBaseline = "middle"
			fillText("add",this.width/2,this.height/1.66)


			fillStyle = this.colors.fill;
			fillText("delete",this.width/2,this.height/8)
			
		}
	}

	metroball.prototype.drawBalls = function() {
		with (this.context) {
			for (var i=0;i<this.CurrentBalls.length;i++) {
				this.CurrentBalls[i].move();
				this.CurrentBalls[i].draw();
			}
		}
	}

	metroball.prototype.click = function(e) {
		
		this.ballpos = this.clickPos;

		if (this.clickPos.y < this.height/4) {
			this.deleteMB(this.ballpos);
		} else {
			this.addNewMB(this.ballpos);
		}
		

	}

	metroball.prototype.move = function(e) {
		this.ballpos = this.clickPos;
		
		if (this.clickPos.y < this.height/4) {
			this.deleteMB(this.ballpos);
		} else {
			this.addNewMB(this.ballpos);
		}
	}

	metroball.prototype.release = function(e) {
		this.clickField = null;
	}


	metroball.prototype.deleteMB = function(ballpos) {
		//delete in reverse order
		for (var i=this.CurrentBalls.length-1;i>=0;i--) {
			if (Math.abs(this.CurrentBalls[i].xpos-ballpos.x)<10) {
				this.CurrentBalls[i].kill();
			}
		}
		
		//reset CurrentBalls
		for (var i=0;i<this.CurrentBalls.length;i++) {
			this.CurrentBalls[i].thisIndex=i;
		}
	}

		
	metroball.prototype.addNewMB = function(ballpos) {
		var nextIndex = this.CurrentBalls.length;
		this.CurrentBalls[nextIndex] = new this.Ball(nextIndex, ballpos.x, ballpos.y, this);
	}


	metroball.prototype.toggleQuantization = function() {
		if (!this.quantize) {
			this.quantize = true;
		} else {
			this.quantize = false;
		}
	}

	/* Tilt */

	metroball.prototype.tilt = function(direction) {
		
		var scaledX = math.prune(this.tiltLR/90,3);
		var scaledY = math.prune(this.tiltFB/90,3);
		var scaledZ = math.prune(this.z,3);
		tilt = scaledX * 10;
		this.tempo = Math.pow(scaledY+1,3);
	}


	metroball.prototype.Ball = function(thisIndex, thisX, thisY, parent) {

		
		this.thisIndex = thisIndex;
		this.color = parent.colors.accent;
		this.space = {
			ypos1: 0,
			ypos2: parent.height,
			xpos1: 0,
			xpos2: parent.width,
			hgt: parent.height,
			wid: parent.width
		}
		this.xpos = thisX;
		this.ypos = thisY;
		this.size = 10;
		this.direction = 1;
		this.speed = (parent.height-this.ypos)/20;
		this.speedQ = 5;
		
		if (this.quantize) {
			this.ypos = parent.height-13;
		}
		
		this.move = function() {
			if (!this.quantize) {
				this.ypos = this.ypos + (this.speed * this.direction * parent.tempo);
			} else {
				this.ypos = this.ypos + (this.speedQ * this.direction * parent.tempo);	
			}
			
			if (this.ypos>(parent.height-this.size-2) || this.ypos<(this.size+2) ) {
				this.bounce();
			}
			
			if (this.ypos<this.space.ypos+this.size) {
				this.ypos=this.space.ypos+this.size+5;
			} else if (this.ypos>this.space.ypos+this.space.hgt-this.size) {
				this.ypos=this.space.ypos+this.space.hgt-this.size-5;
			}
			
			
			if (this.xpos<this.space.xpos) {
				this.xpos = this.space.xpos2;	
			} else if (this.xpos>this.space.xpos2) {
				this.xpos = this.space.xpos;	
			}
			
		}
		
		this.bounce = function() {
			var dirMsg = this.direction/2+1;
			this.bounceside = (this.direction+1)/2;
			this.direction = this.direction * (-1);
			var xMsg = math.prune(this.xpos/this.space.wid, 3);
			this.val = {
				x: xMsg,
				side: this.bounceside,
				ball: this.thisIndex,
				all: xMsg + " " + this.bounceside + " " + this.thisIndex
			}
			parent.transmit(this.val);
		}
		
		this.kill = function() {
			parent.CurrentBalls.splice(this.thisIndex,1);
		}
		
		this.draw = function() {
			
			with (parent.context) {
				beginPath();
				fillStyle = this.color;
				if (this.direction==1) {
					this.radius = this.size * (Math.abs((this.ypos-this.space.ypos-this.space.hgt/2)/(this.space.hgt-this.space.ypos)*2));
					this.radius = this.radius/2 + this.size/2;
					
					this.radius = this.size;
					
					this.radius = this.speed;
					
					this.radius = Math.abs(15-this.speed);
					
				} else {
					this.radius = this.size * Math.abs(2-(Math.abs((this.ypos-this.space.ypos-this.space.hgt/2)/(this.space.hgt-this.space.ypos)*2)));
					this.radius = this.radius/2 + this.size/2;
					
					this.radius = this.size;
					
					this.radius = Math.abs(15-this.speed);
				}
				arc(this.xpos, this.ypos, this.radius, 0, Math.PI*2, true);
				fill();
			}	
		}	
	}
	},{"../core/widget":3,"../utils/drawing":5,"../utils/math":6,"util":47}],25:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class motion      
		Mobile motion sensor. Does not work on all devices! <br> **Notes:** Clicking on this widget toggles it inactive or active. <br>
		We recommend not calling .init() on this object after the original initialization, because it will add additional redundant motion listeners to your document.
		```html
		<canvas nx="motion"></canvas>
		```
		<canvas nx="motion" style="margin-left:25px"></canvas>
	*/

	var motion = module.exports = function (target) {
		this.defaultSize = { width: 75, height: 75 };
		widget.call(this, target);
		
		this.motionLR;
		this.motionFB;
		this.z;
		/** @property {boolean} active Whether or not the motion widget is on (animating and transmitting data). */
		this.active = true;

		this.px = 0;
		this.py = 0;
		this.pz = 0;

		/** @property {object}  val  Object containing the core interactive aspects of the widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *x* | X-axis motion if supported (-1 to 1)
			| *y* | Y-axis motion if supported (-1 to 1)
			| *z* | Z-axis motion if supported (-1 to 1 or 0 to 360 depending on device)
		*/
		this.val = {
			x: 0,
			y: 0,
			z: 0
		}

		/** @property {string}  text   Text shown on motion object
		*/
		
		this.text = "Motion";
		this.init();

		this.boundMotion = this.motionlistener.bind(this)

		if (window.DeviceMotionEvent) {
			window.addEventListener('devicemotion', this.boundMotion, false);
		} else {
			with (this.context) {
				fillText("incompatible",0,0)
				this.active = false;
			}
		}
		
	}
	util.inherits(motion, widget);

	motion.prototype.deviceMotionHandler = function() {
		
		this.val = {
			x: math.prune(this.motionLR/10,4),
			y: math.prune(this.motionFB/10,4),
			z: math.prune(this.z/10,4)
		}

		this.transmit(this.val);
		
	}

	motion.prototype.motionlistener = function(e) {
		var data = e.acceleration
		
		if (this.active) {


			this.motionLR = nx.lp(this.canvasID+"motionx",data.x,20)
			this.motionFB = nx.lp(this.canvasID+"motiony",data.y,20)
			this.z = nx.lp(this.canvasID+"motionz",data.z,20)
	    	this.deviceMotionHandler()

	   		this.draw();

			if (data.x===null || data.x===undefined) {
				this.erase()
				with (this.context) {
					fillStyle = this.colors.fill
					fillRect(0,0,this.width,this.height)
					fillStyle = this.colors.black
					font="12px courier";
					textAlign = "center"
					fillText("no data",this.width/2,this.height/2)	
				}
				this.active = false;
			}
	 	}
	}

	motion.prototype.init = function() {
		this.draw()
	}

	motion.prototype.draw = function() {
		
		this.erase()

		with (this.context) {
		    fillStyle = this.colors.fill;
		    fillRect(0,0,this.width,this.height);
		    fillStyle = this.colors.accent;
		    var eighth = Math.PI/4
		    if (this.motionFB<0) {
				beginPath()
					moveTo(this.width/2,this.height/2)
					arc(this.width/2,this.height/2,this.width/2,eighth*5,eighth*7,false)
					globalAlpha = Math.pow(this.motionFB, 2)
					fill()
				closePath()
		    } else {
				beginPath()
					moveTo(this.width/2,this.height/2)
					arc(this.width/2,this.height/2,this.width/2,eighth*1,eighth*3,false)
					globalAlpha = Math.pow(this.motionFB, 2)
					fill()
				closePath()
		    }
		    if (this.motionLR<0) {
				beginPath()
					moveTo(this.width/2,this.height/2)
					arc(this.width/2,this.height/2,this.width/2,eighth*7,eighth*1,false)
					globalAlpha = Math.pow(this.motionLR, 2)
					fill()
				closePath()
		    } else {
				beginPath()
					moveTo(this.width/2,this.height/2)
					arc(this.width/2,this.height/2,this.width/2,eighth*3,eighth*5,false)
					globalAlpha = Math.pow(this.motionLR, 2)
					fill()
				closePath()
		    }
			beginPath()
				moveTo(this.width/2,this.height/2)
				arc(this.width/2,this.height/2,this.width/6,0,Math.PI*2,false)
				globalAlpha = Math.pow(this.z, 2)
				fill()
			closePath()
			globalAlpha = 1
		}
		this.drawLabel();
	}

	motion.prototype.click = function() {
		this.active = !this.active;
		this.draw()
	}

	motion.prototype.customDestroy = function() {
		this.active = false;
		window.removeEventListener("devicemotion",this.motionlistener,false);
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],26:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');
	var math = require('../utils/math');

	/** 
		@class mouse      
		Mouse tracker, relative to web browser window.
		```html
		<canvas nx="mouse"></canvas>
		```
		<canvas nx="mouse" style="margin-left:25px"></canvas>
	*/

	var mouse = module.exports = function (target) {
		
		this.defaultSize = { width: 98, height: 100 };
		widget.call(this, target);

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *x* | x value of mouse relative to browser
			| *y* | y value of mouse relative to browser
			| *deltax* | x change in mouse from last position
			| *deltay* | y change in mouse from last position
		*/
		this.val = {
			x: 0,
			y: 0,
			deltax: 0, 
			deltay: 0
		}
		this.inside = new Object();
		this.boundmove = this.preMove.bind(this)
		this.mousing = window.addEventListener("mousemove", this.boundmove, false);
		
		this.init();
	}
	util.inherits(mouse, widget);

	mouse.prototype.init = function() {
		
		this.inside.height = this.height;
		this.inside.width = this.width;
		this.inside.left = 0;
		this.inside.top = 0;
		this.inside.quarterwid = (this.inside.width)/4;
		 
		this.draw();
	}

	mouse.prototype.draw = function() {
		this.erase();

		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height); 

			var scaledx = -(this.val.x) * this.height;
			var scaledy = -(this.val.y) * this.height;
			var scaleddx = -(this.val.deltax) * this.height - this.height/2;
			var scaleddy = -(this.val.deltay) * this.height - this.height/2;

			fillStyle = this.colors.accent;
			fillRect(this.inside.left, this.inside.height, this.inside.quarterwid, scaledx);
			fillRect(this.inside.quarterwid, this.inside.height, this.inside.quarterwid, scaledy);
			fillRect(this.inside.quarterwid*2, this.inside.height, this.inside.quarterwid, scaleddx);
			fillRect(this.inside.quarterwid*3, this.inside.height, this.inside.quarterwid, scaleddy);

			globalAlpha = 1;
			fillStyle = this.colors.fill;
			textAlign = "center";
			font = this.width/7+"px "+this.font;
			fillText("x", this.inside.quarterwid*0 + this.inside.quarterwid/2, this.height-7);
			fillText("y", this.inside.quarterwid*1 + this.inside.quarterwid/2, this.height-7);
			fillText("dx", this.inside.quarterwid*2 + this.inside.quarterwid/2, this.height-7);
			fillText("dy", this.inside.quarterwid*3 + this.inside.quarterwid/2, this.height-7);

			globalAlpha = 1;
		}
		
		this.drawLabel();
	}

	mouse.prototype.move = function(e) {
		this.val = {
			deltax: e.clientX/window.innerWidth - this.val.x,
			deltay: math.invert(e.clientY/window.innerHeight) - this.val.y,
			x: e.clientX/window.innerWidth,
			y: math.invert(e.clientY/window.innerHeight)
		}
		this.draw();
		this.transmit(this.val);

	}

	mouse.prototype.customDestroy = function() {
		window.removeEventListener("mousemove",  this.boundmove, false);
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],27:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class multislider      
		Multiple vertical sliders in one interface.
		```html
		<canvas nx="multislider"></canvas>
		```
		<canvas nx="multislider" style="margin-left:25px"></canvas>
	*/
	var multislider = module.exports = function (target) {
		
		this.defaultSize = { width: 100, height: 75 };
		widget.call(this, target);
		
		/** @property {integer} sliders Number of sliders in the multislider. (Must call .init() after changing this setting, or set with .setNumberOfSliders) */
		this.sliders = 15;

		/** @property {array}  val   Array of slider values. <br> **Note:** This widget's output is not .val! Transmitted output is:	

			| &nbsp; | data
			| --- | ---
			| *(slider index)* | value of currently changed slider
			| list | all multislider values as list. (if the interface sends to js or node, this list will be an array. if sending to ajax, max7, etc, the list will be a string of space-separated values)

		*/
		
		this.val = new Object();
		for (var i=0;i<this.sliders;i++) {
			this.val[i] = 0.7;
		}
		this.sliderClicked = 0;
		this.oldSliderToMove;
		this.init();
	}
	util.inherits(multislider, widget);

	multislider.prototype.init = function() {
		this.val = new Object();
		for (var i=0;i<this.sliders;i++) {
			this.val[i] = 0.7;
		}
		this.realSpace = { x: this.width, y: this.height }
		this.sliderWidth = this.realSpace.x/this.sliders;
		this.draw();
	}

	multislider.prototype.draw = function() {
		this.erase();
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
			
			strokeStyle = this.colors.accent;
			fillStyle = this.colors.accent;
			lineWidth = 5;
	    	
			for(var i=0; i<this.sliders; i++) {
				beginPath();
				moveTo(i*this.sliderWidth, this.height-this.val[i]*this.height);
				lineTo(i*this.sliderWidth + this.sliderWidth, this.height-this.val[i]*this.height);
				stroke();
				lineTo(i*this.sliderWidth + this.sliderWidth, this.height);
				lineTo(i*this.sliderWidth,  this.height);
				globalAlpha = 0.3 - (i%3)*0.1;
				fill();
				closePath(); 
				globalAlpha = 1;
			//	var separation = i==this.sliders-1 ? 0 : 1;
			//	fillRect(i*this.sliderWidth, this.height-this.val[i]*this.height, this.sliderWidth-separation, this.val[i]*this.height)
			}
		}
		this.drawLabel();
	}

	multislider.prototype.click = function() {
		this.oldSliderToMove = false;
		this.move(true);
	}

	multislider.prototype.move = function(firstclick) {
		if (this.clicked) {


			if (this.clickPos.touches.length>1) {

				for (var i=0;i<this.clickPos.touches.length;i++) {
					var sliderToMove = Math.floor(this.clickPos.touches[i].x / this.sliderWidth);
					sliderToMove = math.clip(sliderToMove,0,this.sliders-1);
					this.val[sliderToMove] = math.clip(math.invert((this.clickPos.touches[i].y / this.height)),0,1);
				}

			} else {

				var sliderToMove = Math.floor(this.clickPos.x / this.sliderWidth);
				sliderToMove = math.clip(sliderToMove,0,this.sliders-1);
				this.val[sliderToMove] = math.clip(math.invert(this.clickPos.y / this.height),0,1);

				if (this.oldSliderToMove && this.oldSliderToMove > sliderToMove + 1) {
					var missed = this.oldSliderToMove - sliderToMove - 1;
					for (var i=1;i<=missed;i++) {
						this.val[sliderToMove+i] = this.val[sliderToMove] + (this.val[this.oldSliderToMove] - this.val[sliderToMove]) * ((i/(missed+1)));
					}
				} else if (this.oldSliderToMove && sliderToMove > this.oldSliderToMove + 1) {
					var missed = sliderToMove - this.oldSliderToMove - 1;
					for (var i=1;i<=missed;i++) {
						this.val[this.oldSliderToMove+i] = this.val[this.oldSliderToMove] + (this.val[sliderToMove] - this.val[this.oldSliderToMove]) * ((i/(missed+1)));
					}
				}
			
			}
			this.draw();
		}
		var msg = new Object()
		msg[sliderToMove] = this.val[sliderToMove]
		if (this.destination=="js" || this.destination=="node") {
			msg["list"] = this.val;
		} else {
			msg["list"] = new String();
			for (var key in this.val) { msg["list"] += this.val[key] + " " }
		}
		this.transmit(msg);
		this.oldSliderToMove = sliderToMove;
		
	}

	/** @method setNumberOfSliders
	@param {integer} [num] New number of sliders in the multislider */
	multislider.prototype.setNumberOfSliders = function(numOfSliders) {
		this.sliders = numOfSliders;
		this.val = new Array();
		for (var i=0;i<this.sliders;i++) {
			this.val.push(0.7);
		}
		this.sliderWidth = this.realSpace.x/this.sliders;
		this.init();
	}

	/** @method setSliderValue
	Sets a slider to new value and transmits.
	@param {integer} [slider] Slider to set (slider index starts at 0)
	@param {integer} [value] New slider value */
	multislider.prototype.setSliderValue = function(slider,value) {
		this.val[slider] = value;
		this.draw();
		var msg = new Object();
		msg[slider] = this.val[slider]
		if (this.destination=="js" || this.destination=="node") {
			msg["list"] = this.val;
		} else {
			msg["list"] = new String();
			for (var key in this.val) { msg["list"] += this.val[key] + " " }
		}
		this.transmit(msg);
	}

	},{"../core/widget":3,"../utils/math":6,"util":47}],28:[function(require,module,exports){
	var math = require('../utils/math');
	var drawing = require('../utils/drawing');
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class multitouch      
		Multitouch 2d-slider with up to 5 points of touch.
		```html
		<canvas nx="multitouch"></canvas>
		```
		<canvas nx="multitouch" style="margin-left:25px"></canvas>
	*/

	var multitouch = module.exports = function (target) {
		
		this.defaultSize = { width: 200, height: 200 };
		widget.call(this, target);
		
		//unique attributes
		this.nodeSize = this.width/10;

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *touch1.x* | x position of first touch
			| *touch1.y* | y position of first touch
			| *touch2.x* | x position of second touch (if 2 touches)
			| *touch2.y* | y position of second touch (if 2 touches)
			| *etc* | &nbsp;
		*/
		this.val = {
			touch1: {
				x: 0,
				y: 0
			}
		}
		
		this.nodes = new Array();
		
		/** @property {string}  text  Text that will show when object is static */
		this.text = "multitouch";

		this.rainbow = ["#00f", "#04f", "#08F", "0AF", "0FF"];
		
		/** @property {string}  mode   "normal" or "matrix" mode. "matrix" mode has a GUI of discrete touch areas.
		*/
		this.mode = "normal";

		/** @property {integer}  rows   How many rows in the matrix (matrix mode only)
		*/
		this.rows = 10;

		/** @property {integer}  cols   How many rows in the matrix (matrix mode only)
		*/
		this.cols = 10;

		/** @property {array}  matrixLabels  An array of strings that can provide text labels on cells of the matrix. If shorter than the matrix cells, the array will repeat.
		```
			this.mode = "matrix"
			this.matrixLabels = [ "A", "A#", "B", "C" ]
			this.init();
		```
		*/
		this.matrixLabels = false;

		this.init();
	}
	util.inherits(multitouch, widget);

	multitouch.prototype.init = function() {
		this.nodeSize = this.width/10;
		this.draw();
	}

	multitouch.prototype.draw = function() {
		this.erase();
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);

			var count = 0;

			if (this.mode == "matrix") {
				for (var j=0;j<this.rows;j++) {
					for (var i=0;i<this.cols;i++) {
						with (this.context) {
							beginPath();
								fillStyle = this.colors.accent;
								strokeStyle = this.colors.border;
								lineWidth = 1;
								var circx = i*this.width/this.cols + (this.width/this.cols)/2;
								var circy = j*this.height/this.rows + (this.height/this.rows)/2;
								arc(circx, circy, (this.height/this.rows)/2, 0, Math.PI*2, true);					
								stroke();
								fillStyle = this.colors.border;
								textAlign = "center";
								textBaseline = "middle";
								if (this.matrixLabels) {
									fillText(this.matrixLabels[count%this.matrixLabels.length], circx, circy);
									count++
								} 
								var thisarea = {
									x: i*this.width/this.cols,
									y: j*this.height/this.rows,
									w: this.width/this.cols,
									h: this.height/this.rows
								}
								if (this.clickPos.touches.length>=1) {
									for (var k=0;k<this.clickPos.touches.length;k++) {
										if (drawing.isInside(this.clickPos.touches[k],thisarea)) {
											globalAlpha=0.5;
											fillStyle = this.colors.accent;
											fill();
											globalAlpha=0.3;
											fillStyle = this.rainbow[k];
											fill();
											globalAlpha=1;
										}
									}
								}
							closePath();
						}
					}
				}
			} else {
				if (this.clickPos.touches.length>=1) {
					for (var i=0;i<this.clickPos.touches.length;i++) {
						
						with (this.context) {
							globalAlpha=0.5;
							beginPath();
							fillStyle = this.colors.accent;
							strokeStyle = this.colors.border;
							lineWidth = this.lineWidth;
							arc(this.clickPos.touches[i].x, this.clickPos.touches[i].y, this.nodeSize, 0, Math.PI*2, true);					
							fill();
							//	stroke();
							closePath();
							globalAlpha=0.3;
							beginPath();
							fillStyle = this.rainbow[i];
							strokeStyle = this.colors.border;
							lineWidth = this.lineWidth;
							arc(this.clickPos.touches[i].x, this.clickPos.touches[i].y, this.nodeSize, 0, Math.PI*2, true);					
							fill();
							//	stroke();
							closePath(); 
							globalAlpha=1;
						}

					}
				}
				else {
					this.setFont()
					fillStyle = this.colors.border;
					fillText(this.text, this.width/2, this.height/2);
					globalAlpha = 1;
				}
			}
		}
		this.drawLabel();
	}

	multitouch.prototype.click = function() {
		this.draw();
		this.sendit();
	}

	multitouch.prototype.move = function() {
		if (this.clicked) {
			this.draw();
			this.sendit();
		}
	}

	multitouch.prototype.release = function() {

		if(!this.clicked) {
			this.clickPos.touches = new Array();
			for (var i=0;i<5;i++) {
				this.val["touch"+i] = {
					x: 0,
					y: 0
				}
			}
			this.transmit(this.val);
		}
		
		this.draw();
		this.sendit();
		
	}

	multitouch.prototype.sendit = function() {
		this.val = new Object();
		for (var i=0;i<this.clickPos.touches.length;i++) {
			this.val["touch"+i] = {
				x: this.clickPos.touches[i].x/this.canvas.width,
				y: math.invert(this.clickPos.touches[i].y/this.canvas.height)
			}
		}
		this.transmit(this.val);
	}
	},{"../core/widget":3,"../utils/drawing":5,"../utils/math":6,"util":47}],29:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class number      
		Number box
		```html
		<canvas nx="number"></canvas>
		```
		<canvas nx="number" style="margin-left:25px"></canvas>
	*/

	var number = module.exports = function (target) {
		this.defaultSize = { width: 50, height: 20 };
		widget.call(this, target);
		
		/** @property {object}  val    
			| &nbsp; | data
			| --- | ---
			| *value* | Number value
			
			```js
				// Sets number1.val.value to 20
				number1.set({
				&nbsp; value: 20
				})
			```
		*/
		this.val = {
			value: 0
		}

		/** @property {float}  min   The minimum number allowed. Default is -20000.

			```js
			    // only allow positive numbers
				number1.min = 0;
			```
		*/
		this.min = -20000

		/** @property {float}  max   The maximum number allowed. Default is 20000.

			```js
			    // only allow negative numbers
				number1.max = 0;
			```
		*/
		this.max = 20000

		/** @property {float}  step   The increment. Default is 1.

			```js
			    // count by 10s
				number1.step = 10;
			```
		*/
		this.step = 1


		/** @property {float}  rate   Sensitivity of dragging. Default is .25

			```js
			    // For fine tuning 
				number1.rate = .001;
			```
		*/
		this.rate = .25

		/** @property {integer}  decimalPlaces   How many decimal places on the number. This applies to both the output and the interface text. Default is 2. To achieve an int (non-float), set decimalPlaces to 0.

			```js
				// For an int counter
				number1.decimalPlaces = 0;
			```
		*/ 
		this.decimalPlaces = 3;
		this.lostdata = 0;
		this.actual = 0;

		this.init();
	}
	util.inherits(number, widget);

	number.prototype.init = function() {

		this.canvas.ontouchstart = null;
		this.canvas.ontouchmove = null;
		this.canvas.ontouchend = null;

		var htmlstr = '<input type="text" class="nx" nx="number" id="'+this.canvasID+'" style="height:'+this.height+'px;width:'+this.width+'px;font-size:'+this.height/2+'px;"></input><canvas height="1px" width="1px" style="display:none"></canvas>'                   
		var canv = this.canvas
		var cstyle = this.canvas.style
		var parent = canv.parentNode;
		var newdiv = document.createElement("span");
		newdiv.innerHTML = htmlstr;
		parent.replaceChild(newdiv,canv)
		this.el = document.getElementById(this.canvasID)
		for (var prop in cstyle)
	    	this.el.style[prop] = cstyle[prop];

		this.canvas = document.getElementById(this.canvasID);
		this.canvas.style.fontSize = this.height * .6 + "px"
		this.canvas.style.textAlign = "left"
		this.canvas.style.backgroundColor = this.colors.fill
		this.canvas.style.highlight = this.colors.fill
		this.canvas.style.border = "none"
		this.canvas.style.outline = "none"
		this.canvas.style.padding = "4px 10px"
		this.canvas.style.cursor = "pointer"
		this.canvas.style.display = "block"

		this.canvas.addEventListener("blur", function () {
		  //this.canvas.style.border = "none";

		  this.canvas.style.backgroundColor = this.colors.fill;
		  this.canvas.style.color = this.colors.black;
		  if (this.canvas.value != this.val.value) {
		  	this.actual = parseFloat(this.canvas.value)
		  	this.actual = math.clip(this.actual,this.min,this.max)
			this.actual = math.prune(this.actual,this.decimalPlaces);
		  	this.set({"value": this.actual}, true)
		  }
		}.bind(this));

		this.canvas.addEventListener("keydown", function (e) {
		  if (e.which < 48 || e.which > 57) {
		  	if (e.which != 189 && e.which != 190 && e.which != 8) {
		  		e.preventDefault();
		  	}
		  }
		  if (e.which==13) {
		  /*	this.actual = parseFloat(this.canvas.value)
		  	this.actual = math.clip(this.actual,this.min,this.max)
			this.actual = math.prune(this.actual,this.decimalPlaces);
		  	this.set({"value": this.actual}, true) */
		  	//this.canvas.style.outline = "none";
		  	this.canvas.blur()
		  }
		}.bind(this));

		
	  // Setup interaction
	  if (nx.isTouchDevice) {
	    this.canvas.ontouchstart = this.preTouch;
	    this.canvas.ontouchmove = this.preTouchMove;
	    this.canvas.ontouchend = this.preTouchRelease;
	  } else {
	    this.canvas.addEventListener('mousedown', this.preClick, false);
	  }


	  this.canvas.style.userSelect = "none !important";
	  this.canvas.style.mozUserSelect = "none !important";
	  this.canvas.style.webkitUserSelect = "none !important";

	  this.draw();
	}

	number.prototype.draw = function() {

		this.canvas.value = this.val.value;

	}


	number.prototype.click = function(e) {
		this.canvas.readOnly = true
		this.actual = this.val.value
	}

	number.prototype.move = function(e) {
		if (this.clicked) {
		  	this.canvas.style.border = "none";

			this.actual -= (this.deltaMove.y*(this.rate*this.step));
			this.actual = math.clip(this.actual,this.min,this.max)
			this.val.value = Math.floor(this.actual / this.step) * this.step;
			this.val.value = math.prune(this.val.value,this.decimalPlaces);
			this.draw();
			this.transmit(this.val);
		}
	}


	number.prototype.release = function(e) {
		if (!this.hasMoved && this.canvas.readOnly) {
			this.canvas.readOnly = false;
			this.canvas.focus()
			this.canvas.setSelectionRange(0, this.canvas.value.length)
			this.canvas.style.backgroundColor = this.colors.accent;
			this.canvas.style.color = this.colors.fill;
		}
	}

	},{"../core/widget":3,"../utils/math":6,"util":47}],30:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class position      
		Two-dimensional touch slider.
		```html
		<canvas nx="position"></canvas>
		```
		<canvas nx="position" style="margin-left:25px"></canvas>
	*/

	var position = module.exports = function (target) {

		// define a default size
		this.defaultSize = { width: 150, height: 100 };

		widget.call(this, target);
		
		/** @property {integer} nodeSize Size of touch node graphic. */
		this.nodeSize = 15;

		/** @property {object}  val   val is an object containing the main interactive / actionable aspects of the widget.
			| &nbsp; | data
			| --- | ---
			| *x* | x position of slider (float 0-1)
			| *y* | y position of slider (float 0-1)
		*/
		this.val = {
			x: 0.5,
			y: 0.5
		}
		
		this.init();
	}

	// inherit the widget object template
	util.inherits(position, widget);

	// .init() is called automatically when the widget is created on a webpage.
	position.prototype.init = function() {
		this.nodeSize = Math.min(this.height,this.width)/10;
		this.nodeSize = Math.max(this.nodeSize,10)
		this.actualWid = this.width - this.nodeSize*2;
		this.actualHgt = this.height - this.nodeSize*2;
		this.draw();
	}

	// .draw() should be used for any graphics activity
	position.prototype.draw = function() {
		this.erase();
		with (this.context) {

			// use this.colors.fill for the widget background color (default: very light gray)
			// use this.colors.border for any extra structural needs (default: light gray)
			// use this.colors.accent for important or highlighted parts (default: a bright color)
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);

			var drawingX = this.val.x * this.actualWid + this.nodeSize
			var drawingY = math.invert(this.val.y) * this.actualHgt + this.nodeSize

			//stay within right/left bounds
			if (drawingX<(this.nodeSize)) {
				drawingX = this.nodeSize;
			} else if (drawingX>(this.width-this.nodeSize)) {
				drawingX = this.width - this.nodeSize;
			}
			//stay within top/bottom bounds
			if (drawingY<(this.nodeSize)) {
				drawingY = this.nodeSize;
			} else if (drawingY>(this.height-this.nodeSize)) {
				drawingY = this.height - this.nodeSize;
			}
		
			with (this.context) {

				// draw the touch point
				beginPath();
				fillStyle = this.colors.accent;
				arc(drawingX, drawingY, this.nodeSize, 0, Math.PI*2, true);					
				fill();
				closePath();

				if (this.clicked) {
					// draw the emphasis circle
					beginPath();
					fillStyle = this.colors.accent;
					arc(drawingX, drawingY, this.nodeSize*2, 0, Math.PI*2, true);					
					fill();
					closePath();

				}
			}
		}
		
		this.drawLabel();
	}

	// .click() will be fired when the interface is interacted with
	// this.clicked is automatically set to true
	// this.clickPos is already and object with x and y properties detailing click point.
	position.prototype.click = function() {
		this.val.x = this.clickPos.x;
		this.val.y = this.clickPos.y;
		this.scaleNode();
		this.val["state"] = "click"
		this.transmit(this.val);
		this.draw();
	}

	// .move() will be fired when the interface is moved over after being clicked
	// this.clickPos is already and object with x and y properties detailing click point.
	position.prototype.move = function() {
		this.val.x = this.clickPos.x;
		this.val.y = this.clickPos.y;
		this.scaleNode();
		this.val["state"] = "move"
		this.transmit(this.val);
		this.draw();
	}

	// .release() will be fired on mouse up (unclick)
	position.prototype.release = function() {
		this.val.x = this.clickPos.x;
		this.val.y = this.clickPos.y;
		this.scaleNode();
		this.val["state"] = "release"
		this.transmit(this.val);
		this.draw();
	}

	/* TOUCH SPECIFIC EVENTS
	 currently, ontouch, ontouchmove, and ontouchrelease automatically execute .click, .move, and .release
	 so you only need to write one function for these events, and they will be touch compatible by default
	 however if you would like to create a touch-specific event you may define the following functions.
	 in these functions, .clickPos and .clicked will refer to your touch interactions.

	position.prototype.touch = function() {

	}

	position.prototype.touchmove = function() {
		
	}

	position.prototype.touchrelease = function() {
		
	}




	*/



	/* 
	 extra functions pertaining only to this widget 
	*/

	position.prototype.scaleNode = function() {
		var actualX = this.val.x - this.nodeSize;
		var actualY = this.val.y - this.nodeSize;
		var clippedX = math.clip(actualX/this.actualWid, 0, 1);
		var clippedY = math.clip(actualY/this.actualHgt, 0, 1);
		this.val.x = math.prune(clippedX, 3)
		this.val.y = math.prune(clippedY, 3)
		this.val.y = math.invert(this.val.y);
	}

	/** @method animate
		Adds animation to the widget.
		@param {string} [type] Type of animation. Currently accepts "none" or "bounce", in which case the touch node can be tossed and bounces.
	*/
	position.prototype.animate = function(aniType) {
		
		switch (aniType) {
			case "bounce":
				nx.aniItems.push(this.aniBounce.bind(this));
				break;
			case "none":
				nx.aniItems.splice(nx.aniItems.indexOf(this.aniBounce));
				break;
		}
		
	}

	position.prototype.aniBounce = function() {
		if (!this.clicked && this.val.x) {
			this.val.x += (this.deltaMove.x/2)/this.width;
			this.val.y -= (this.deltaMove.y/2)/this.height;
			this.val["state"] = "animated";
			if (math.bounce(this.val.x, 0, 1, this.deltaMove.x) != this.deltaMove.x) {
				this.deltaMove.x = math.bounce(this.val.x, 0, 1, this.deltaMove.x);
				this.val["state"] = "bounce";
			}
			if (this.val.y >= 1 || this.val.y <= 0) {
				this.deltaMove.y = math.bounce(this.val.y, 0, 1, this.deltaMove.y) * -1;
				this.val["state"] = "bounce";
			}
			this.transmit(this.val);
			this.draw();
		}
	}

	position.prototype.customDestroy = function() {
		nx.removeAni(this.aniBounce);
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],31:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');
	var math = require('../utils/math')

	/** 
		@class range      
		Range slider
		```html
		<canvas nx="range"></canvas>
		```
		<canvas nx="range" style="margin-left:25px"></canvas>
	*/

	var range = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 30 };
		widget.call(this, target);

		/** @property {object}  val  Object containing core interactive aspects of widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *start* | Range start value (float 0-1)
			| *stop* | Range end value (float 0-1)
			| *size* | Distance between ends (float 0-1)
		*/
		this.val = {
			start: 0.3,
			stop: 0.7,
			size: 0.4
		}


		// handling horiz possibility
		/** @property {boolean}  hslider  Whether or not the slider is a horizontal slider. Default is false, but set automatically to true if the slider is wider than it is tall. */  
		this.hslider = false;
		this.handle;
		this.relhandle;
		this.cap;
		this.firsttouch = "start";

		/** @property {string}  mode  Mode of interaction. "edge" mode lets you drag each edge of the range individually. "area" mode (default) lets you drag the range as a whole (with parallel mouse movement) or scale the range as a whole (with transverse mouse movement) */
		this.mode = "area" // modes: "edge", "area"
		this.touchdown = new Object();
		this.init();
	}
	util.inherits(range, widget);

	range.prototype.init = function() {

		//decide if hslider or vslider
		if (this.height>=this.width) {
			this.hslider = false;
		} else {
			this.hslider = true;
		}

		if (this.canvas.getAttribute("label")!=null) {
			this.label = this.canvas.getAttribute("label");
		}

		this.draw();
	}

	range.prototype.draw = function() {
		this.erase();
			
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
		
			if (!this.hslider) {
				
				if (nx.showLabels && this.label) {
					save();
		 			translate(this.width/2, 0);
					rotate(Math.PI/2);
					this.setFont();
					fillText(this.label, this.height/2, 0);
					globalAlpha = 1;
					restore();
				}

				var x1 = 0;
				var y1 = this.height-this.val.stop*this.height;
				var x2 = this.width;
				var y2 = this.height-this.val.start*this.height;

				fillStyle = this.colors.accent;
				fillRect(x1,y1,x2-x1,y2-y1);

			} else {
				
				if (nx.showLabels && this.label) {
					this.setFont();
					fillText(this.label, this.width/2, this.height/2);
					globalAlpha = 1;
				}

				var x1 = this.val.start*this.width;
				var y1 = 0;
				var x2 = this.val.stop*this.width;
				var y2 = this.height;
			   
			
				fillStyle = this.colors.accent;
				fillRect(x1,y1,x2-x1,y2-y1);
			}
		}
	}

	range.prototype.click = function() {
		if (this.mode=="edge") {
			if (this.hslider) {
				if (Math.abs(this.clickPos.x-this.val.start*this.width) < Math.abs(this.clickPos.x-this.val.stop*this.width)) {
					this.firsttouch = "start"
				} else {
					this.firsttouch = "stop"
				}
			} else {
				if (Math.abs(Math.abs(this.clickPos.y-this.height)-this.val.start*this.height) < Math.abs(Math.abs(this.clickPos.y-this.height)-this.val.stop*this.height)) {
					this.firsttouch = "start"
				} else {
					this.firsttouch = "stop"
				}
			}
		} else if (this.mode=="area") {
			this.touchdown = {
				x: this.clickPos.x,
				y: this.clickPos.y
			}
			this.startval = new Object();
			this.startval.size = this.val.stop - this.val.start;
			this.startval.loc = this.val.start + this.startval.size/2;
		}
		this.move();
	}

	range.prototype.move = function() {

		if (this.mode=="edge") {
			if (this.hslider) {
				if (this.firsttouch=="start") {
					this.val.start = this.clickPos.x/this.width;
					if (this.clickPos.touches.length>1) {
						this.val.stop = this.clickPos.touches[1].x/this.width;
					}
				} else {
					this.val.stop = this.clickPos.x/this.width;
					if (this.clickPos.touches.length>1) {
						this.val.start = this.clickPos.touches[1].x/this.width;
					}
				}
			} else {
				if (this.firsttouch=="start") {
					this.val.start = math.invert(this.clickPos.y/this.height);
					if (this.clickPos.touches.length>1) {
						this.val.stop = math.invert(this.clickPos.touches[1].y/this.height);
					}
				} else {
					this.val.stop = math.invert(this.clickPos.y/this.height);
					if (this.clickPos.touches.length>1) {
						this.val.start = math.invert(this.clickPos.touches[1].y/this.height);
					}
				}
			}

			if (this.val.stop < this.val.start) {
				this.tempstart = this.val.start;
				this.val.start = this.val.stop;
				this.val.stop = this.tempstart;
				if (this.firsttouch=="start") {
					this.firsttouch = "stop";
				} else {
					this.firsttouch = "start";
				}
			} 
			this.val = {
				start: math.clip(this.val.start, 0, 1),
				stop: math.clip(this.val.stop, 0, 1),
			} 
			this.val['size'] = math.prune(math.clip(Math.abs(this.val.stop - this.val.start), 0, 1), 3)
		
			this.draw();

			this.transmit(this.val);

		} else if (this.mode=="area") {

			if (this.hslider) {
				var moveloc = this.clickPos.x/this.width;
				var movesize = (this.touchdown.y - this.clickPos.y)/this.height;
			} else {
				var moveloc = nx.invert(this.clickPos.y/this.height);
				var movesize = (this.touchdown.x - this.clickPos.x)/this.width;
			//	moveloc *= -1;
				movesize *= -1;
			}
			movesize /= 3;
			var size = this.startval.size + movesize;
			size = math.clip(size,0.001,1);

			this.val = {
				start: moveloc - size/2,
				stop: moveloc + size/2
			}

			this.val.start = math.clip(this.val.start,0,1);
			this.val.stop = math.clip(this.val.stop,0,1);

			this.draw();

			this.transmit(this.val);

		}
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],32:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class select    
		HTML-style option selector. Outputs the chosen text string. <br> **Note:** Currently the canvas is actaully replaced by an HTML select object. Any inline style on your canvas may be lost in this transformation. To style the resultant select element, we recommend creating CSS styles for the select object using its ID or the select tag.
		```html
		<canvas nx="select" choices="sine,saw,square"></canvas>
		```
		<canvas nx="select" choices="sine,saw,square"></canvas>
	*/

	var select = module.exports = function (target) {
		this.defaultSize = { width: 200, height: 30 };
		widget.call(this, target);
		
		/** @property {array} choices Desired choices, as an array of strings. Can be initialized with a "choices" HTML attribute of comma-separated text (see example above). 
		```js
		select1.choices = ["PartA", "PartB", "GoNuts"]
		select1.init()
		```
		*/
		this.choices = [ ];

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *value* | Text string of option chosen
		*/
		this.val = new Object();

		
		this.canvas.ontouchstart = null;
		this.canvas.ontouchmove = null;
		this.canvas.ontouchend = null;
		
		if (this.canvas.getAttribute("choices")) {
			this.choices = this.canvas.getAttribute("choices");
			this.choices = this.choices.split(",");
		}

		var htmlstr = '<select id="'+this.canvasID+'" class="nx" nx="select" style="height:'+this.height+'px;width:'+this.width+'px;font-size:'+this.height/2+'px;" onchange="'+this.canvasID+'.change(this)"></select><canvas height="1px" width="1px" style="display:none"></canvas>'                   
		var canv = this.canvas
		var cstyle = this.canvas.style
		var parent = canv.parentNode;
		var newdiv = document.createElement("span");
		newdiv.innerHTML = htmlstr;
		parent.replaceChild(newdiv,canv)
		this.sel = document.getElementById(this.canvasID)
		this.sel.style.float = "left"
		this.sel.style.display = "block"
		for (var prop in cstyle)
	    	this.sel.style[prop] = cstyle[prop];

		this.canvas = document.getElementById(this.canvasID);

	    this.canvas.style.backgroundColor = this.colors.fill;
	    this.canvas.style.color = this.colors.black;
		
		for (var i=0;i<this.choices.length;i++) {
			var option=document.createElement("option");
			option.text = this.choices[i];
			option.value = this.choices[i];
			this.canvas.add(option,null);
		}
		



	}
	util.inherits(select, widget);

	select.prototype.init = function() {

	    this.canvas.style.backgroundColor = this.colors.fill;
	    this.canvas.style.color = this.colors.black;
		
		for (var i=0;i<this.choices.length;i++) {
			var option=document.createElement("option");
			option.text = this.choices[i];
			option.value = this.choices[i];
			this.canvas.add(option,null);
		}
	}

	// should have a modified "set" function
	select.prototype.change = function(thisselect) {
		this.val.text = thisselect.value;
		this.transmit(this.val);
	}

	select.prototype.draw = function() {

	    this.canvas.style.backgroundColor = this.colors.fill;
	    this.canvas.style.color = this.colors.black;

	}
	},{"../core/widget":3,"util":47}],33:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class slider      
		Slider (vertical or horizontal)
		```html
		<canvas nx="slider"></canvas>
		```
		<canvas nx="slider" style="margin-left:25px"></canvas>
	*/

	var slider = module.exports = function (target) {
		this.defaultSize = { width: 30, height: 100 };
		widget.call(this, target);

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *value* | Slider value (float 0-1)
		*/
		this.val.value = 0.7

		/** @property {string}  mode   Set "absolute" or "relative" mode. In absolute mode, slider will jump to click/touch position. In relative mode, it will not.
		```js
		nx.onload = function() {
		&nbsp; // Slider will not jump to touch position.
		&nbsp; slider1.mode = "relative" 
		}
		```
		*/
		this.mode = "absolute";

		/** @property {boolean}  hslider   Whether or not the slider should be horizontal. This is set to true automatically if the canvas is wider than it is tall. To override the default decision, set this property to true to create a horizontal slider, or false to create a vertical slider.
		
		```js
		nx.onload = function() {
		&nbsp; //forces horizontal slider 
		&nbsp; slider1.hslider = true
		&nbsp; slider1.draw();
		&nbsp; //forces vertical slider 
		&nbsp; slider2.hslider = false
		&nbsp; slider2.draw();
		}
		```
		*/
		this.hslider = false;
		this.label = "";
		this.handle;
		this.relhandle;
		this.cap;


		this.init();
	}
	util.inherits(slider, widget);

	slider.prototype.init = function() {

		//decide if hslider or vslider
		if (this.height>=this.width) {
			this.hslider = false;
		} else {
			this.hslider = true;
		}

		if (this.canvas.getAttribute("label")!=null) {
			this.label = this.canvas.getAttribute("label");
		}

		this.draw();
	}

	slider.prototype.draw = function() {
		
		this.erase();
			
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
		
			if (!this.hslider) {

				if (nx.showLabels) {

					save();
		 			translate(this.width/2, 0);
					rotate(Math.PI/2);
					this.setFont();
					fillText(this.label, this.height/2, 0);
					globalAlpha = 1;
					restore();
				
				}

				var x1 = 0;
				var y1 = this.height-this.val.value*this.height;
				var x2 = this.width;
				var y2 = this.height;

			
				fillStyle = this.colors.accent;
				if (this.val.value>0.01) {
					fillRect(x1,y1,x2-x1,y2-y1);
				}

			} else {
				
				if (nx.showLabels) {
					this.setFont();
					fillText(this.label, this.width/2, this.height/2);
					globalAlpha = 1;
				
				}

				var x1 = 0;
				var y1 = 0;
				var x2 = this.val.value*this.width;
				var y2 = this.height;
			   
			
				fillStyle = this.colors.accent;
				if (this.val.value>0.01) {
					fillRect(x1,y1,x2-x1,y2-y1);
				}
			}
		}
	}

	slider.prototype.click = function() {
		this.move();
	}

	slider.prototype.move = function() {
		if (this.hslider) {
			this.handle = this.clickPos.x;
			this.relhandle = this.deltaMove.x;
			this.cap = this.width;
		} else {
			this.handle = this.clickPos.y;
			this.relhandle = this.deltaMove.y*-1;
			this.cap = this.height
		}

		if (this.mode=="absolute") {
			if (this.clicked) {
				if (!this.hslider) {
					this.val.value = math.prune((Math.abs((math.clip(this.clickPos.y/this.height, 0, 1)) - 1)),3);
				} else {	
					this.val.value = math.prune(math.clip(this.clickPos.x/this.width, 0, 1),3);
				}
				this.draw();
			}
		} else if (this.mode=="relative") {
			if (this.clicked) {
				if (!this.hslider) {
					this.val.value = math.clip((this.val.value + ((this.deltaMove.y*-1)/this.height)),0,1);
				} else {
					this.val.value = math.clip((this.val.value + ((this.deltaMove.x)/this.width)),0,1);
				}
				this.draw();
			}
		}
		this.transmit(this.val);
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],34:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class string      
		Animated model of a plucked string interface.
		```html
		<canvas nx="string"></canvas>
		```
		<canvas nx="string" style="margin-left:25px"></canvas>
	*/

	var string = module.exports = function (target) {
		this.defaultSize = { width: 150, height: 75 };
		widget.call(this, target);
		
		/** @property {object}  val  Object containing the core interactive aspects of the widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *string* | Index of the string that is plucked (starts at 0)
			| *x* | Where on the string the pluck occured (float 0-1);
		*/
		this.val = {
			string: 0,
			x: 0
		}
		/** @property {integer}  numberOfStrings How many strings in the widget. We recommend setting this property with .setStrings() */
		this.numberOfStrings = 10;
		this.strings = new Array();
		this.abovestring = new Array();
		/** @property {integer}  friction  How quickly the string slows down */
		this.friction = 1;
		
		var stringdiv;

		this.init();

		nx.aniItems.push(this.draw.bind(this));
	}
	util.inherits(string, widget);

	string.prototype.init = function() {
		stringdiv = this.height/(this.numberOfStrings + 1);
		for (var i=0;i<this.numberOfStrings;i++) {
			this.strings[i] = {
				x1: this.lineWidth,
				y1: stringdiv*(1+i),
				x2: this.width - this.lineWidth,
				y2: stringdiv*(i+1),
				held: false, // whether or not it's gripped
				vibrating: false, // whether or not its vibrating
				force: 0, // amount of force of pull on string
				maxstretch: 0, // vibration cap (in Y domain)
				stretch: 0, // current point vibrating in y domain
				direction: 0, // which direction it's vibrating
				above: false // is mouse above or below string
			};
		}
		this.draw();
	}

	string.prototype.pulse = function() {
		this.draw();
	}

	/* @method setStrings Sets how many strings are in the widget.
		```js
		string1.setStrings(20);
		``` 
		*/
	string.prototype.setStrings = function(val) {
		this.numberOfStrings = val;
		this.strings = new Array();
		this.init();
	}

	string.prototype.draw = function() {
		this.erase();
		this.makeRoundedBG();
		with (this.context) {
			strokeStyle = this.colors.border;
			fillStyle = this.colors.fill;
			lineWidth = this.lineWidth;
		//	stroke();
			fill();
			
			strokeStyle = this.colors.accent;

			for (var i = 0;i<this.strings.length;i++) {

				var st = this.strings[i];

				if (st.vibrating) {
					if (st.maxstretch < 0) {
						st.vibrating = false;
						st.held = false;
					}
					st.stretch = st.stretch + st.direction;
					
					if (Math.abs(st.stretch) > st.maxstretch) {
						//st.direction *= (-0.99);
						st.direction *= -1;
						st.stretch = st.stretch + st.direction;
						st.maxstretch = st.maxstretch - this.friction;

						st.direction = (st.direction / Math.abs(st.direction)) * (st.maxstretch/1)
					}

					beginPath();
					moveTo(st.x1, st.y1);
					quadraticCurveTo(this.width/2, st.y1+st.stretch, st.x2, st.y2);
					stroke();
					closePath();
					st.on = true;


				} else if (st.held) {
						//will draw rounded
						//if mouse is higher than string and gripup
						//or if mouse is 
						//	if (this.clickPos.y-st.y1<0 && st.gripup || this.clickPos.y-st.y1>0 && !st.gripup) {
						beginPath();
						moveTo(st.x1, st.y1);
						quadraticCurveTo(this.clickPos.x, this.clickPos.y, st.x2, st.y2);
						stroke();
						closePath();
						st.on = true;	
						/*	} else {
						beginPath();
						moveTo(st.x1, st.y1);
						lineTo(st.x2, st.y2);
						stroke();
						closePath();
					} */
				} else {
					beginPath();
					moveTo(st.x1, st.y1);
					lineTo(st.x2, st.y2);
					stroke();
					closePath();
					if (st.on) {
						st.on = false;
					}
				}
			}
		}
		this.drawLabel();
	}

	string.prototype.click = function() {
		for (var i = 0;i<this.numberOfStrings;i++) {
			this.strings[i].above = (this.clickPos.y<this.strings[i].y1);
		}
		this.draw();
	}

	string.prototype.move = function() {
		if (this.clicked) {
			for (var i = 0;i<this.strings.length;i++) {

				//if crosses string
				if (this.strings[i].above != (this.clickPos.y<this.strings[i].y1) ) {
					this.strings[i].held = true;
					this.strings[i].above ^= true;
				}

				if (this.strings[i].held && Math.abs(this.clickPos.y - this.strings[i].y1) > this.height/(this.strings.length*3)) {

					this.pluck(i)
					
				}
			}
		}
	}

	string.prototype.release = function() {
		for (var i = 0;i<this.strings.length;i++) {
			if (this.strings[i].held) {
				this.pluck(i);
			}
		}	
	}

	string.prototype.pluck = function(which) {
		var i = which;
		this.val = {
			string: i,
			x: this.clickPos.x/this.width
		}
		this.transmit(this.val);
		this.strings[i].held = false;
		this.strings[i].force = this.clickPos.y - this.strings[i].y1;
		this.strings[i].maxstretch = Math.abs(this.clickPos.y - this.strings[i].y1);
		this.strings[i].stretch = this.clickPos.y - this.strings[i].y1;
		this.strings[i].vibrating = true;
		this.strings[i].direction = (this.clickPos.y - this.strings[i].y1)/Math.abs(this.clickPos.y - this.strings[i].y1) * ((this.clickPos.y - this.strings[i].y1)/-1.2);
	}

	string.prototype.customDestroy = function() {
		nx.removeAni(this.draw.bind(this));
	}
	},{"../core/widget":3,"util":47}],35:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class tabs   
		
		```html
		<canvas nx="tabs"></canvas>
		```
		<canvas nx="tabs" style="margin-left:25px"></canvas>
	*/

	var tabs = module.exports = function(target) {
		
		this.defaultSize = { width: 150, height: 50 };
		widget.call(this, target);
		
		//define unique attributes
		this.choice = 0;
		this.val = {
			index: 0,
			text: ""
		}
		this.tabwid = 0;
		this.options = ["one", "two", "three"]
		//init
		this.init();

	}

	util.inherits(tabs, widget);


	tabs.prototype.init = function() {
		this.draw();
	}


	tabs.prototype.draw = function() {

		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height)

			textAlign = "center"
			textBaseline = "middle"
			font = "normal "+this.height/5+"px courier"
		}

		this.tabwid = this.width/this.options.length

		for (var i=0;i<this.options.length;i++) {
			if (i==this.choice) {
				var tabcol = this.colors.accent;
				var textcol = this.colors.white;
			} else {
				var tabcol = this.colors.fill;
				var textcol = this.colors.black;
				globalAlpha = 0.7;
			}
			with (this.context) {
				fillStyle=tabcol;
				fillRect(this.tabwid*i,0,this.tabwid,this.height)
				if (i!=this.options.length-1) {
					beginPath();
					moveTo(this.tabwid*(i+1),0)
					lineTo(this.tabwid*(i+1),this.height)
					lineWidth = 1;
					strokeStyle = this.colors.border
					stroke()
					closePath()
				}
				fillStyle=textcol;
				font = this.fontSize+"px "+this.font;
				fillText(this.options[i],this.tabwid*i+this.tabwid/2,this.height/2)
			}
			
		}
	}


	tabs.prototype.click = function() {
		this.choice = ~~(this.clickPos.x / this.tabwid);
		this.val = {
			index: this.choice,
			text: this.options[this.choice]
		}
		this.transmit(this.val)
		this.draw();
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],36:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class text    
		Text editor. Outputs the typed text string when Enter is pressed. <br> **Note:** Currently the canvas is actaully replaced by an HTML textarea object. Any inline style on your canvas may be lost in this transformation. To style the resultant textarea element, we recommend creating CSS styles for the textarea element using its ID or the textarea tag.
		```html
		<canvas nx="text"></canvas>
		```
		<canvas nx="text"></canvas>
	*/

	var text = module.exports = function (target) {
		this.defaultSize = { width: 200, height: 100 };
		widget.call(this, target);

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *text* | Text string
		*/
		this.val = {
			text: ""
		}

		var htmlstr = '<textarea id="'+this.canvasID+'" style="height:'+this.height+'px;width:'+this.width+'px;" onkeydown="'+this.canvasID+'.change(event,this)"></textarea><canvas height="1px" width="1px" style="display:none"></canvas>'                   
		var canv = this.canvas
		var cstyle = this.canvas.style
		var parent = canv.parentNode;
		var newdiv = document.createElement("span");
		newdiv.innerHTML = htmlstr;
		parent.replaceChild(newdiv,canv)
		this.el = document.getElementById(this.canvasID)

		for (var prop in cstyle)
	    	this.el.style[prop] = cstyle[prop];

		this.el.style.display = "block"
		this.el.style.backgroundColor = this.colors.fill
		this.el.style.border = "none"
		this.el.style.color = this.colors.black
		this.el.style.outline = "none"
		this.el.style.resize = "none"
		this.el.style.boxSizing = "border-box"
		this.el.style.padding = "5px"
		this.el.style.fontFamily = nx.font
		this.el.style.fontSize = "16px"


		this.canvas = document.getElementById(this.canvasID);


	}
	util.inherits(text, widget);

	text.prototype.init = function() {
		
		this.canvas.ontouchstart = null;
		this.canvas.ontouchmove = null;
		this.canvas.ontouchend = null;

	    this.canvas.style.backgroundColor = this.colors.fill;
	    this.canvas.style.color = this.colors.black;
		
	}

	// should have a modified "set" function
	text.prototype.change = function(e,el) {
		this.val.text = el.value
		if (e.which=="13") {
			this.transmit(this.val)
			this.val.text = ""
			this.draw()
			e.preventDefault()
		}
	}

	text.prototype.draw = function() {
		// needed especially for ghost
		this.el.value = this.val.text 
		
	    this.canvas.style.backgroundColor = this.colors.fill;
	    this.canvas.style.color = this.colors.black;
	}
	},{"../core/widget":3,"util":47}],37:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class tilt      
		Mobile and Mac/Chrome-compatible tilt sensor. May not work on all devices! <br> **Notes:** Clicking on this widget toggles it inactive or active. <br>
		We recommend not calling .init() on this object after the original initialization, because it will add additional redundant tilt listeners to your document.
		```html
		<canvas nx="tilt"></canvas>
		```
		<canvas nx="tilt" style="margin-left:25px"></canvas>
	*/

	var tilt = module.exports = function (target) {
		this.defaultSize = { width: 50, height: 50 };
		widget.call(this, target);
		
		this.tiltLR;
		this.tiltFB;
		this.z;
		/** @property {boolean} active Whether or not the tilt widget is on (animating and transmitting data). */
		this.active = true;

		/** @property {object}  val  Object containing the core interactive aspects of the widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *x* | X-axis rotation if supported (-1 to 1)
			| *y* | Y-axis rotation if supported (-1 to 1)
			| *z* | Z-axis rotation if supported (-1 to 1 or possibly 0 to 360 depending on device)
		*/
		this.val = {
			x: 0,
			y: 0,
			z: 0
		}

		/** @property {string}  text   Text shown on tilt object
		*/
		
		this.text = "TILT";
		this.init();

		this.boundChromeTilt = this.chromeTilt.bind(this)
		this.boundMozTilt = this.mozTilt.bind(this)

		if (window.DeviceOrientationEvent) {
			window.addEventListener('deviceorientation', this.boundChromeTilt, false);
		} else if (window.OrientationEvent) {
		  	window.addEventListener('MozOrientation', this.boundMozTilt, false);
		} else {
		  	console.log("Not supported on your device or browser.")
		}
		
	}
	util.inherits(tilt, widget);

	tilt.prototype.deviceOrientationHandler = function() {
		
		this.val = {
			x: math.prune(this.tiltLR/90,3),
			y: math.prune(this.tiltFB/90,3),
			z: math.prune(this.z,3)
		}

		if (this.active) {
			this.transmit(this.val);
		}
		
	}

	tilt.prototype.chromeTilt = function(eventData) {
	    this.tiltLR = eventData.gamma;
			this.tiltFB = eventData.beta;
			this.z = eventData.alpha
	    this.deviceOrientationHandler();
	    this.draw();
	}

	tilt.prototype.mozTilt = function(eventData) {
	    this.tiltLR = eventData.x * 90;
	    // y is the front-to-back tilt from -1 to +1, so we need to convert to degrees
	    // We also need to invert the value so tilting the device towards us (forward) 
	    // results in a positive value. 
	    this.tiltFB = eventData.y * -90;
	    this.z = eventData.z;
	    this.deviceOrientationHandler();
	    this.draw();
	}

	tilt.prototype.init = function() {
		this.draw();
	}

	tilt.prototype.draw = function() {
		
		this.erase();

		with (this.context) {
			fillStyle = this.colors.fill;
		    fillRect(0,0,this.width,this.height);

			save(); 
			translate(this.width/2,this.height/2)
			rotate(-this.val.x*Math.PI/2);
			translate(-this.width/2,-this.height/2)
		    globalAlpha = 0.4;

		    if (this.active) {
		    	fillStyle = this.colors.accent;
		    } else {
		    	fillStyle = this.colors.border;
		    }

			fillRect(-this.width,this.height*(this.val.y/2)+this.height/2,this.width*3,this.height*2)
			font = "bold "+this.height/5+"px "+this.font;
			textAlign = "center";
			fillText(this.text, this.width/2, this.height*(this.val.y/2)+this.height/2+this.height/15);
			globalAlpha = 1;
			restore();
		}
		this.drawLabel();
	}

	tilt.prototype.click = function() {
		this.active = !this.active;
	}

	tilt.prototype.customDestroy = function() {
		this.active = false;
		window.removeEventListener("deviceorientation",this.boundChromeTilt,false);
		window.removeEventListener("mozOrientation",this.boundMozTilt,false);
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],38:[function(require,module,exports){
	var drawing = require('../utils/drawing');
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class toggle      
		On/off toggle
		```html
		<canvas nx="toggle"></canvas>
		```
		<canvas nx="toggle" style="margin-left:25px"></canvas>
	*/

	var toggle = module.exports = function (target) {
		this.defaultSize = { width: 50, height: 50 };
		widget.call(this, target);
		
		this.mindim = this.height>this.width ? this.width : this.height;

		/** @property {object}  val  Object containing the core interactive aspects of the widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *value*| 1 if on, 0 if off
		*/
		this.val = {
			value: 0
		}
		this.init();
	}
	util.inherits(toggle, widget);

	toggle.prototype.init = function() {
		this.fontsize = this.mindim/4;
		this.draw();
	}

	toggle.prototype.draw = function() {
		
		this.erase()

		with (this.context) {
			if (this.val.value) {
				fillStyle = this.colors.accent;
			} else {
				fillStyle = this.colors.fill;
			}
			fillRect(0,0,this.width,this.height);
			if (this.val.value) {
				this.setFont();
				fillStyle = "#424242";
				globalAlpha = 1;
				fillText("STOP", this.width/2, this.height/2);	
			} else { //MODIFIED BY KARL
				this.setFont();
				fillText("START", this.width/2, this.height/2);
				globalAlpha = 1;
			}
		}

		this.drawLabel();
		
	}

	toggle.prototype.click = function() {
		if (!this.val.value) {
			this.val.value = 1;
		} else {
			this.val.value = 0;
		}
		this.draw();
		this.transmit(this.val);
	}
	},{"../core/widget":3,"../utils/drawing":5,"util":47}],39:[function(require,module,exports){
	var drawing = require('../utils/drawing');
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class typewriter      
		Computer keyboard listener and visualization. (Desktop only) <br> **Note:** Clicking on the widget toggles it inactive or active, which can be useful if you need to temporarily type without triggering the widget's events.
		```html
		<canvas nx="typewriter"></canvas>
		```
		<canvas nx="typewriter" style="margin-left:25px"></canvas>
	*/

	var typewriter = module.exports = function(target) {
		this.defaultSize = { width: 300, height: 100 };
		widget.call(this, target);

		
		this.letter = ""
		this.keywid = this.width/14.5;
		this.keyhgt = this.height/5

		/** @property {boolean}  active  Whether or not the widget is on (listening for events and transmitting values).*/ 
		this.active = true;

		/** @property {object}  val  Object containing the core interactive aspects of the widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *key* | symbol of key pressed (example: "a")
			| *ascii* | ascii value of key pressed (example: 48)
			| *on* | 0 if key is being pressed, 1 if key is being released
		*/
		this.val = {
			key: "",
			ascii: 0,
			on: 0
		}

		this.rows = [
			[
				{ symbol: "`", value: 192, width: 1, on: false },
				{ symbol: "1", value: 49, width: 1, on: false  },
				{ symbol: "2", value: 50, width: 1, on: false  },
				{ symbol: "3", value: 51, width: 1, on: false  },
				{ symbol: "4", value: 52, width: 1, on: false  },
				{ symbol: "5", value: 53, width: 1, on: false  },
				{ symbol: "6", value: 54, width: 1, on: false  },
				{ symbol: "7", value: 55, width: 1, on: false  },
				{ symbol: "8", value: 56, width: 1, on: false  },
				{ symbol: "9", value: 57, width: 1, on: false  },
				{ symbol: "0", value: 48, width: 1, on: false  },
				{ symbol: "-", value: 189, width: 1, on: false  },
				{ symbol: "=", value: 187, width: 1, on: false  },
				{ symbol: "delete", value: 46, width: 1.5, on: false  }
			],
			[
				{ symbol: "tab", value: 9, width: 1.5, on: false  },
				{ symbol: "q", value: 81, width: 1, on: false  },
				{ symbol: "w", value: 87, width: 1, on: false  },
				{ symbol: "e", value: 69, width: 1, on: false  },
				{ symbol: "r", value: 82, width: 1, on: false  },
				{ symbol: "t", value: 84, width: 1, on: false  },
				{ symbol: "y", value: 89, width: 1, on: false  },
				{ symbol: "u", value: 85, width: 1, on: false  },
				{ symbol: "i", value: 73, width: 1, on: false  },
				{ symbol: "o", value: 79, width: 1, on: false  },
				{ symbol: "p", value: 80, width: 1, on: false  },
				{ symbol: "[", value: 219, width: 1, on: false  },
				{ symbol: "]", value: 221, width: 1, on: false  },
				{ symbol: "\\", value: 220, width: 1, on: false  }
			],
			[
				{ symbol: "caps", value: 20, width: 1.75, on: false  },
				{ symbol: "a", value: 65, width: 1, on: false  },
				{ symbol: "s", value: 83, width: 1, on: false  },
				{ symbol: "d", value: 68, width: 1, on: false  },
				{ symbol: "f", value: 70, width: 1, on: false  },
				{ symbol: "g", value: 71, width: 1, on: false  },
				{ symbol: "h", value: 72, width: 1, on: false  },
				{ symbol: "j", value: 74, width: 1, on: false  },
				{ symbol: "k", value: 75, width: 1, on: false  },
				{ symbol: "l", value: 76, width: 1, on: false  },
				{ symbol: ";", value: 186, width: 1, on: false  },
				{ symbol: "'", value: 222, width: 1, on: false  },
				{ symbol: "enter", value: 13, width: 1.75, on: false }
			],
			[
				{ symbol: "shift", value: 16, width: 2.25, on: false  },
				{ symbol: "z", value: 90, width: 1, on: false  },
				{ symbol: "x", value: 88, width: 1, on: false  },
				{ symbol: "c", value: 67, width: 1, on: false  },
				{ symbol: "v", value: 86, width: 1, on: false  },
				{ symbol: "b", value: 66, width: 1, on: false  },
				{ symbol: "n", value: 78, width: 1, on: false  },
				{ symbol: "m", value: 77, width: 1, on: false  },
				{ symbol: ",", value: 188, width: 1, on: false  },
				{ symbol: ".", value: 190, width: 1, on: false  },
				{ symbol: "/", value: 191, width: 1, on: false  },
				{ symbol: "shift", value: 16, width: 2.25, on: false }
			],
			[
				{ symbol: "fn", value: 10, width: 1, on: false  },
				{ symbol: "ctrl", value: 17, width: 1, on: false  },
				{ symbol: "opt", value: 10, width: 1, on: false  },
				{ symbol: "cmd", value: 10, width: 1.25, on: false  },
				{ symbol: "space", value: 32, width: 5, on: false  },
				{ symbol: "cmd", value: 10, width: 1, on: false  },
				{ symbol: "opt", value: 10, width: 1, on: false  },
				{ symbol: "left", value: 37, width: .81, on: false  },
				{ symbol: "up", value: 38, width: .81, on: false  },
				{ symbol: "down", value: 40, width: .81, on: false  },
				{ symbol: "right", value: 39, width: .81, on: false  }
			]
		]

		this.boundType = this.typekey.bind(this);
		this.boundUntype = this.untype.bind(this);
		window.addEventListener("keydown", this.boundType);
		window.addEventListener("keyup", this.boundUntype);

		this.init();
	}
	util.inherits(typewriter, widget);
		
	typewriter.prototype.init = function() {

		this.keywid = this.width/14.5;
		this.keyhgt = this.height/5
		
		this.draw();
	}

	typewriter.prototype.draw = function() {	// erase
		this.erase();

		if (!this.active) {
			this.context.globalAlpha = 0.4
		} else {
			this.context.globalAlpha = 1
		}

		with (this.context) {

			strokeStyle = this.colors.border 
			fillStyle = this.colors.accent 
			lineWidth = 1

			for (var i=0;i<this.rows.length;i++) {
				var currkeyL = 0;
				for (var j=0;j<this.rows[i].length;j++) {

					if (this.val.key==this.rows[i][j].symbol) {
						if (this.val.on) {
							this.rows[i][j].on = true;
						} else {
							this.rows[i][j].on = false;
						}
					}

					drawing.makeRoundRect(this.context, currkeyL , i*this.keyhgt,this.keywid*this.rows[i][j].width,this.keyhgt,4);
						
					if (this.rows[i][j].on) {
						fillStyle = this.colors.accent 
						strokeStyle = this.colors.accent 
						fill()
						stroke()
					} else {
						fillStyle = this.colors.fill 
						strokeStyle = this.colors.border 

						fill()
						stroke()
					}
		
					currkeyL += this.keywid*this.rows[i][j].width;

				}
			}

			if (this.val.on) {
				this.setFont();
				fillStyle = this.colors.border;
				font = this.height+"px "+this.font;
				fillText(this.val.key, this.width/2, this.height/2);
				
				globalAlpha = 1
			}

			if (!this.active) {
				globalAlpha = 0.7
				fillStyle = this.colors.border;
				font = (this.height/2)+"px courier";
				textAlign = "center";
				textBaseline = "middle"
				fillText("inactive", this.width/2, this.height/2);
			}
		}

		this.drawLabel();
	}

	typewriter.prototype.click = function(e) {
		this.active = !this.active;
		this.draw();
	}

	typewriter.prototype.typekey = function(e) {
		if (this.active) {
			var currKey = e.which;
			for (var i=0;i<this.rows.length;i++) {
				for (var j=0;j<this.rows[i].length;j++) {
					if (currKey == this.rows[i][j].value) {
						this.val.key = this.rows[i][j].symbol;
						this.val.on = 1;
						this.val.ascii = e.which;
						this.transmit(this.val);
						break;
					}
				}
			}
			this.draw();
		}	
	}

	typewriter.prototype.untype = function(e) {
		if (this.active) {
			var currKey = e.which;
			for (var i=0;i<this.rows.length;i++) {
				for (var j=0;j<this.rows[i].length;j++) {
					if (currKey == this.rows[i][j].value) {
					//	this.rows[i][j].on = false;
						this.val.key = this.rows[i][j].symbol;
						this.val.on = 0;
						this.val.ascii = e.which;
						this.transmit(this.val);
						break;
					}
				}
			}
			this.draw();
		}
	}

	typewriter.prototype.customDestroy = function() {
		window.removeEventListener("keydown", this.boundType);
		window.removeEventListener("keyup", this.boundUntype);
	}
	},{"../core/widget":3,"../utils/drawing":5,"util":47}],40:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class vinyl      
		For the boom bap
		```html
		<canvas nx="vinyl"></canvas>
		```
	<!--	<canvas nx="vinyl" style="margin-left:25px"></canvas> -->
	*/

	var vinyl = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 100 };
		widget.call(this, target);
		
		this.circleSize;

		/** @property speed The rotation increment. Default is 0.05. Not to be confused with .val.speed (see below) which is the data output. During rotation, .speed will always move towards .defaultSpeed */
		this.speed = 0.05;
		/** @property defaultSpeed The "steady-state" rotation increment. Default is 0.05. During rotation, if .speed is changed, it will gradually move towards this. */
		this.defaultspeed = 0.05
		this.rotation = 0;
		this.hasMovedOnce = false;

		this.lockResize = true;
		
		/** @property {object}  val  Object containing the core interactive aspects of the widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *speed*| Current speed of the record player's rotation. (Normal is 1.)
		*/
		this.val = {
			speed: 0
		}
		this.init();
		nx.aniItems.push(this.spin.bind(this));
	}
	util.inherits(vinyl, widget);

	vinyl.prototype.init = function() {

		this.circleSize = (Math.min(this.center.x, this.center.y)-this.lineWidth);
		this.draw();
	}

	vinyl.prototype.draw = function() {
		this.erase()

		with (this.context) {
			strokeStyle = this.colors.border;
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height)
			
			//draw main circle
			beginPath();
			fillStyle = this.colors.black;
			arc(this.center.x, this.center.y, this.circleSize-5, 0, Math.PI*2, true);
			fill();
			closePath();


			//draw circle in center
			beginPath();
			fillStyle = this.colors.accent;
			arc(this.center.x, this.center.y*1, this.circleSize/4, 0, Math.PI*2, false);
			fill()
			closePath();


			//draw tint
			beginPath();
			globalAlpha = 0.5;
			fillStyle = this.colors.fill;
			arc(this.center.x, this.center.y, this.circleSize, this.rotation, this.rotation + 0.4, false);
			lineTo(this.center.x, this.center.y);
			arc(this.center.x, this.center.y, this.circleSize, this.rotation+Math.PI, this.rotation +Math.PI+ 0.4, false);
			lineTo(this.center.x, this.center.y);
			fill();
			globalAlpha = 1;
			closePath(); 


			//draw white circle in center
			beginPath();
			fillStyle = this.colors.white;
			arc(this.center.x, this.center.y*1, this.circleSize/16, 0, Math.PI*2, false);
			fill()
			closePath(); 

		}

		this.drawLabel();
	}

	vinyl.prototype.click = function(e) {
		this.hasMovedOnce = false;
		this.lastRotation = this.rotation
		this.grabAngle = this.rotation % (Math.PI*2)
		this.grabPos = math.toPolar(this.clickPos.x-this.center.x,this.clickPos.y-this.center.y).angle

	}

	vinyl.prototype.move = function() {

		if (!this.hasMovedOnce) {
			this.hasMovedOnce = true;
			this.grabAngle = this.rotation % (Math.PI*2)
			this.grabPos = math.toPolar(this.clickPos.x-this.center.x,this.clickPos.y-this.center.y).angle
		}

		this.rotation = math.toPolar(this.clickPos.x-this.center.x,this.clickPos.y-this.center.y).angle + this.grabAngle - this.grabPos	


	}

	vinyl.prototype.release = function() {
		this.speed = ((this.rotation - this.lastRotation) + (this.lastRotation-this.lastRotation2))/2 ;
	}

	vinyl.prototype.spin = function() {

		if (this.clicked) { 
			this.speed /= 1.1;
		} else {
			this.speed = this.speed*0.9 + this.defaultspeed*0.1
		}

		// may need to math.clip(this.val.speed,-10,10);
		this.val.speed = (this.rotation - this.lastRotation) * 20; // normalizes it to 1

		this.lastRotation2 = this.lastRotation
		this.lastRotation = this.rotation

		this.rotation += this.speed

		this.draw();

		this.transmit(this.val)
		
	}

	vinyl.prototype.customDestroy = function() {
		nx.removeAni(this.spin.bind(this));
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],41:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');
	var math = require('../utils/math')

	/** 
		@class waveform      
		Waveform visualizer and selecter
		```html
		<canvas nx="waveform"></canvas>
		```
	*/

	var waveform = module.exports = function (target) {
		this.defaultSize = { width: 400, height: 125 };
		widget.call(this, target);

		/** @property {object}  val  Object containing core interactive aspects of widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *starttime* | Waveform selection start position in milliseconds (integer)
			| *stoptime* | Waveform selection end position in milliseconds (integer)
			| *looptime* | Selection size, in milliseconds (integer)
			| *start* | Waveform selection start, as fraction of waveform (float 0-1)
			| *stop* | Waveform selection end, as fraction of waveform (float 0-1)
			| *size* | Selection size, as fraction of waveform (float 0-1)
		*/
		this.val = {
			start: 0,
			stop: 0,
			size: 0,
			starttime: 0,
			stoptime: 0,
			looptime: 0
		}

		this.handle;
		this.relhandle;
		this.cap;
		this.firsttouch = "start";

		/** @property {Array} buffer  Contains multiple arrays of reduced buffer data, for visualization */
		this.buffer = []

		if (nx.isMobile) {
			/** @property {integer} definition  Horizontal definition of the visualization. Value of 3 means the waveform will be represented in 3 pixel chunks. Higher numbers (4+) lead to a smaller graphics load. Smaller numbers (1-3) look better. Default is 1 for desktop renders, 3 for mobile renders. */
			this.definition = 3;
		} else {
			this.definition = 1;
		}

		this.pieces = false;

		/** @property {integer} channels  How many channels in the waveform */
		this.channels = 1
		this.rawbuffer = []

		this.times = [
			{ dur: 10 , format: 1 },
			{ dur: 50 , format: 1 },
			{ dur: 100 , format: 1 },
			{ dur: 200 , format: 1 },
			{ dur: 500 , format: 1 },
			{ dur: 1000 , format: 1 },
			{ dur: 2000 , format: 1 },
			{ dur: 5000 , format: 1 },
			{ dur: 10000 , format: 3 },
			{ dur: 15000 , format: 3 },
			{ dur: 60000 , format: 3 }, // 1 min
			{ dur: 120000 , format: 3 }, // 2 mins
			{ dur: 300000 , format: 3 }, // 5 mins
			{ dur: 600000 , format: 3 }, // 10 mins
		]
		this.timescale = false

		// to do --
		// // sample rate adjustments
		// .select(500,1000)

		/** @property {string}  mode  Mode of interaction. "edge" mode lets you drag each edge of the waveform individually. "area" mode (default) lets you drag the waveform as a whole (with parallel mouse movement) or scale the waveform as a whole (with transverse mouse movement) */
		this.mode = "area" // modes: "edge", "area"
		this.touchdown = new Object();
		this.init();
	}
	util.inherits(waveform, widget);

	waveform.prototype.init = function() {

		this.pieces = ~~(this.width/this.definition);

		this.draw();
	}


	/** 
	  @method setBuffer 
	  Load a web audio AudioBuffer into the waveform ui, for analysis and visualization.
	  @param {AudioBuffer} [buffer] The buffer to be loaded.
	  */
	waveform.prototype.setBuffer = function(prebuff) {

		this.channels = prebuff.numberOfChannels
		this.duration = prebuff.duration
		this.sampleRate = prebuff.sampleRate
		this.waveHeight = this.height / this.channels

		// timescale
		this.durationMS = (this.duration * 1000) 
		this.timescale = 0
		while (~~(this.durationMS/this.times[this.timescale].dur) > 7 && this.timescale < this.times.length ) {
			this.timescale++;
		}
		this.timescale = this.times[this.timescale]

		this.rawbuffer = []
		this.buffer = []

		// reduce/crush buffers
		for (var i=0;i<this.channels;i++) {
			this.rawbuffer.push(prebuff.getChannelData(0))
			this.buffer.push([])

			// counts faster (& less accurately) through larger buffers.
			// for every 5 seconds in the buffer, our counter skips 1.
			// so a 10 second buffer will only look at every 3rd sample
			//   when calculating waveform.
			var countinc = ~~(this.rawbuffer[0].length / (this.sampleRate*5)) + 1

			var groupsize = ~~(this.rawbuffer[i].length/this.pieces)
			var cmax = 0
			var cmin = 0
			var group = 0
			var vis = []
			for (var j=0;j<this.rawbuffer[i].length;j += countinc) {
				if (this.rawbuffer[i][j]>0) {
					cmax = Math.max(cmax,this.rawbuffer[i][j])
				} else {
					cmin = Math.min(cmin,this.rawbuffer[i][j])
				}
				if (j > group * groupsize) {
					this.buffer[i].push([cmax,cmin])
					group++
					cmin = 0
					cmax = 0
				}
			}
		}

		if (this.val.start && this.val.stop) {

		}

		this.val.starttime = Math.round(this.val.start * this.durationMS)
		this.val.stoptime = Math.round(this.val.stop * this.durationMS)
		this.val.looptime = Math.round(this.val.size * this.durationMS)
		

		this.draw()

	}

	/** 
	  @method select 
	  Set the selection start and end points.
	  @param {integer} [start] Selection start point in milliseconds
	  @param {integer} [end] Selection end point in milliseconds
	  */
	waveform.prototype.select = function(start,stop) {
		this.val.start = math.clip(start / this.durationMS,0,1)
		this.val.stop = math.clip(stop / this.durationMS,0,1)
		this.val.size = this.val.stop - this.val.start
		this.val.starttime = start
		this.val.stoptime = stop
		this.val.looptime = start - stop
		this.transmit(this.val)
		this.draw()
	}


	waveform.prototype.draw = function() {
		//this.erase();

		with (this.context) {
			//bg
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);

			//waveform
			for (var i=0;i<this.buffer.length;i++) {
				fillStyle = this.colors.black
				this.waveTop = i*this.waveHeight;
				this.waveCenter = this.waveTop + this.waveHeight/2
				for (var j=0;j<this.buffer[i].length;j++) {
					var ht1 = this.waveCenter - this.buffer[i][j][0]*this.waveHeight
					var ht2 = this.waveCenter + Math.abs(this.buffer[i][j][1]*this.waveHeight)
					ht2 = ht2 - ht1
					fillRect( j*this.definition, ht1 , this.definition, ht2)
				}
				this.buffer[i]

			}

			//time bar - top
			globalAlpha = 0.3
			fillStyle = this.colors.border
			fillRect(0,0,this.width,16)
			globalAlpha = 1


			textBaseline = "middle"
			textAlign = "left"
			fontSize = "8px"

			//time lines
			if (this.timescale) {
				for (var i=1; i<this.durationMS/this.timescale.dur; i++) {
					var x = (i * this.timescale.dur) / this.durationMS
					x *= this.width
					fillStyle = this.colors.border
					fillRect(x,0,1,this.height)
					fillStyle = this.colors.black
					globalAlpha = 0.6
					fillText(this.msToTime(i * this.timescale.dur,this.timescale.format),x+5,8)
					globalAlpha = 1
				}	
			} 
			

			// range selection
			var x1 = this.val.start*this.width;
			var y1 = 0;
			var x2 = this.val.stop*this.width;
			var y2 = this.height;
		   
			fillStyle = this.colors.accent;
			strokeStyle = this.colors.accent;
			lineWidth = 2
			globalAlpha = 0.3
			fillRect(x1,y1,x2-x1,y2-y1);
			globalAlpha = 0.7
			strokeRect(x1,y1-2,x2-x1,y2-y1+4);
			if (this.durationMS && this.val.looptime) {
				this.val.size = this.val.stop - this.val.start
				textAlign = "center"
				var dur = this.val.looptime
				if (dur > 1000) {
					dur /= 1000
					math.prune(dur,2)
					dur += ' s'
				} else {
					math.prune(dur,0)
					dur += ' ms'
				}
				fillText(dur,x1 + (x2-x1)/2,this.height/2)
			}
			
			globalAlpha = 1

			
		}

	}

	waveform.prototype.msToTime = function(rawms,format) {

	  var format = format ? format : 2

	  var s = ~~(rawms / 1000)
	  var secs = s % 60;
	  s = (s - secs) / 60;
	  var mins = s % 60;
	  var hrs = (s - mins) / 60;
	  var ms = rawms % 1000

	  //correct digits
	  secs = (secs < 10 && mins) ? secs + '0' : secs;
	  //ms = (ms < 10 && secs) ? ms + '0' : ms;

	  if (format==1) {
	  	return secs + '.' + ms;
	  } else if (format==2) {
	  	return mins + ':' + secs + '.' + ms;
	  } else if (format==3) {
	  	return mins + ':' + secs;
	  }

	}

	waveform.prototype.click = function() {
		if (this.mode=="edge") {
			if (Math.abs(this.clickPos.x-this.val.start*this.width) < Math.abs(this.clickPos.x-this.val.stop*this.width)) {
				this.firsttouch = "start"
			} else {
				this.firsttouch = "stop"
			}
		} else if (this.mode=="area") {
			this.touchdown = {
				x: this.clickPos.x,
				y: this.clickPos.y
			}
			this.startval = new Object();
			this.startval.size = this.val.stop - this.val.start;
			this.startval.loc = this.val.start + this.startval.size/2;
		}
		this.move();
	}

	waveform.prototype.move = function() {

		if (this.mode=="edge") {
			if (this.firsttouch=="start") {
				this.val.start = this.clickPos.x/this.width;
				if (this.clickPos.touches.length>1) {
					this.val.stop = this.clickPos.touches[1].x/this.width;
				}
			} else {
				this.val.stop = this.clickPos.x/this.width;
				if (this.clickPos.touches.length>1) {
					this.val.start = this.clickPos.touches[1].x/this.width;
				}
			}
		

			if (this.val.stop < this.val.start) {
				this.tempstart = this.val.start;
				this.val.start = this.val.stop;
				this.val.stop = this.tempstart;
				if (this.firsttouch=="start") {
					this.firsttouch = "stop";
				} else {
					this.firsttouch = "start";
				}
			} 
			
		} else if (this.mode=="area") {

			var moveloc = this.clickPos.x/this.width;
			var movesize = (this.touchdown.y - this.clickPos.y)/this.height;
		
			movesize /= 4;
			var size = this.startval.size + movesize;
			size = math.clip(size,0.001,1);

			this.val = {
				start: moveloc - size/2,
				stop: moveloc + size/2,
			}

		}

		this.val.start = math.clip(this.val.start,0,1);
		this.val.stop = math.clip(this.val.stop,0,1);

		this.val['size'] = math.clip(Math.abs(this.val.stop - this.val.start), 0, 1)

		if (this.durationMS) {
			this.val["starttime"] = Math.round(this.val.start * this.durationMS)
			this.val["stoptime"] = Math.round(this.val.stop * this.durationMS)
			this.val["looptime"] = Math.round(this.val.size * this.durationMS)
		}

		this.transmit(this.val);
		this.draw();

	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],42:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class windows      
		Scalable windows
		```html
		<canvas nx="windows"></canvas>
		```
		<canvas nx="windows" style="margin-left:25px"></canvas>
	*/

	var windows = module.exports = function (target) {

		this.defaultSize = { width: 200, height: 200 };

		widget.call(this, target);

		this.val = {
			items: [],
			add: false,
			remove: false,
			change: false
		}

		//this.val.items = []
		this.size = .25;
		this.meta = false;
		this.resizing = false;
		
		this.init();

		document.addEventListener('keydown',function(e) {
			if (e.shiftKey && !this.meta) {
				this.meta = true;
				this.draw();
			}
		}.bind(this))
		document.addEventListener('keyup',function(e) {
			if (!e.shiftKey && this.meta) {
				this.meta = false;
				this.draw();
			}
		}.bind(this))
	}
	util.inherits(windows, widget);

	windows.prototype.init = function() {
		this.draw();
	}

	windows.prototype.add = function(x,y,w,h) {
		this.val.items.push({
			x: x,
			y: y,
			w: w,
			h: h
		})
		this.draw();
	}

	windows.prototype.setWindow = function(index, loc) {
		this.val.items[index] = loc;
		this.draw();
	}

	windows.prototype.remove = function(index) {
		this.val.items.splice(index,1)
		this.val.add = false
		this.val.remove = index
		this.val.change = false
		/* this.val = {
			remove: index,
			items: this.val.items
		} */
		this.transmit(this.val)
		this.draw();
	}

	windows.prototype.draw = function() {
	//	this.erase()
		with (this.context) {

			if (!this.meta) {
				fillStyle = this.colors.fill;
			} else {
				fillStyle = this.colors.border;
			}

			fillRect(0,0,this.width,this.height);

			globalAlpha = 0.8;
		
			for (var i=0;i<this.val.items.length;i++) {
				fillStyle = this.colors.accent;
				var x = this.val.items[i].x*this.width
				var y = this.val.items[i].y*this.height
				var w = this.val.items[i].w*this.width
				var h = this.val.items[i].h*this.height
				fillRect(x,y,w,h)
			    
				strokeStyle = this.colors.fill;
				lineWidth = 1;
			    strokeRect(x+w-10,y+h-10,10,10)
			  //  strokeRect((this.val.items[i].x + this.val.items[i].w/2)*this.width - 10, (this.val.items[i].y + this.val.items[i].h/2)*this.height - 10,10,10)
			}

			globalAlpha = 1;

		}
		
		this.drawLabel();
	}

	windows.prototype.click = function() {

		this.holds = false;
		var cx = this.clickPos.x / this.width;
		var cy = this.clickPos.y / this.height;
		for (var i=0;i<this.val.items.length;i++) {
			if (nx.isInside({ x: cx, y: cy }, this.val.items[i])) {
				this.holds = i;
				if (this.clickPos.x > (this.val.items[i].x+this.val.items[i].w)*this.width - 10 && this.clickPos.x < (this.val.items[i].x+this.val.items[i].w)*this.width && this.clickPos.y > (this.val.items[i].y+this.val.items[i].h)*this.height - 10 && this.clickPos.y < (this.val.items[i].y+this.val.items[i].h)*this.height) {
					this.resizing = true;
				}
			}
		}

		if (this.holds===false) {
			this.val.items.push({
				x: cx,
				y: cy,
				w: this.size,
				h: this.size
			})
			this.holds = this.val.items.length-1;
			this.hasMoved = true;
			this.val.add = this.val.items[this.holds]
			this.val.remove = false
			this.val.change = false
			/* this.val = {
				add: this.val.items[this.holds],
				items: this.val.items
			} */
			this.transmit(this.val)
		}
		if (this.meta) {
			for (var i=0;i<this.val.items.length;i++) {
				this.val.items[i].tx = this.val.items[i].x
				this.val.items[i].ty = this.val.items[i].y
			}
			this.tx = cx
			this.ty = cy
		}
		this.draw();
	}

	windows.prototype.move = function() {
		var cx = this.clickPos.x / this.width;
		var cy = this.clickPos.y / this.height;
		if (this.resizing) {
			if (!this.meta) {
				this.val.items[this.holds].w = cx - this.val.items[this.holds].x
				this.val.items[this.holds].h = cy - this.val.items[this.holds].y
				this.val.items[this.holds] = this.restrict(this.val.items[this.holds])
			} else {
				for (var i=0;i<this.val.items.length;i++) {
					this.val.items[i].w = cx - this.val.items[this.holds].x
					this.val.items[i].h = cy - this.val.items[this.holds].y
					this.val.items[i] = this.restrict(this.val.items[i])
				}
			}
		} else {
			if (!this.meta) {
				this.val.items[this.holds].x = cx;
				this.val.items[this.holds].y = cy;	
				this.val.items[this.holds] = this.restrict(this.val.items[this.holds])
			} else {
				for (var i=0;i<this.val.items.length;i++) {
					this.val.items[i].x = (cx - this.tx) + this.val.items[i].tx;
					this.val.items[i].y = (cy - this.ty) + this.val.items[i].ty;
					this.val.items[i] = this.restrict(this.val.items[i])	
				}
			}	
		}


		
		this.val.change = true;
		this.val.add = false;
		this.val.remove = false;
		/*this.val = {
			change: true,
			items: this.val.items
		} */
		this.transmit(this.val)
		this.draw();
	}

	windows.prototype.release = function() {
		if (!this.hasMoved) {
			if (this.meta) {
				this.val.add = false
				this.val.remove = "all"
				this.val.change = false
				/*this.val = {
					remove: "all",
					items: this.val.items
				} */
				this.val.items = []
			} else {
				this.val.add = false
				this.val.remove = this.holds
				this.val.change = false
			/*	this.val = {
					remove: this.holds,
					items: this.val.items
				} */
				this.val.items.splice(this.holds,1)
			}
		}
		this.resizing = false;
		this.transmit(this.val);
		this.draw();
	}

	windows.prototype.restrict = function(item) {
		if (item.x < 0) {
			item.x = 0
		}
		if (item.y < 0) {
			item.y = 0
		}
		if (item.x + item.w > 1) {
			item.x = 1 - item.w
		}
		if (item.y + item.h > 1) {
			item.y = 1 - item.h
		}	
		return item;
	}
	},{"../core/widget":3,"../utils/math":6,"util":47}],43:[function(require,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	},{}],44:[function(require,module,exports){
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}

	},{}],45:[function(require,module,exports){
	// shim for using process in browser

	var process = module.exports = {};

	process.nextTick = (function () {
	    var canSetImmediate = typeof window !== 'undefined'
	    && window.setImmediate;
	    var canPost = typeof window !== 'undefined'
	    && window.postMessage && window.addEventListener
	    ;

	    if (canSetImmediate) {
	        return function (f) { return window.setImmediate(f) };
	    }

	    if (canPost) {
	        var queue = [];
	        window.addEventListener('message', function (ev) {
	            var source = ev.source;
	            if ((source === window || source === null) && ev.data === 'process-tick') {
	                ev.stopPropagation();
	                if (queue.length > 0) {
	                    var fn = queue.shift();
	                    fn();
	                }
	            }
	        }, true);

	        return function nextTick(fn) {
	            queue.push(fn);
	            window.postMessage('process-tick', '*');
	        };
	    }

	    return function nextTick(fn) {
	        setTimeout(fn, 0);
	    };
	})();

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	}

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};

	},{}],46:[function(require,module,exports){
	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}
	},{}],47:[function(require,module,exports){
	(function (process,global){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = require('./support/isBuffer');

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	exports.inherits = require('inherits');

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"./support/isBuffer":46,"_process":45,"inherits":44}],48:[function(require,module,exports){
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	var undefined;

	var isPlainObject = function isPlainObject(obj) {
		'use strict';
		if (!obj || toString.call(obj) !== '[object Object]') {
			return false;
		}

		var has_own_constructor = hasOwn.call(obj, 'constructor');
		var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) {}

		return key === undefined || hasOwn.call(obj, key);
	};

	module.exports = function extend() {
		'use strict';
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0],
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if (typeof target === 'boolean') {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
			target = {};
		}

		for (; i < length; ++i) {
			options = arguments[i];
			// Only deal with non-null/undefined values
			if (options != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && Array.isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = extend(deep, clone, copy);

					// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};


	},{}]},{},[1]);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root) {
		"use strict";
		var Tone;
		//constructs the main Tone object
		function Main(func){
			Tone = func();
		}
		//invokes each of the modules with the main Tone object as the argument
		function Module(func){
			func(Tone);
		}
		/**
		 *  Tone.js
		 *  @author Yotam Mann
		 *  @license http://opensource.org/licenses/MIT MIT License
		 *  @copyright 2014-2015 Yotam Mann
		 */
		Main(function () {
		    
		    //////////////////////////////////////////////////////////////////////////
		    //	WEB AUDIO CONTEXT
		    ///////////////////////////////////////////////////////////////////////////
		    //borrowed from underscore.js
		    function isUndef(val) {
		        return val === void 0;
		    }
		    //borrowed from underscore.js
		    function isFunction(val) {
		        return typeof val === 'function';
		    }
		    var audioContext;
		    //polyfill for AudioContext and OfflineAudioContext
		    if (isUndef(window.AudioContext)) {
		        window.AudioContext = window.webkitAudioContext;
		    }
		    if (isUndef(window.OfflineAudioContext)) {
		        window.OfflineAudioContext = window.webkitOfflineAudioContext;
		    }
		    if (!isUndef(AudioContext)) {
		        audioContext = new AudioContext();
		    } else {
		        throw new Error('Web Audio is not supported in this browser');
		    }
		    //SHIMS////////////////////////////////////////////////////////////////////
		    if (!isFunction(AudioContext.prototype.createGain)) {
		        AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
		    }
		    if (!isFunction(AudioContext.prototype.createDelay)) {
		        AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
		    }
		    if (!isFunction(AudioContext.prototype.createPeriodicWave)) {
		        AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;
		    }
		    if (!isFunction(AudioBufferSourceNode.prototype.start)) {
		        AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn;
		    }
		    if (!isFunction(AudioBufferSourceNode.prototype.stop)) {
		        AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff;
		    }
		    if (!isFunction(OscillatorNode.prototype.start)) {
		        OscillatorNode.prototype.start = OscillatorNode.prototype.noteOn;
		    }
		    if (!isFunction(OscillatorNode.prototype.stop)) {
		        OscillatorNode.prototype.stop = OscillatorNode.prototype.noteOff;
		    }
		    if (!isFunction(OscillatorNode.prototype.setPeriodicWave)) {
		        OscillatorNode.prototype.setPeriodicWave = OscillatorNode.prototype.setWaveTable;
		    }
		    //extend the connect function to include Tones
		    AudioNode.prototype._nativeConnect = AudioNode.prototype.connect;
		    AudioNode.prototype.connect = function (B, outNum, inNum) {
		        if (B.input) {
		            if (Array.isArray(B.input)) {
		                if (isUndef(inNum)) {
		                    inNum = 0;
		                }
		                this.connect(B.input[inNum]);
		            } else {
		                this.connect(B.input, outNum, inNum);
		            }
		        } else {
		            try {
		                if (B instanceof AudioNode) {
		                    this._nativeConnect(B, outNum, inNum);
		                } else {
		                    this._nativeConnect(B, outNum);
		                }
		            } catch (e) {
		                throw new Error('error connecting to node: ' + B);
		            }
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	TONE
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  @class  Tone is the base class of all other classes. It provides 
			 *          a lot of methods and functionality to all classes that extend
			 *          it. 
			 *  
			 *  @constructor
			 *  @alias Tone
			 *  @param {number} [inputs=1] the number of input nodes
			 *  @param {number} [outputs=1] the number of output nodes
			 */
		    var Tone = function (inputs, outputs) {
		        /**
				 *  the input node(s)
				 *  @type {GainNode|Array}
				 */
		        if (isUndef(inputs) || inputs === 1) {
		            this.input = this.context.createGain();
		        } else if (inputs > 1) {
		            this.input = new Array(inputs);
		        }
		        /**
				 *  the output node(s)
				 *  @type {GainNode|Array}
				 */
		        if (isUndef(outputs) || outputs === 1) {
		            this.output = this.context.createGain();
		        } else if (outputs > 1) {
		            this.output = new Array(inputs);
		        }
		    };
		    /**
			 *  Set the parameters at once. Either pass in an
			 *  object mapping parameters to values, or to set a
			 *  single parameter, by passing in a string and value.
			 *  The last argument is an optional ramp time which 
			 *  will ramp any signal values to their destination value
			 *  over the duration of the rampTime.
			 *  @param {Object|string} params
			 *  @param {number=} value
			 *  @param {Time=} rampTime
			 *  @returns {Tone} this
			 *  @example
			 * //set values using an object
			 * filter.set({
			 * 	"frequency" : 300,
			 * 	"type" : highpass
			 * });
			 *  @example
			 * filter.set("type", "highpass");
			 *  @example
			 * //ramp to the value 220 over 3 seconds. 
			 * oscillator.set({
			 * 	"frequency" : 220
			 * }, 3);
			 */
		    Tone.prototype.set = function (params, value, rampTime) {
		        if (typeof params === 'object') {
		            rampTime = value;
		        } else if (typeof params === 'string') {
		            var tmpObj = {};
		            tmpObj[params] = value;
		            params = tmpObj;
		        }
		        for (var attr in params) {
		            value = params[attr];
		            var parent = this;
		            if (attr.indexOf('.') !== -1) {
		                var attrSplit = attr.split('.');
		                for (var i = 0; i < attrSplit.length - 1; i++) {
		                    parent = parent[attrSplit[i]];
		                }
		                attr = attrSplit[attrSplit.length - 1];
		            }
		            var param = parent[attr];
		            if (isUndef(param)) {
		                continue;
		            }
		            if (param instanceof Tone.Signal) {
		                if (param.value !== value) {
		                    if (isUndef(rampTime)) {
		                        param.value = value;
		                    } else {
		                        param.rampTo(value, rampTime);
		                    }
		                }
		            } else if (param instanceof AudioParam) {
		                if (param.value !== value) {
		                    param.value = value;
		                }
		            } else if (param instanceof Tone) {
		                param.set(value);
		            } else if (param !== value) {
		                parent[attr] = value;
		            }
		        }
		        return this;
		    };
		    /**
			 *  Get the object's attributes. Given no arguments get
			 *  will return all available object properties and their corresponding
			 *  values. Pass in a single attribute to retrieve or an array
			 *  of attributes. The attribute strings can also include a "."
			 *  to access deeper properties.
			 *  @example
			 * osc.get();
			 * //returns {"type" : "sine", "frequency" : 440, ...etc}
			 *  @example
			 * osc.get("type");
			 * //returns { "type" : "sine"}
			 * @example
			 * //use dot notation to access deep properties
			 * synth.get(["envelope.attack", "envelope.release"]);
			 * //returns {"envelope" : {"attack" : 0.2, "release" : 0.4}}
			 *  @param {Array=|string|undefined} params the parameters to get, otherwise will return 
			 *  					                  all available.
			 *  @returns {Object}
			 */
		    Tone.prototype.get = function (params) {
		        if (isUndef(params)) {
		            params = this._collectDefaults(this.constructor);
		        } else if (typeof params === 'string') {
		            params = [params];
		        }
		        var ret = {};
		        for (var i = 0; i < params.length; i++) {
		            var attr = params[i];
		            var parent = this;
		            var subRet = ret;
		            if (attr.indexOf('.') !== -1) {
		                var attrSplit = attr.split('.');
		                for (var j = 0; j < attrSplit.length - 1; j++) {
		                    var subAttr = attrSplit[j];
		                    subRet[subAttr] = subRet[subAttr] || {};
		                    subRet = subRet[subAttr];
		                    parent = parent[subAttr];
		                }
		                attr = attrSplit[attrSplit.length - 1];
		            }
		            var param = parent[attr];
		            if (typeof params[attr] === 'object') {
		                subRet[attr] = param.get();
		            } else if (param instanceof Tone.Signal) {
		                subRet[attr] = param.value;
		            } else if (param instanceof AudioParam) {
		                subRet[attr] = param.value;
		            } else if (param instanceof Tone) {
		                subRet[attr] = param.get();
		            } else if (!isFunction(param) && !isUndef(param)) {
		                subRet[attr] = param;
		            }
		        }
		        return ret;
		    };
		    /**
			 *  collect all of the default attributes in one
			 *  @private
			 *  @param {function} constr the constructor to find the defaults from
			 *  @return {Array} all of the attributes which belong to the class
			 */
		    Tone.prototype._collectDefaults = function (constr) {
		        var ret = [];
		        if (!isUndef(constr.defaults)) {
		            ret = Object.keys(constr.defaults);
		        }
		        if (!isUndef(constr._super)) {
		            var superDefs = this._collectDefaults(constr._super);
		            //filter out repeats
		            for (var i = 0; i < superDefs.length; i++) {
		                if (ret.indexOf(superDefs[i]) === -1) {
		                    ret.push(superDefs[i]);
		                }
		            }
		        }
		        return ret;
		    };
		    /**
			 *  Set the preset if it exists. 
			 *  @param {string} presetName the name of the preset
			 *  @returns {Tone} this
			 */
		    Tone.prototype.setPreset = function (presetName) {
		        if (!this.isUndef(this.preset) && this.preset.hasOwnProperty(presetName)) {
		            this.set(this.preset[presetName]);
		        }
		        return this;
		    };
		    /**
			 *  @returns {string} returns the name of the class as a string
			 */
		    Tone.prototype.toString = function () {
		        for (var className in Tone) {
		            var isLetter = className[0].match(/^[A-Z]$/);
		            var sameConstructor = Tone[className] === this.constructor;
		            if (isFunction(Tone[className]) && isLetter && sameConstructor) {
		                return className;
		            }
		        }
		        return 'Tone';
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	CLASS VARS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  A static pointer to the audio context accessible as Tone.context. 
			 *  @type {AudioContext}
			 */
		    Tone.context = audioContext;
		    /**
			 *  The audio context.
			 *  @type {AudioContext}
			 */
		    Tone.prototype.context = Tone.context;
		    /**
			 *  the default buffer size
			 *  @type {number}
			 *  @static
			 *  @const
			 */
		    Tone.prototype.bufferSize = 2048;
		    /**
			 *  the delay time of a single buffer frame
			 *  @type {number}
			 *  @static
			 *  @const
			 */
		    Tone.prototype.bufferTime = Tone.prototype.bufferSize / Tone.context.sampleRate;
		    ///////////////////////////////////////////////////////////////////////////
		    //	CONNECTIONS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  disconnect and dispose
			 *  @returns {Tone} this
			 */
		    Tone.prototype.dispose = function () {
		        if (!this.isUndef(this.input)) {
		            if (this.input instanceof AudioNode) {
		                this.input.disconnect();
		            }
		            this.input = null;
		        }
		        if (!this.isUndef(this.output)) {
		            if (this.output instanceof AudioNode) {
		                this.output.disconnect();
		            }
		            this.output = null;
		        }
		        return this;
		    };
		    /**
			 *  a silent connection to the DesinationNode
			 *  which will ensure that anything connected to it
			 *  will not be garbage collected
			 *  
			 *  @private
			 */
		    var _silentNode = null;
		    /**
			 *  makes a connection to ensure that the node will not be garbage collected
			 *  until 'dispose' is explicitly called
			 *
			 *  use carefully. circumvents JS and WebAudio's normal Garbage Collection behavior
			 *  @returns {Tone} this
			 */
		    Tone.prototype.noGC = function () {
		        this.output.connect(_silentNode);
		        return this;
		    };
		    AudioNode.prototype.noGC = function () {
		        this.connect(_silentNode);
		        return this;
		    };
		    /**
			 *  connect the output of a ToneNode to an AudioParam, AudioNode, or ToneNode
			 *  @param  {Tone | AudioParam | AudioNode} unit 
			 *  @param {number} [outputNum=0] optionally which output to connect from
			 *  @param {number} [inputNum=0] optionally which input to connect to
			 *  @returns {Tone} this
			 */
		    Tone.prototype.connect = function (unit, outputNum, inputNum) {
		        if (Array.isArray(this.output)) {
		            outputNum = this.defaultArg(outputNum, 0);
		            this.output[outputNum].connect(unit, 0, inputNum);
		        } else {
		            this.output.connect(unit, outputNum, inputNum);
		        }
		        return this;
		    };
		    /**
			 *  disconnect the output
			 *  @returns {Tone} this
			 */
		    Tone.prototype.disconnect = function (outputNum) {
		        if (Array.isArray(this.output)) {
		            outputNum = this.defaultArg(outputNum, 0);
		            this.output[outputNum].disconnect();
		        } else {
		            this.output.disconnect();
		        }
		        return this;
		    };
		    /**
			 *  connect together all of the arguments in series
			 *  @param {...AudioParam|Tone|AudioNode}
			 *  @returns {Tone} this
			 */
		    Tone.prototype.connectSeries = function () {
		        if (arguments.length > 1) {
		            var currentUnit = arguments[0];
		            for (var i = 1; i < arguments.length; i++) {
		                var toUnit = arguments[i];
		                currentUnit.connect(toUnit);
		                currentUnit = toUnit;
		            }
		        }
		        return this;
		    };
		    /**
			 *  fan out the connection from the first argument to the rest of the arguments
			 *  @param {...AudioParam|Tone|AudioNode}
			 *  @returns {Tone} this
			 */
		    Tone.prototype.connectParallel = function () {
		        var connectFrom = arguments[0];
		        if (arguments.length > 1) {
		            for (var i = 1; i < arguments.length; i++) {
		                var connectTo = arguments[i];
		                connectFrom.connect(connectTo);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Connect the output of this node to the rest of the nodes in series.
			 *  @example
			 *  //connect a node to an effect, panVol and then to the master output
			 *  node.chain(effect, panVol, Tone.Master);
			 *  @param {...AudioParam|Tone|AudioNode} nodes
			 *  @returns {Tone} this
			 */
		    Tone.prototype.chain = function () {
		        if (arguments.length > 0) {
		            var currentUnit = this;
		            for (var i = 0; i < arguments.length; i++) {
		                var toUnit = arguments[i];
		                currentUnit.connect(toUnit);
		                currentUnit = toUnit;
		            }
		        }
		        return this;
		    };
		    /**
			 *  connect the output of this node to the rest of the nodes in parallel.
			 *  @param {...AudioParam|Tone|AudioNode}
			 *  @returns {Tone} this
			 */
		    Tone.prototype.fan = function () {
		        if (arguments.length > 0) {
		            for (var i = 0; i < arguments.length; i++) {
		                this.connect(arguments[i]);
		            }
		        }
		        return this;
		    };
		    //give native nodes chain and fan methods
		    AudioNode.prototype.chain = Tone.prototype.chain;
		    AudioNode.prototype.fan = Tone.prototype.fan;
		    ///////////////////////////////////////////////////////////////////////////
		    //	UTILITIES / HELPERS / MATHS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  if a the given is undefined, use the fallback. 
			 *  if both given and fallback are objects, given
			 *  will be augmented with whatever properties it's
			 *  missing which are in fallback
			 *
			 *  warning: if object is self referential, it will go into an an 
			 *  infinite recursive loop. 
			 *  
			 *  @param  {*} given    
			 *  @param  {*} fallback 
			 *  @return {*}          
			 */
		    Tone.prototype.defaultArg = function (given, fallback) {
		        if (typeof given === 'object' && typeof fallback === 'object') {
		            var ret = {};
		            //make a deep copy of the given object
		            for (var givenProp in given) {
		                ret[givenProp] = this.defaultArg(given[givenProp], given[givenProp]);
		            }
		            for (var prop in fallback) {
		                ret[prop] = this.defaultArg(given[prop], fallback[prop]);
		            }
		            return ret;
		        } else {
		            return isUndef(given) ? fallback : given;
		        }
		    };
		    /**
			 *  returns the args as an options object with given arguments
			 *  mapped to the names provided. 
			 *
			 *  if the args given is an array containing an object, it is assumed
			 *  that that's already the options object and will just return it. 
			 *  
			 *  @param  {Array} values  the 'arguments' object of the function
			 *  @param  {Array} keys the names of the arguments as they
			 *                                 should appear in the options object
			 *  @param {Object=} defaults optional defaults to mixin to the returned 
			 *                            options object                              
			 *  @return {Object}       the options object with the names mapped to the arguments
			 */
		    Tone.prototype.optionsObject = function (values, keys, defaults) {
		        var options = {};
		        if (values.length === 1 && typeof values[0] === 'object') {
		            options = values[0];
		        } else {
		            for (var i = 0; i < keys.length; i++) {
		                options[keys[i]] = values[i];
		            }
		        }
		        if (!this.isUndef(defaults)) {
		            return this.defaultArg(options, defaults);
		        } else {
		            return options;
		        }
		    };
		    /**
			 *  test if the arg is undefined
			 *  @param {*} arg the argument to test
			 *  @returns {boolean} true if the arg is undefined
			 *  @function
			 */
		    Tone.prototype.isUndef = isUndef;
		    /**
			 *  test if the arg is a function
			 *  @param {*} arg the argument to test
			 *  @returns {boolean} true if the arg is a function
			 *  @function
			 */
		    Tone.prototype.isFunction = isFunction;
		    /**
			 *  Make the property not writable. Internal use only. 
			 *  @private
			 *  @param  {string}  property  the property to make not writable
			 */
		    Tone.prototype._readOnly = function (property) {
		        if (Array.isArray(property)) {
		            for (var i = 0; i < property.length; i++) {
		                this._readOnly(property[i]);
		            }
		        } else {
		            Object.defineProperty(this, property, {
		                writable: false,
		                enumerable: true
		            });
		        }
		    };
		    /**
			 *  Make an attribute writeable. Interal use only. 
			 *  @private
			 *  @param  {string}  property  the property to make writable
			 */
		    Tone.prototype._writable = function (property) {
		        if (Array.isArray(property)) {
		            for (var i = 0; i < property.length; i++) {
		                this._writable(property[i]);
		            }
		        } else {
		            Object.defineProperty(this, property, { writable: true });
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    // GAIN CONVERSIONS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  equal power gain scale
			 *  good for cross-fading
			 *  @param  {number} percent (0-1)
			 *  @return {number}         output gain (0-1)
			 */
		    Tone.prototype.equalPowerScale = function (percent) {
		        var piFactor = 0.5 * Math.PI;
		        return Math.sin(percent * piFactor);
		    };
		    /**
			 *  convert db scale to gain scale (0-1)
			 *  @param  {number} db
			 *  @return {number}   
			 */
		    Tone.prototype.dbToGain = function (db) {
		        return Math.pow(2, db / 6);
		    };
		    /**
			 *  convert gain scale to decibels
			 *  @param  {number} gain (0-1)
			 *  @return {number}   
			 */
		    Tone.prototype.gainToDb = function (gain) {
		        return 20 * (Math.log(gain) / Math.LN10);
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	TIMING
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  @return {number} the currentTime from the AudioContext
			 */
		    Tone.prototype.now = function () {
		        return this.context.currentTime;
		    };
		    /**
			 *  convert a sample count to seconds
			 *  @param  {number} samples 
			 *  @return {number}         
			 */
		    Tone.prototype.samplesToSeconds = function (samples) {
		        return samples / this.context.sampleRate;
		    };
		    /**
			 *  convert a time into samples
			 *  
			 *  @param  {Tone.time} time
			 *  @return {number}         
			 */
		    Tone.prototype.toSamples = function (time) {
		        var seconds = this.toSeconds(time);
		        return Math.round(seconds * this.context.sampleRate);
		    };
		    /**
			 *  convert time to seconds
			 *
			 *  this is a simplified version which only handles numbers and 
			 *  'now' relative numbers. If the Transport is included this 
			 *  method is overridden to include many other features including 
			 *  notationTime, Frequency, and transportTime
			 *  
			 *  @param  {number=} time 
			 *  @param {number=} now if passed in, this number will be 
			 *                       used for all 'now' relative timings
			 *  @return {number}   	seconds in the same timescale as the AudioContext
			 */
		    Tone.prototype.toSeconds = function (time, now) {
		        now = this.defaultArg(now, this.now());
		        if (typeof time === 'number') {
		            return time;    //assuming that it's seconds
		        } else if (typeof time === 'string') {
		            var plusTime = 0;
		            if (time.charAt(0) === '+') {
		                time = time.slice(1);
		                plusTime = now;
		            }
		            return parseFloat(time) + plusTime;
		        } else {
		            return now;
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    // FREQUENCY CONVERSION
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  true if the input is in the format number+hz
			 *  i.e.: 10hz
			 *
			 *  @param {number} freq 
			 *  @return {boolean} 
			 *  @function
			 */
		    Tone.prototype.isFrequency = function () {
		        var freqFormat = new RegExp(/\d*\.?\d+hz$/i);
		        return function (freq) {
		            return freqFormat.test(freq);
		        };
		    }();
		    /**
			 *  Convert a frequency into seconds.
			 *  Accepts numbers and strings: i.e. "10hz" or 
			 *  10 both return 0.1. 
			 *  
			 *  @param  {number|string} freq 
			 *  @return {number}      
			 */
		    Tone.prototype.frequencyToSeconds = function (freq) {
		        return 1 / parseFloat(freq);
		    };
		    /**
			 *  Convert a number in seconds to a frequency.
			 *  @param  {number} seconds 
			 *  @return {number}         
			 */
		    Tone.prototype.secondsToFrequency = function (seconds) {
		        return 1 / seconds;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	INHERITANCE
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  have a child inherit all of Tone's (or a parent's) prototype
			 *  to inherit the parent's properties, make sure to call 
			 *  Parent.call(this) in the child's constructor
			 *
			 *  based on closure library's inherit function
			 *
			 *  @static
			 *  @param  {function} 	child  
			 *  @param  {function=} parent (optional) parent to inherit from
			 *                             if no parent is supplied, the child
			 *                             will inherit from Tone
			 */
		    Tone.extend = function (child, parent) {
		        if (isUndef(parent)) {
		            parent = Tone;
		        }
		        function TempConstructor() {
		        }
		        TempConstructor.prototype = parent.prototype;
		        child.prototype = new TempConstructor();
		        /** @override */
		        child.prototype.constructor = child;
		        child._super = parent;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	TYPES / STATES
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 * Possible types which a value can take on
			 * @enum {string}
			 */
		    Tone.Type = {
		        /** 
				 *  The default value is a number which can take on any value between [-Infinity, Infinity]
				 */
		        Default: 'number',
		        /**
				 *  Time can be described in a number of ways. Read more [Time](https://github.com/TONEnoTONE/Tone.js/wiki/Time).
				 *
				 *  <ul>
				 *  <li>Numbers, which will be taken literally as the time (in seconds).</li>
				 *  <li>Notation, ("4n", "8t") describes time in BPM and time signature relative values.</li>
				 *  <li>TransportTime, ("4:3:2") will also provide tempo and time signature relative times 
				 *  in the form BARS:QUARTERS:SIXTEENTHS.</li>
				 *  <li>Frequency, ("8hz") is converted to the length of the cycle in seconds.</li>
				 *  <li>Now-Relative, ("+1") prefix any of the above with "+" and it will be interpreted as 
				 *  "the current time plus whatever expression follows".</li>
				 *  <li>Expressions, ("3:0 + 2 - (1m / 7)") any of the above can also be combined 
				 *  into a mathematical expression which will be evaluated to compute the desired time.</li>
				 *  <li>No Argument, for methods which accept time, no argument will be interpreted as 
				 *  "now" (i.e. the currentTime).</li>
				 *  </ul>
				 *  
				 *  @typedef {Time}
				 */
		        Time: 'time',
		        /**
				 *  Frequency can be described similar to time, except ultimately the
				 *  values are converted to frequency instead of seconds. A number
				 *  is taken literally as the value in hertz. Additionally any of the 
				 *  Time encodings can be used. Note names in the form
				 *  of NOTE OCTAVE (i.e. C4) are also accepted and converted to their
				 *  frequency value. 
				 *  @typedef {Frequency}
				 */
		        Frequency: 'frequency',
		        /**
				 * Gain is the ratio between the input and the output value of a signal.
				 *  @typedef {Gain}
				 */
		        Gain: 'gain',
		        /** 
				 *  Normal values are within the range [0, 1].
				 *  @typedef {NormalRange}
				 */
		        NormalRange: 'normalrange',
		        /** 
				 *  AudioRange values are between [-1, 1].
				 *  @typedef {AudioRange}
				 */
		        AudioRange: 'audiorange',
		        /** 
				 *  Decibels are a logarithmic unit of measurement which is useful for volume
				 *  because of the logarithmic way that we perceive loudness. 0 decibels 
				 *  means no change in volume. -10db is approximately half as loud and 10db 
				 *  is twice is loud. 
				 *  @typedef {Decibels}
				 */
		        Decibels: 'db',
		        /** 
				 *  Half-step note increments, i.e. 12 is an octave above the root. and 1 is a half-step up.
				 *  @typedef {Interval}
				 */
		        Interval: 'interval',
		        /** 
				 *  Beats per minute. 
				 *  @typedef {BPM}
				 */
		        BPM: 'bpm',
		        /** 
				 *  The value must be greater than 0.
				 *  @typedef {Positive}
				 */
		        Positive: 'positive',
		        /** 
				 *  A cent is a hundredth of a semitone. 
				 *  @typedef {Cents}
				 */
		        Cents: 'cents',
		        /** 
				 *  Angle between 0 and 360. 
				 *  @typedef {Degrees}
				 */
		        Degrees: 'degrees',
		        /** 
				 *  A number representing a midi note.
				 *  @typedef {MIDI}
				 */
		        MIDI: 'midi',
		        /** 
				 *  A colon-separated representation of time in the form of
				 *  BARS:QUARTERS:SIXTEENTHS. 
				 *  @typedef {TransportTime}
				 */
		        TransportTime: 'transporttime'
		    };
		    /**
			 * Possible play states. 
			 * @enum {string}
			 */
		    Tone.State = {
		        Started: 'started',
		        Stopped: 'stopped',
		        Paused: 'paused'
		    };
		    /**
			 *  An empty function.
			 *  @static
			 */
		    Tone.noOp = function () {
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	CONTEXT
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  array of callbacks to be invoked when a new context is added
			 *  @private 
			 *  @private
			 */
		    var newContextCallbacks = [];
		    /**
			 *  invoke this callback when a new context is added
			 *  will be invoked initially with the first context
			 *  @private 
			 *  @static
			 *  @param {function(AudioContext)} callback the callback to be invoked
			 *                                           with the audio context
			 */
		    Tone._initAudioContext = function (callback) {
		        //invoke the callback with the existing AudioContext
		        callback(Tone.context);
		        //add it to the array
		        newContextCallbacks.push(callback);
		    };
		    /**
			 *  Tone automatically creates a context on init, but if you are working
			 *  with other libraries which also create an AudioContext, it can be
			 *  useful to set your own. If you are going to set your own context, 
			 *  be sure to do it at the start of your code, before creating any objects.
			 *  @static
			 *  @param {AudioContext} ctx The new audio context to set
			 */
		    Tone.setContext = function (ctx) {
		        //set the prototypes
		        Tone.prototype.context = ctx;
		        Tone.context = ctx;
		        //invoke all the callbacks
		        for (var i = 0; i < newContextCallbacks.length; i++) {
		            newContextCallbacks[i](ctx);
		        }
		    };
		    /**
			 *  Bind this to a touchstart event to start the audio on mobile devices. 
			 *  <br>
			 *  http://stackoverflow.com/questions/12517000/no-sound-on-ios-6-web-audio-api/12569290#12569290
			 *  @static
			 */
		    Tone.startMobile = function () {
		        var osc = Tone.context.createOscillator();
		        var silent = Tone.context.createGain();
		        silent.gain.value = 0;
		        osc.connect(silent);
		        silent.connect(Tone.context.destination);
		        var now = Tone.context.currentTime;
		        osc.start(now);
		        osc.stop(now + 1);
		    };
		    //setup the context
		    Tone._initAudioContext(function (audioContext) {
		        //set the bufferTime
		        Tone.prototype.bufferTime = Tone.prototype.bufferSize / audioContext.sampleRate;
		        _silentNode = audioContext.createGain();
		        _silentNode.gain.value = 0;
		        _silentNode.connect(audioContext.destination);
		    });
		    Tone.version = 'r5';
		    console.log('%c * Tone.js ' + Tone.version + ' * ', 'background: #000; color: #fff');
		    return Tone;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Base class for all Signals. Used Internally. 
			 *
			 *  @constructor
			 *  @extends {Tone}
			 */
		    Tone.SignalBase = function () {
		    };
		    Tone.extend(Tone.SignalBase);
		    /**
			 *  When signals connect to other signals or AudioParams, 
			 *  they take over the output value of that signal or AudioParam. 
			 *  For all other nodes, the behavior is the same as a default <code>connect</code>. 
			 *
			 *  @override
			 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node 
			 *  @param {number} [outputNumber=0] The output number to connect from.
			 *  @param {number} [inputNumber=0] The input number to connect to.
			 *  @returns {Tone.SignalBase} this
			 */
		    Tone.SignalBase.prototype.connect = function (node, outputNumber, inputNumber) {
		        //zero it out so that the signal can have full control
		        if (node.constructor === Tone.Signal) {
		            //cancel changes
		            node._value.cancelScheduledValues(0);
		            //reset the value
		            node._value.value = 0;
		            //mark the value as overridden
		            node.overridden = true;
		        } else if (node instanceof AudioParam) {
		            node.cancelScheduledValues(0);
		            node.value = 0;
		        }
		        Tone.prototype.connect.call(this, node, outputNumber, inputNumber);
		        return this;
		    };
		    return Tone.SignalBase;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Wraps the native Web Audio API 
			 *         [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {function|Array|Number} mapping The function used to define the values. 
			 *                                    The mapping function should take two arguments: 
			 *                                    the first is the value at the current position 
			 *                                    and the second is the array position. 
			 *                                    If the argument is an array, that array will be
			 *                                    set as the wave shaping function. The input
			 *                                    signal is an AudioRange [-1, 1] value and the output
			 *                                    signal can take on any numerical values. 
			 *                                    
			 *  @param {Number} [bufferLen=1024] The length of the WaveShaperNode buffer.
			 *  @example
			 * var timesTwo = new Tone.WaveShaper(function(val){
			 * 	return val * 2;
			 * }, 2048);
			 *  @example
			 * //a waveshaper can also be constructed with an array of values
			 * var invert = new Tone.WaveShaper([1, -1]);
			 */
		    Tone.WaveShaper = function (mapping, bufferLen) {
		        /**
				 *  the waveshaper
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._shaper = this.input = this.output = this.context.createWaveShaper();
		        /**
				 *  the waveshapers curve
				 *  @type {Float32Array}
				 *  @private
				 */
		        this._curve = null;
		        if (Array.isArray(mapping)) {
		            this.curve = mapping;
		        } else if (isFinite(mapping) || this.isUndef(mapping)) {
		            this._curve = new Float32Array(this.defaultArg(mapping, 1024));
		        } else if (this.isFunction(mapping)) {
		            this._curve = new Float32Array(this.defaultArg(bufferLen, 1024));
		            this.setMap(mapping);
		        }
		    };
		    Tone.extend(Tone.WaveShaper, Tone.SignalBase);
		    /**
			 *  Uses a mapping function to set the value of the curve. 
			 *  @param {function} mapping The function used to define the values. 
			 *                            The mapping function take two arguments: 
			 *                            the first is the value at the current position 
			 *                            which goes from -1 to 1 over the number of elements
			 *                            in the curve array. The second argument is the array position. 
			 *  @returns {Tone.WaveShaper} this
			 *  @example
			 * //map the input signal from [-1, 1] to [0, 10]
			 * shaper.setMap(function(val, index){
			 * 	return (val + 1) * 5;
			 * })
			 */
		    Tone.WaveShaper.prototype.setMap = function (mapping) {
		        for (var i = 0, len = this._curve.length; i < len; i++) {
		            var normalized = i / len * 2 - 1;
		            this._curve[i] = mapping(normalized, i);
		        }
		        this._shaper.curve = this._curve;
		        return this;
		    };
		    /**
			 * The array to set as the waveshaper curve. For linear curves
			 * array length does not make much difference, but for complex curves
			 * longer arrays will provide smoother interpolation. 
			 * @memberOf Tone.WaveShaper#
			 * @type {Array}
			 * @name curve
			 */
		    Object.defineProperty(Tone.WaveShaper.prototype, 'curve', {
		        get: function () {
		            return this._shaper.curve;
		        },
		        set: function (mapping) {
		            //fixes safari WaveShaperNode bug
		            if (this._isSafari()) {
		                var first = mapping[0];
		                mapping.unshift(first);
		            }
		            this._curve = new Float32Array(mapping);
		            this._shaper.curve = this._curve;
		        }
		    });
		    /**
			 * Specifies what type of oversampling (if any) should be used when 
			 * applying the shaping curve. Can either be "none", "2x" or "4x". 
			 * @memberOf Tone.WaveShaper#
			 * @type {string}
			 * @name oversample
			 */
		    Object.defineProperty(Tone.WaveShaper.prototype, 'oversample', {
		        get: function () {
		            return this._shaper.oversample;
		        },
		        set: function (oversampling) {
		            this._shaper.oversample = oversampling;
		        }
		    });
		    /**
			 *  returns true if the browser is safari
			 *  @return  {boolean} 
			 *  @private
			 */
		    Tone.WaveShaper.prototype._isSafari = function () {
		        var ua = navigator.userAgent.toLowerCase();
		        return ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.WaveShaper} this
			 */
		    Tone.WaveShaper.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._shaper.disconnect();
		        this._shaper = null;
		        this._curve = null;
		        return this;
		    };
		    return Tone.WaveShaper;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A signal is an audio-rate value. Tone.Signal is a core component of the library.
			 *          Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal
			 *          has all of the methods available to native Web Audio 
			 *          [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)
			 *          as well as additional conveniences. Read more about working with signals 
			 *          [here](https://github.com/TONEnoTONE/Tone.js/wiki/Signals).
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {Number|AudioParam} [value] Initial value of the signal. If an AudioParam
			 *                                     is passed in, that parameter will be wrapped
			 *                                     and controlled by the Signal. 
			 *  @param {string} [units=Number] unit The units the signal is in. 
			 *  @example
			 * var signal = new Tone.Signal(10);
			 */
		    Tone.Signal = function () {
		        var options = this.optionsObject(arguments, [
		            'value',
		            'units'
		        ], Tone.Signal.defaults);
		        /**
				 * The units of the signal.
				 * @type {string}
				 */
		        this.units = options.units;
		        /**
				 *  When true, converts the set value
				 *  based on the units given. When false,
				 *  applies no conversion and the units
				 *  are merely used as a label. 
				 *  @type  {boolean}
				 */
		        this.convert = options.convert;
		        /**
				 *  True if the signal value is being overridden by 
				 *  a connected signal.
				 *  @readOnly
				 *  @type  {boolean}
				 *  @private
				 */
		        this.overridden = false;
		        /**
				 * The node where the constant signal value is scaled.
				 * @type {GainNode}
				 * @private
				 */
		        this.output = this._scaler = this.context.createGain();
		        /**
				 * The node where the value is set.
				 * @type {AudioParam}
				 * @private
				 */
		        this.input = this._value = this._scaler.gain;
		        if (options.value instanceof AudioParam) {
		            this._scaler.connect(options.value);
		            //zero out the value
		            options.value.value = 0;
		        } else {
		            if (!this.isUndef(options.param)) {
		                this._scaler.connect(options.param);
		                options.param.value = 0;
		            }
		            this.value = options.value;
		        }
		        //connect the constant 1 output to the node output
		        Tone.Signal._constant.chain(this._scaler);
		    };
		    Tone.extend(Tone.Signal, Tone.SignalBase);
		    /**
			 *  The default values
			 *  @type  {Object}
			 *  @static
			 *  @const
			 */
		    Tone.Signal.defaults = {
		        'value': 0,
		        'param': undefined,
		        'units': Tone.Type.Default,
		        'convert': true
		    };
		    /**
			 * The current value of the signal. 
			 * @memberOf Tone.Signal#
			 * @type {Number}
			 * @name value
			 */
		    Object.defineProperty(Tone.Signal.prototype, 'value', {
		        get: function () {
		            return this._toUnits(this._value.value);
		        },
		        set: function (value) {
		            var convertedVal = this._fromUnits(value);
		            //is this what you want?
		            this.cancelScheduledValues(0);
		            this._value.value = convertedVal;
		        }
		    });
		    /**
			 * @private
			 * @param  {*} val the value to convert
			 * @return {number}     the number which the value should be set to
			 */
		    Tone.Signal.prototype._fromUnits = function (val) {
		        if (this.convert || this.isUndef(this.convert)) {
		            switch (this.units) {
		            case Tone.Type.Time:
		                return this.toSeconds(val);
		            case Tone.Type.Frequency:
		                return this.toFrequency(val);
		            case Tone.Type.Decibels:
		                return this.dbToGain(val);
		            case Tone.Type.NormalRange:
		                return Math.min(Math.max(val, 0), 1);
		            case Tone.Type.AudioRange:
		                return Math.min(Math.max(val, -1), 1);
		            case Tone.Type.Positive:
		                return Math.max(val, 0);
		            default:
		                return val;
		            }
		        } else {
		            return val;
		        }
		    };
		    /**
			 * convert to the desired units
			 * @private
			 * @param  {number} val the value to convert
			 * @return {number}
			 */
		    Tone.Signal.prototype._toUnits = function (val) {
		        if (this.convert || this.isUndef(this.convert)) {
		            switch (this.units) {
		            case Tone.Type.Decibels:
		                return this.gainToDb(val);
		            default:
		                return val;
		            }
		        } else {
		            return val;
		        }
		    };
		    /**
			 *  Schedules a parameter value change at the given time.
			 *  @param {*}	value The value to set the signal.
			 *  @param {Time}  time The time when the change should occur.
			 *  @returns {Tone.Signal} this
			 *  @example
			 * //set the frequency to "G4" in exactly 1 second from now. 
			 * freq.setValueAtTime("G4", "+1");
			 */
		    Tone.Signal.prototype.setValueAtTime = function (value, time) {
		        value = this._fromUnits(value);
		        this._value.setValueAtTime(value, this.toSeconds(time));
		        return this;
		    };
		    /**
			 *  Creates a schedule point with the current value at the current time.
			 *  This is useful for creating an automation anchor point in order to 
			 *  schedule changes from the current value. 
			 *
			 *  @param {number=} now (Optionally) pass the now value in. 
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.setCurrentValueNow = function (now) {
		        now = this.defaultArg(now, this.now());
		        var currentVal = this._value.value;
		        this.cancelScheduledValues(now);
		        this._value.setValueAtTime(currentVal, now);
		        return this;
		    };
		    /**
			 *  Schedules a linear continuous change in parameter value from the 
			 *  previous scheduled parameter value to the given value.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} endTime 
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.linearRampToValueAtTime = function (value, endTime) {
		        value = this._fromUnits(value);
		        this._value.linearRampToValueAtTime(value, this.toSeconds(endTime));
		        return this;
		    };
		    /**
			 *  Schedules an exponential continuous change in parameter value from 
			 *  the previous scheduled parameter value to the given value.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} endTime 
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.exponentialRampToValueAtTime = function (value, endTime) {
		        value = this._fromUnits(value);
		        value = Math.max(0.00001, value);
		        this._value.exponentialRampToValueAtTime(value, this.toSeconds(endTime));
		        return this;
		    };
		    /**
			 *  Schedules an exponential continuous change in parameter value from 
			 *  the current time and current value to the given value.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} rampTime the time that it takes the 
			 *                               value to ramp from it's current value
			 *  @returns {Tone.Signal} this
			 *  @example
			 * //exponentially ramp to the value 2 over 4 seconds. 
			 * signal.exponentialRampToValueNow(2, 4);
			 */
		    Tone.Signal.prototype.exponentialRampToValueNow = function (value, rampTime) {
		        var now = this.now();
		        // exponentialRampToValueAt cannot ever ramp from 0, apparently.
		        // More info: https://bugzilla.mozilla.org/show_bug.cgi?id=1125600#c2
		        var currentVal = this.value;
		        this.setValueAtTime(Math.max(currentVal, 0.0001), now);
		        this.exponentialRampToValueAtTime(value, now + this.toSeconds(rampTime));
		        return this;
		    };
		    /**
			 *  Schedules an linear continuous change in parameter value from 
			 *  the current time and current value to the given value at the given time.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} rampTime the time that it takes the 
			 *                               value to ramp from it's current value
			 *  @returns {Tone.Signal} this
			 *  @example
			 * //linearly ramp to the value 4 over 3 seconds. 
			 * signal.linearRampToValueNow(4, 3);
			 */
		    Tone.Signal.prototype.linearRampToValueNow = function (value, rampTime) {
		        var now = this.now();
		        this.setCurrentValueNow(now);
		        this.linearRampToValueAtTime(value, now + this.toSeconds(rampTime));
		        return this;
		    };
		    /**
			 *  Start exponentially approaching the target value at the given time with
			 *  a rate having the given time constant.
			 *  @param {number} value        
			 *  @param {Time} startTime    
			 *  @param {number} timeConstant 
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
		        value = this._fromUnits(value);
		        // The value will never be able to approach without timeConstant > 0.
		        // http://www.w3.org/TR/webaudio/#dfn-setTargetAtTime, where the equation
		        // is described. 0 results in a division by 0.
		        timeConstant = Math.max(0.00001, timeConstant);
		        this._value.setTargetAtTime(value, this.toSeconds(startTime), timeConstant);
		        return this;
		    };
		    /**
			 *  Sets an array of arbitrary parameter values starting at the given time
			 *  for the given duration.
			 *  	
			 *  @param {Array} values    
			 *  @param {Time} startTime 
			 *  @param {Time} duration  
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.setValueCurveAtTime = function (values, startTime, duration) {
		        for (var i = 0; i < values.length; i++) {
		            values[i] = this._fromUnits(values[i]);
		        }
		        this._value.setValueCurveAtTime(values, this.toSeconds(startTime), this.toSeconds(duration));
		        return this;
		    };
		    /**
			 *  Cancels all scheduled parameter changes with times greater than or 
			 *  equal to startTime.
			 *  
			 *  @param  {Time} startTime
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.cancelScheduledValues = function (startTime) {
		        this._value.cancelScheduledValues(this.toSeconds(startTime));
		        return this;
		    };
		    /**
			 *  Ramps to the given value over the duration of the rampTime. 
			 *  Automatically selects the best ramp type (exponential or linear)
			 *  depending on the `units` of the signal
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} rampTime the time that it takes the 
			 *                               value to ramp from it's current value
			 *  @returns {Tone.Signal} this
			 *  @example
			 * //ramp to the value either linearly or exponentially 
			 * //depending on the "units" value of the signal
			 * signal.rampTo(0, 10);
			 */
		    Tone.Signal.prototype.rampTo = function (value, rampTime) {
		        rampTime = this.defaultArg(rampTime, 0);
		        if (this.units === Tone.Type.Frequency || this.units === Tone.Type.BPM) {
		            this.exponentialRampToValueNow(value, rampTime);
		        } else {
		            this.linearRampToValueNow(value, rampTime);
		        }
		        return this;
		    };
		    /**
			 *  dispose and disconnect
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._value = null;
		        this._scaler = null;
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	STATIC
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  the constant signal generator
			 *  @static
			 *  @private
			 *  @const
			 *  @type {OscillatorNode}
			 */
		    Tone.Signal._generator = null;
		    /**
			 *  the signal generator waveshaper. makes the incoming signal
			 *  only output 1 for all inputs.
			 *  @static
			 *  @private
			 *  @const
			 *  @type {Tone.WaveShaper}
			 */
		    Tone.Signal._constant = null;
		    /**
			 *  initializer function
			 */
		    Tone._initAudioContext(function (audioContext) {
		        Tone.Signal._generator = audioContext.createOscillator();
		        Tone.Signal._constant = new Tone.WaveShaper([
		            1,
		            1
		        ]);
		        Tone.Signal._generator.connect(Tone.Signal._constant);
		        Tone.Signal._generator.start(0);
		        Tone.Signal._generator.noGC();
		    });
		    return Tone.Signal;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Pow applies an exponent to the incoming signal. The incoming signal
			 *         must be AudioRange.
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {number} exp The exponent to apply to the incoming signal, must be at least 2. 
			 *  @example
			 * var pow = new Tone.Pow(2);
			 * var sig = new Tone.Signal(0.5).connect(pow);
			 * //output of pow is 0.25. 
			 */
		    Tone.Pow = function (exp) {
		        /**
				 * the exponent
				 * @private
				 * @type {number}
				 */
		        this._exp = this.defaultArg(exp, 1);
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._expScaler = this.input = this.output = new Tone.WaveShaper(this._expFunc(this._exp), 8192);
		    };
		    Tone.extend(Tone.Pow, Tone.SignalBase);
		    /**
			 * The value of the exponent.
			 * @memberOf Tone.Pow#
			 * @type {number}
			 * @name value
			 */
		    Object.defineProperty(Tone.Pow.prototype, 'value', {
		        get: function () {
		            return this._exp;
		        },
		        set: function (exp) {
		            this._exp = exp;
		            this._expScaler.setMap(this._expFunc(this._exp));
		        }
		    });
		    /**
			 *  the function which maps the waveshaper
			 *  @param   {number} exp
			 *  @return {function}
			 *  @private
			 */
		    Tone.Pow.prototype._expFunc = function (exp) {
		        return function (val) {
		            return Math.pow(Math.abs(val), exp);
		        };
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Pow} this
			 */
		    Tone.Pow.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._expScaler.dispose();
		        this._expScaler = null;
		        return this;
		    };
		    return Tone.Pow;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)
			 *          envelope generator. Tone.Envelope outputs a signal which 
			 *          can be connected to an AudioParam or Tone.Signal. 
			 *          <img src="https://upload.wikimedia.org/wikipedia/commons/e/ea/ADSR_parameter.svg">
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Time} [attack] The amount of time it takes for the envelope to go from 
			 *                         0 to it's maximum value. 
			 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
			 *                       	to fall to the sustain value. 
			 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
			 *                                	the release is triggered. 
			 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0. 
			 *  @example
			 * //an amplitude envelope
			 * var gainNode = Tone.context.createGain();
			 * var env = new Tone.Envelope({
			 * 	"attack" : 0.1,
			 * 	"decay" : 0.2,
			 * 	"sustain" : 1,
			 * 	"release" : 0.8,
			 * });
			 * env.connect(gainNode.gain);
			 */
		    Tone.Envelope = function () {
		        //get all of the defaults
		        var options = this.optionsObject(arguments, [
		            'attack',
		            'decay',
		            'sustain',
		            'release'
		        ], Tone.Envelope.defaults);
		        /** 
				 *  When triggerAttack is called, the attack time is the amount of
				 *  time it takes for the envelope to reach it's maximum value. 
				 *  @type {Time}
				 */
		        this.attack = options.attack;
		        /**
				 *  After the attack portion of the envelope, the value will fall
				 *  over the duration of the decay time to it's sustain value. 
				 *  @type {Time}
				 */
		        this.decay = options.decay;
		        /**
				 * 	The sustain value is the value 
				 * 	which the envelope rests at after triggerAttack is
				 * 	called, but before triggerRelease is invoked. 
				 *  @type {NormalRange}
				 */
		        this.sustain = options.sustain;
		        /**
				 *  After triggerRelease is called, the envelope's
				 *  value will fall to it's miminum value over the
				 *  duration of the release time. 
				 *  @type {Time}
				 */
		        this.release = options.release;
		        /**
				 *  the next time the envelope is attacked
				 *  @type {number}
				 *  @private
				 */
		        this._nextAttack = Infinity;
		        /**
				 *  the next time the envelope is decayed
				 *  @type {number}
				 *  @private
				 */
		        this._nextDecay = Infinity;
		        /**
				 *  the next time the envelope is sustain
				 *  @type {number}
				 *  @private
				 */
		        this._nextSustain = Infinity;
		        /**
				 *  the next time the envelope is released
				 *  @type {number}
				 *  @private
				 */
		        this._nextRelease = Infinity;
		        /**
				 *  the next time the envelope is at standby
				 *  @type {number}
				 *  @private
				 */
		        this._nextStandby = Infinity;
		        /**
				 *  the next time the envelope is at standby
				 *  @type {number}
				 *  @private
				 */
		        this._attackCurve = Tone.Envelope.Type.Linear;
		        /** 
				 *  the last recorded velocity value
				 *  @type {number}
				 *  @private
				 */
		        this._peakValue = 1;
		        /**
				 *  the minimum output value
				 *  @type {number}
				 *  @private
				 */
		        this._minOutput = 0.0001;
		        /**
				 *  the signal
				 *  @type {Tone.Signal}
				 *  @private
				 */
		        this._sig = this.output = new Tone.Signal(0);
		        //set the attackCurve initially
		        this.attackCurve = options.attackCurve;
		    };
		    Tone.extend(Tone.Envelope);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 */
		    Tone.Envelope.defaults = {
		        'attack': 0.01,
		        'decay': 0.1,
		        'sustain': 0.5,
		        'release': 1,
		        'attackCurve': 'linear'
		    };
		    /**
			 *  the envelope time multipler
			 *  @type {number}
			 *  @private
			 */
		    Tone.Envelope.prototype._timeMult = 0.25;
		    /**
			 * Read the current value of the envelope. Useful for 
			 * syncronizing visual output to the envelope. 
			 * @memberOf Tone.Envelope#
			 * @type {Number}
			 * @name value
			 * @readOnly
			 */
		    Object.defineProperty(Tone.Envelope.prototype, 'value', {
		        get: function () {
		            return this._sig.value;
		        }
		    });
		    /**
			 * The slope of the attack. Either "linear" or "exponential". 
			 * @memberOf Tone.Envelope#
			 * @type {string}
			 * @name attackCurve
			 * @example
			 * env.attackCurve = "linear";
			 */
		    Object.defineProperty(Tone.Envelope.prototype, 'attackCurve', {
		        get: function () {
		            return this._attackCurve;
		        },
		        set: function (type) {
		            if (type === Tone.Envelope.Type.Linear || type === Tone.Envelope.Type.Exponential) {
		                this._attackCurve = type;
		            } else {
		                throw Error('attackCurve must be either "linear" or "exponential". Invalid type: ', type);
		            }
		        }
		    });
		    /**
			 *  Get the phase of the envelope at the specified time.
			 *  @param  {number}  time
			 *  @return  {Tone.Envelope.Phase} 
			 *  @private
			 */
		    Tone.Envelope.prototype._phaseAtTime = function (time) {
		        if (this._nextRelease > time) {
		            if (this._nextAttack <= time && this._nextDecay > time) {
		                return Tone.Envelope.Phase.Attack;
		            } else if (this._nextDecay <= time && this._nextSustain > time) {
		                return Tone.Envelope.Phase.Decay;
		            } else if (this._nextSustain <= time && this._nextRelease > time) {
		                return Tone.Envelope.Phase.Sustain;
		            } else {
		                return Tone.Envelope.Phase.Standby;
		            }
		        } else if (this._nextRelease < time && this._nextStandby > time) {
		            return Tone.Envelope.Phase.Release;
		        } else {
		            return Tone.Envelope.Phase.Standby;
		        }
		    };
		    /**
			 *  https://github.com/jsantell/web-audio-automation-timeline
			 *  MIT License, copyright (c) 2014 Jordan Santell
			 *  @private
			 */
		    Tone.Envelope.prototype._exponentialApproach = function (t0, v0, v1, timeConstant, t) {
		        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);
		    };
		    /**
			 *  @private
			 */
		    Tone.Envelope.prototype._linearInterpolate = function (t0, v0, t1, v1, t) {
		        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));
		    };
		    /**
			 *  @private
			 */
		    Tone.Envelope.prototype._exponentialInterpolate = function (t0, v0, t1, v1, t) {
		        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));
		    };
		    /**
			 *  Get the envelopes value at the given time
			 *  @param  {number}  time
			 *  @param  {number}  velocity
			 *  @return  {number} 
			 *  @private
			 */
		    Tone.Envelope.prototype._valueAtTime = function (time) {
		        var attack = this.toSeconds(this.attack);
		        var decay = this.toSeconds(this.decay);
		        var release = this.toSeconds(this.release);
		        switch (this._phaseAtTime(time)) {
		        case Tone.Envelope.Phase.Attack:
		            if (this._attackCurve === Tone.Envelope.Type.Linear) {
		                return this._linearInterpolate(this._nextAttack, this._minOutput, this._nextAttack + attack, this._peakValue, time);
		            } else {
		                return this._exponentialInterpolate(this._nextAttack, this._minOutput, this._nextAttack + attack, this._peakValue, time);
		            }
		            break;
		        case Tone.Envelope.Phase.Decay:
		            return this._exponentialApproach(this._nextDecay, this._peakValue, this.sustain * this._peakValue, decay * this._timeMult, time);
		        case Tone.Envelope.Phase.Release:
		            return this._exponentialApproach(this._nextRelease, this._peakValue, this._minOutput, release * this._timeMult, time);
		        case Tone.Envelope.Phase.Sustain:
		            return this.sustain * this._peakValue;
		        case Tone.Envelope.Phase.Standby:
		            return this._minOutput;
		        }
		    };
		    /**
			 *  Trigger the attack/decay portion of the ADSR envelope. 
			 *  @param  {Time} [time=now] When the attack should start.
			 *  @param {NormalRange} [velocity=1] The velocity of the envelope scales the vales.
			 *                               number between 0-1
			 *  @returns {Tone.Envelope} this
			 *  @example
			 *  //trigger the attack 0.5 seconds from now with a velocity of 0.2
			 *  env.triggerAttack("+0.5", 0.2);
			 */
		    Tone.Envelope.prototype.triggerAttack = function (time, velocity) {
		        //to seconds
		        time = this.toSeconds(time);
		        var attack = this.toSeconds(this.attack);
		        var decay = this.toSeconds(this.decay);
		        //get the phase and position
		        var valueAtTime = this._valueAtTime(time);
		        var attackPast = valueAtTime * attack;
		        //compute the timing
		        this._nextAttack = time - attackPast;
		        this._nextDecay = this._nextAttack + attack;
		        this._nextSustain = this._nextDecay + decay;
		        this._nextRelease = Infinity;
		        //get the values
		        this._peakValue = this.defaultArg(velocity, 1);
		        var scaledMax = this._peakValue;
		        var sustainVal = this.sustain * scaledMax;
		        //set the curve		
		        this._sig.cancelScheduledValues(time);
		        this._sig.setValueAtTime(valueAtTime, time);
		        if (this._attackCurve === Tone.Envelope.Type.Linear) {
		            this._sig.linearRampToValueAtTime(scaledMax, this._nextDecay);
		        } else {
		            this._sig.exponentialRampToValueAtTime(scaledMax, this._nextDecay);
		        }
		        this._sig.setTargetAtTime(sustainVal, this._nextDecay, decay * this._timeMult);
		        return this;
		    };
		    /**
			 *  Triggers the release of the envelope.
			 *  @param  {Time} [time=now] When the release portion of the envelope should start. 
			 *  @returns {Tone.Envelope} this
			 *  @example
			 *  //trigger release immediately
			 *  env.triggerRelease();
			 */
		    Tone.Envelope.prototype.triggerRelease = function (time) {
		        time = this.toSeconds(time);
		        var phase = this._phaseAtTime(time);
		        var release = this.toSeconds(this.release);
		        //computer the value at the start of the next release
		        var valueAtTime = this._valueAtTime(time);
		        this._peakValue = valueAtTime;
		        this._nextRelease = time;
		        this._nextStandby = this._nextRelease + release;
		        //set the values
		        this._sig.cancelScheduledValues(this._nextRelease);
		        //if the phase is in the attack still, must reschedule the rest of the attack
		        if (phase === Tone.Envelope.Phase.Attack) {
		            this._sig.setCurrentValueNow();
		            if (this.attackCurve === Tone.Envelope.Type.Linear) {
		                this._sig.linearRampToValueAtTime(this._peakValue, this._nextRelease);
		            } else {
		                this._sig.exponentialRampToValueAtTime(this._peakValue, this._nextRelease);
		            }
		        } else {
		            this._sig.setValueAtTime(this._peakValue, this._nextRelease);
		        }
		        this._sig.setTargetAtTime(this._minOutput, this._nextRelease, release * this._timeMult);
		        return this;
		    };
		    /**
			 *  triggerAttackRelease is shorthand for triggerAttack, then waiting
			 *  some duration, then triggerRelease. 
			 *  @param {Time} duration The duration of the sustain.
			 *  @param {Time} [time=now] When the attack should be triggered.
			 *  @param {number} [velocity=1] The velocity of the envelope. 
			 *  @returns {Tone.Envelope} this
			 *  @example
			 * //trigger the attack and then the release after 0.6 seconds.
			 * env.triggerAttackRelease(0.6);
			 */
		    Tone.Envelope.prototype.triggerAttackRelease = function (duration, time, velocity) {
		        time = this.toSeconds(time);
		        this.triggerAttack(time, velocity);
		        this.triggerRelease(time + this.toSeconds(duration));
		        return this;
		    };
		    /**
			 *  Borrows the connect method from Tone.Signal. 
			 *  @function
			 *  @private
			 */
		    Tone.Envelope.prototype.connect = Tone.Signal.prototype.connect;
		    /**
			 *  Disconnect and dispose.
			 *  @returns {Tone.Envelope} this
			 */
		    Tone.Envelope.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._sig.dispose();
		        this._sig = null;
		        return this;
		    };
		    /**
			 *  The phase of the envelope. 
			 *  @enum {string}
			 */
		    Tone.Envelope.Phase = {
		        Attack: 'attack',
		        Decay: 'decay',
		        Sustain: 'sustain',
		        Release: 'release',
		        Standby: 'standby'
		    };
		    /**
			 *  The phase of the envelope. 
			 *  @enum {string}
			 */
		    Tone.Envelope.Type = {
		        Linear: 'linear',
		        Exponential: 'exponential'
		    };
		    return Tone.Envelope;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.AmplitudeEnvelope is a Tone.Envelope connected to a gain node. 
			 *          Unlike Tone.Envelope, which outputs the envelope's value, Tone.AmplitudeEnvelope accepts
			 *          an audio signal as the input and will apply the envelope to the amplitude
			 *          of the signal. Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).
			 *  
			 *  @constructor
			 *  @extends {Tone.Envelope}
			 *  @param {Time|Object} [attack] The amount of time it takes for the envelope to go from 
			 *                               0 to it's maximum value. 
			 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
			 *                       	to fall to the sustain value. 
			 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
			 *                                	the release is triggered. 
			 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0. 
			 *  @example
			 * var ampEnv = new Tone.AmplitudeEnvelope({
			 * 	"attack": 0.1,
			 * 	"decay": 0.2,
			 * 	"sustain": 1.0,
			 * 	"release": 0.8
			 * }).toMaster();
			 * //create an oscillator and connect it
			 * var osc = new Tone.Oscillator().connect(ampEnv).start();
			 * //trigger the envelopes attack and release "8t" apart
			 * ampEnv.triggerAttackRelease("8t");
			 */
		    Tone.AmplitudeEnvelope = function () {
		        Tone.Envelope.apply(this, arguments);
		        /**
				 *  the input node
				 *  @type {GainNode}
				 *  @private
				 */
		        this.input = this.output = this.context.createGain();
		        this._sig.connect(this.output.gain);
		    };
		    Tone.extend(Tone.AmplitudeEnvelope, Tone.Envelope);
		    return Tone.AmplitudeEnvelope;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Compressor is a thin wrapper around the Web Audio 
			 *         [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).
			 *         Compression reduces the volume of loud sounds or amplifies quiet sounds 
			 *         by narrowing or "compressing" an audio signal's dynamic range. 
			 *         Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Decibels|Object} [threshold] The value above which the compression starts to be applied.
			 *  @param {Positive} [ratio] The gain reduction ratio.
			 *  @example
			 * var comp = new Tone.Compressor(-30, 3);
			 */
		    Tone.Compressor = function () {
		        var options = this.optionsObject(arguments, [
		            'threshold',
		            'ratio'
		        ], Tone.Compressor.defaults);
		        /**
				 *  the compressor node
				 *  @type {DynamicsCompressorNode}
				 *  @private
				 */
		        this._compressor = this.input = this.output = this.context.createDynamicsCompressor();
		        /**
				 *  the threshold vaue
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.threshold = this._compressor.threshold;
		        /**
				 *  The attack parameter
				 *  @type {Time}
				 *  @signal
				 */
		        this.attack = new Tone.Signal(this._compressor.attack, Tone.Type.Time);
		        /**
				 *  The release parameter
				 *  @type {Time}
				 *  @signal
				 */
		        this.release = new Tone.Signal(this._compressor.release, Tone.Type.Time);
		        /**
				 *  The knee parameter
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.knee = this._compressor.knee;
		        /**
				 *  The ratio value
				 *  @type {Number}
				 *  @signal
				 */
		        this.ratio = this._compressor.ratio;
		        //set the defaults
		        this._readOnly([
		            'knee',
		            'release',
		            'attack',
		            'ratio',
		            'threshold'
		        ]);
		        this.set(options);
		    };
		    Tone.extend(Tone.Compressor);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Compressor.defaults = {
		        'ratio': 12,
		        'threshold': -24,
		        'release': 0.25,
		        'attack': 0.003,
		        'knee': 30
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Compressor} this
			 */
		    Tone.Compressor.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'knee',
		            'release',
		            'attack',
		            'ratio',
		            'threshold'
		        ]);
		        this._compressor.disconnect();
		        this._compressor = null;
		        this.attack.dispose();
		        this.attack = null;
		        this.release.dispose();
		        this.release = null;
		        this.threshold = null;
		        this.ratio = null;
		        this.knee = null;
		        return this;
		    };
		    return Tone.Compressor;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Add a signal and a number or two signals. When no value is
			 *         passed into the constructor, Tone.Add will sum <code>input[0]</code>
			 *         and <code>input[1]</code>. If a value is passed into the constructor, 
			 *         the it will be added to the input.
			 *  
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number=} value If no value is provided, Tone.Add will sum the first
			 *                         and second inputs. 
			 *  @example
			 * var signal = new Tone.Signal(2);
			 * var add = new Tone.Add(2);
			 * signal.connect(add);
			 * //the output of add equals 4
			 *  @example
			 * //if constructed with no arguments
			 * //it will add the first and second inputs
			 * var add = new Tone.Add();
			 * var sig0 = new Tone.Signal(3).connect(add, 0, 0);
			 * var sig1 = new Tone.Signal(4).connect(add, 0, 1);
			 * //the output of add equals 7. 
			 */
		    Tone.Add = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  the summing node
				 *  @type {GainNode}
				 *  @private
				 */
		        this._sum = this.input[0] = this.input[1] = this.output = this.context.createGain();
		        /**
				 *  @private
				 *  @type {Tone.Signal}
				 */
		        this._value = this.input[1] = new Tone.Signal(value);
		        this._value.connect(this._sum);
		    };
		    Tone.extend(Tone.Add, Tone.Signal);
		    /**
			 *  Clean up.
			 *  @returns {Tone.Add} this
			 */
		    Tone.Add.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._sum.disconnect();
		        this._sum = null;
		        this._value.dispose();
		        this._value = null;
		        return this;
		    };
		    return Tone.Add;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Multiply two incoming signals. Or, if a number is given in the constructor, 
			 *          multiplies the incoming signal by that value. 
			 *
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number=} value Constant value to multiple. If no value is provided,
			 *                         it will return the product of the first and second inputs
			 *  @example
			 * var mult = new Tone.Multiply();
			 * var sigA = new Tone.Signal(3);
			 * var sigB = new Tone.Signal(4);
			 * sigA.connect(mult, 0, 0);
			 * sigB.connect(mult, 0, 1);
			 * //output of mult is 12.
			 *  @example
			 * var mult = new Tone.Multiply(10);
			 * var sig = new Tone.Signal(2).connect(mult);
			 * //the output of mult is 20. 
			 */
		    Tone.Multiply = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  the input node is the same as the output node
				 *  it is also the GainNode which handles the scaling of incoming signal
				 *  
				 *  @type {GainNode}
				 *  @private
				 */
		        this._mult = this.input[0] = this.output = this.context.createGain();
		        /**
				 *  the scaling parameter
				 *  @type {AudioParam}
				 *  @private
				 */
		        this._value = this.input[1] = this.output.gain;
		        this._value.value = this.defaultArg(value, 0);
		    };
		    Tone.extend(Tone.Multiply, Tone.Signal);
		    /**
			 *  clean up
			 *  @returns {Tone.Multiply} this
			 */
		    Tone.Multiply.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._mult.disconnect();
		        this._mult = null;
		        this._value = null;
		        return this;
		    };
		    return Tone.Multiply;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Negate the incoming signal. i.e. an input signal of 10 will output -10
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var neg = new Tone.Negate();
			 * var sig = new Tone.Signal(-2).connect(neg);
			 * //output of neg is positive 2. 
			 */
		    Tone.Negate = function () {
		        /**
				 *  negation is done by multiplying by -1
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._multiply = this.input = this.output = new Tone.Multiply(-1);
		    };
		    Tone.extend(Tone.Negate, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.Negate} this
			 */
		    Tone.Negate.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._multiply.dispose();
		        this._multiply = null;
		        return this;
		    };
		    return Tone.Negate;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Subtract the signal connected to <code>input[1]</code> from the signal connected 
			 *         to <code>input[0]</code>. If an argument is provided in the constructor, the 
			 *         signals <code>.value</code> will be subtracted from the incoming signal.
			 *
			 *  @extends {Tone.Signal}
			 *  @constructor
			 *  @param {number=} value The value to subtract from the incoming signal. If the value
			 *                         is omitted, it will subtract the second signal from the first.
			 *  @example
			 * var sub = new Tone.Subtract(1);
			 * var sig = new Tone.Signal(4).connect(sub);
			 * //the output of sub is 3. 
			 *  @example
			 * var sub = new Tone.Subtract();
			 * var sigA = new Tone.Signal(10);
			 * var sigB = new Tone.Signal(2.5);
			 * sigA.connect(sub, 0, 0);
			 * sigB.connect(sub, 0, 1);
			 * //output of sub is 7.5
			 */
		    Tone.Subtract = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  the summing node
				 *  @type {GainNode}
				 *  @private
				 */
		        this._sum = this.input[0] = this.output = this.context.createGain();
		        /**
				 *  negate the input of the second input before connecting it
				 *  to the summing node.
				 *  @type {Tone.Negate}
				 *  @private
				 */
		        this._neg = new Tone.Negate();
		        /**
				 *  the node where the value is set
				 *  @private
				 *  @type {Tone.Signal}
				 */
		        this._value = this.input[1] = new Tone.Signal(value);
		        this._value.chain(this._neg, this._sum);
		    };
		    Tone.extend(Tone.Subtract, Tone.Signal);
		    /**
			 *  Clean up.
			 *  @returns {Tone.SignalBase} this
			 */
		    Tone.Subtract.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._neg.dispose();
		        this._neg = null;
		        this._sum.disconnect();
		        this._sum = null;
		        this._value.dispose();
		        this._value = null;
		        return this;
		    };
		    return Tone.Subtract;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  GreaterThanZero outputs 1 when the input is strictly greater than zero
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var gt0 = new Tone.GreaterThanZero();
			 * var sig = new Tone.Signal(0.01).connect(gt0);
			 * //the output of gt0 is 1. 
			 * sig.value = 0;
			 * //the output of gt0 is 0. 
			 */
		    Tone.GreaterThanZero = function () {
		        /**
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._thresh = this.output = new Tone.WaveShaper(function (val) {
		            if (val <= 0) {
		                return 0;
		            } else {
		                return 1;
		            }
		        });
		        /**
				 *  scale the first thresholded signal by a large value.
				 *  this will help with values which are very close to 0
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = this.input = new Tone.Multiply(10000);
		        //connections
		        this._scale.connect(this._thresh);
		    };
		    Tone.extend(Tone.GreaterThanZero, Tone.SignalBase);
		    /**
			 *  dispose method
			 *  @returns {Tone.GreaterThanZero} this
			 */
		    Tone.GreaterThanZero.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._scale.dispose();
		        this._scale = null;
		        this._thresh.dispose();
		        this._thresh = null;
		        return this;
		    };
		    return Tone.GreaterThanZero;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  EqualZero outputs 1 when the input is equal to 
			 *          0 and outputs 0 otherwise. 
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var eq0 = new Tone.EqualZero();
			 * var sig = new Tone.Signal(0).connect(eq0);
			 * //the output of eq0 is 1. 
			 */
		    Tone.EqualZero = function () {
		        /**
				 *  scale the incoming signal by a large factor
				 *  @private
				 *  @type {Tone.Multiply}
				 */
		        this._scale = this.input = new Tone.Multiply(10000);
		        /**
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._thresh = new Tone.WaveShaper(function (val) {
		            if (val === 0) {
		                return 1;
		            } else {
		                return 0;
		            }
		        }, 128);
		        /**
				 *  threshold the output so that it's 0 or 1
				 *  @type {Tone.GreaterThanZero}
				 *  @private
				 */
		        this._gtz = this.output = new Tone.GreaterThanZero();
		        //connections
		        this._scale.chain(this._thresh, this._gtz);
		    };
		    Tone.extend(Tone.EqualZero, Tone.SignalBase);
		    /**
			 *  Clean up.
			 *  @returns {Tone.EqualZero} this
			 */
		    Tone.EqualZero.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._gtz.dispose();
		        this._gtz = null;
		        this._scale.dispose();
		        this._scale = null;
		        this._thresh.dispose();
		        this._thresh = null;
		        return this;
		    };
		    return Tone.EqualZero;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Output 1 if the signal is equal to the value, otherwise outputs 0. 
			 *          Can accept two signals if connected to inputs 0 and 1.
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number=} value The number to compare the incoming signal to
			 *  @example
			 * var eq = new Tone.Equal(3);
			 * var sig = new Tone.Signal(3).connect(eq);
			 * //the output of eq is 1. 
			 */
		    Tone.Equal = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  subtract the value from the incoming signal
				 *  
				 *  @type {Tone.Add}
				 *  @private
				 */
		        this._sub = this.input[0] = new Tone.Subtract(value);
		        /**
				 *  @type {Tone.EqualZero}
				 *  @private
				 */
		        this._equals = this.output = new Tone.EqualZero();
		        this._sub.connect(this._equals);
		        this.input[1] = this._sub.input[1];
		    };
		    Tone.extend(Tone.Equal, Tone.SignalBase);
		    /**
			 * The value to compare to the incoming signal.
			 * @memberOf Tone.Equal#
			 * @type {number}
			 * @name value
			 */
		    Object.defineProperty(Tone.Equal.prototype, 'value', {
		        get: function () {
		            return this._sub.value;
		        },
		        set: function (value) {
		            this._sub.value = value;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.Equal} this
			 */
		    Tone.Equal.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._equals.dispose();
		        this._equals = null;
		        this._sub.dispose();
		        this._sub = null;
		        return this;
		    };
		    return Tone.Equal;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Select between any number of inputs, sending the one 
			 *         selected by the gate signal to the output
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} [sourceCount=2] the number of inputs the switch accepts
			 *  @example
			 * var sel = new Tone.Select(2);
			 * var sigA = new Tone.Signal(10).connect(sel, 0, 0);
			 * var sigB = new Tone.Signal(20).connect(sel, 0, 1);
			 * sel.gate.value = 0;
			 * //sel outputs 10 (the value of sigA);
			 * sel.gate.value = 1;
			 * //sel outputs 20 (the value of sigB);
			 */
		    Tone.Select = function (sourceCount) {
		        sourceCount = this.defaultArg(sourceCount, 2);
		        Tone.call(this, sourceCount, 1);
		        /**
				 *  the control signal
				 *  @type {Number}
				 *  @signal
				 */
		        this.gate = new Tone.Signal(0);
		        this._readOnly('gate');
		        //make all the inputs and connect them
		        for (var i = 0; i < sourceCount; i++) {
		            var switchGate = new SelectGate(i);
		            this.input[i] = switchGate;
		            this.gate.connect(switchGate.selecter);
		            switchGate.connect(this.output);
		        }
		    };
		    Tone.extend(Tone.Select, Tone.SignalBase);
		    /**
			 *  Open a specific input and close the others.
			 *  @param {number} which The gate to open. 
			 *  @param {Time} [time=now] The time when the switch will open
			 *  @returns {Tone.Select} this
			 *  @example
			 * //open input 1 in a half second from now
			 * sel.select(1, "+0.5");
			 */
		    Tone.Select.prototype.select = function (which, time) {
		        //make sure it's an integer
		        which = Math.floor(which);
		        this.gate.setValueAtTime(which, this.toSeconds(time));
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Select} this
			 */
		    Tone.Select.prototype.dispose = function () {
		        this._writable('gate');
		        this.gate.dispose();
		        this.gate = null;
		        for (var i = 0; i < this.input.length; i++) {
		            this.input[i].dispose();
		            this.input[i] = null;
		        }
		        Tone.prototype.dispose.call(this);
		        return this;
		    };
		    ////////////START HELPER////////////
		    /**
			 *  helper class for Tone.Select representing a single gate
			 *  @constructor
			 *  @extends {Tone}
			 *  @private
			 */
		    var SelectGate = function (num) {
		        /**
				 *  the selector
				 *  @type {Tone.Equal}
				 */
		        this.selecter = new Tone.Equal(num);
		        /**
				 *  the gate
				 *  @type {GainNode}
				 */
		        this.gate = this.input = this.output = this.context.createGain();
		        //connect the selecter to the gate gain
		        this.selecter.connect(this.gate.gain);
		    };
		    Tone.extend(SelectGate);
		    /**
			 *  clean up
			 *  @private
			 */
		    SelectGate.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.selecter.dispose();
		        this.gate.disconnect();
		        this.selecter = null;
		        this.gate = null;
		    };
		    ////////////END HELPER////////////
		    //return Tone.Select
		    return Tone.Select;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class IfThenElse has three inputs. When the first input (if) is true (i.e. === 1), 
			 *         then it will pass the second input (then) through to the output, otherwise, 
			 *         if it's not true (i.e. === 0) then it will pass the third input (else) 
			 *         through to the output. 
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @example
			 * var ifThenElse = new Tone.IfThenElse();
			 * var ifSignal = new Tone.Signal(1).connect(ifThenElse.if);
			 * var pwmOsc = new Tone.PWMOscillator().connect(ifThenElse.then);
			 * var pulseOsc = new Tone.PulseOscillator().connect(ifThenElse.else);
			 * //ifThenElse outputs pwmOsc
			 * signal.value = 0;
			 * //now ifThenElse outputs pulseOsc
			 */
		    Tone.IfThenElse = function () {
		        Tone.call(this, 3, 0);
		        /**
				 *  the selector node which is responsible for the routing
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._selector = this.output = new Tone.Select(2);
		        //the input mapping
		        this.if = this.input[0] = this._selector.gate;
		        this.then = this.input[1] = this._selector.input[1];
		        this.else = this.input[2] = this._selector.input[0];
		    };
		    Tone.extend(Tone.IfThenElse, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.IfThenElse} this
			 */
		    Tone.IfThenElse.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._selector.dispose();
		        this._selector = null;
		        this.if = null;
		        this.then = null;
		        this.else = null;
		        return this;
		    };
		    return Tone.IfThenElse;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class [OR](https://en.wikipedia.org/wiki/OR_gate)
			 *         the inputs together. True if at least one of the inputs is true. 
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {number} [inputCount=2] the input count
			 *  @example
			 * var or = new Tone.OR(2);
			 * var sigA = new Tone.Signal(0)connect(or, 0, 0);
			 * var sigB = new Tone.Signal(1)connect(or, 0, 1);
			 * //output of or is 1 because at least
			 * //one of the inputs is equal to 1. 
			 */
		    Tone.OR = function (inputCount) {
		        inputCount = this.defaultArg(inputCount, 2);
		        Tone.call(this, inputCount, 0);
		        /**
				 *  a private summing node
				 *  @type {GainNode}
				 *  @private
				 */
		        this._sum = this.context.createGain();
		        /**
				 *  @type {Tone.Equal}
				 *  @private
				 */
		        this._gtz = this.output = new Tone.GreaterThanZero();
		        //make each of the inputs an alias
		        for (var i = 0; i < inputCount; i++) {
		            this.input[i] = this._sum;
		        }
		        this._sum.connect(this._gtz);
		    };
		    Tone.extend(Tone.OR, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.OR} this
			 */
		    Tone.OR.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._gtz.dispose();
		        this._gtz = null;
		        this._sum.disconnect();
		        this._sum = null;
		        return this;
		    };
		    return Tone.OR;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class [AND](https://en.wikipedia.org/wiki/Logical_conjunction)
			 *         returns 1 when all the inputs are equal to 1 and returns 0 otherwise.
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {number} [inputCount=2] the number of inputs. NOTE: all inputs are
			 *                                 connected to the single AND input node
			 *  @example
			 * var and = new Tone.AND(2);
			 * var sigA = new Tone.Signal(0).connect(and, 0, 0);
			 * var sigB = new Tone.Signal(1).connect(and, 0, 1);
			 * //the output of and is 0. 
			 */
		    Tone.AND = function (inputCount) {
		        inputCount = this.defaultArg(inputCount, 2);
		        Tone.call(this, inputCount, 0);
		        /**
				 *  @type {Tone.Equal}
				 *  @private
				 */
		        this._equals = this.output = new Tone.Equal(inputCount);
		        //make each of the inputs an alias
		        for (var i = 0; i < inputCount; i++) {
		            this.input[i] = this._equals;
		        }
		    };
		    Tone.extend(Tone.AND, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.AND} this
			 */
		    Tone.AND.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._equals.dispose();
		        this._equals = null;
		        return this;
		    };
		    return Tone.AND;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Just an alias for Tone.EqualZero, but has the same effect as a NOT operator. 
			 *          Outputs 1 when input equals 0. 
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var not = new Tone.NOT();
			 * var sig = new Tone.Signal(1).connect(not);
			 * //output of not equals 0. 
			 * sig.value = 0;
			 * //output of not equals 1.
			 */
		    Tone.NOT = Tone.EqualZero;
		    return Tone.NOT;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Output 1 if the signal is greater than the value, otherwise outputs 0.
			 *          can compare two signals or a signal and a number. 
			 *  
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number} [value=0] the value to compare to the incoming signal
			 *  @example
			 * var gt = new Tone.GreaterThan(2);
			 * var sig = new Tone.Signal(4).connect(gt);
			 * //output of gt is equal 1. 
			 */
		    Tone.GreaterThan = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  subtract the amount from the incoming signal
				 *  @type {Tone.Subtract}
				 *  @private
				 */
		        this._value = this.input[0] = new Tone.Subtract(value);
		        this.input[1] = this._value.input[1];
		        /**
				 *  compare that amount to zero
				 *  @type {Tone.GreaterThanZero}
				 *  @private
				 */
		        this._gtz = this.output = new Tone.GreaterThanZero();
		        //connect
		        this._value.connect(this._gtz);
		    };
		    Tone.extend(Tone.GreaterThan, Tone.Signal);
		    /**
			 *  dispose method
			 *  @returns {Tone.GreaterThan} this
			 */
		    Tone.GreaterThan.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._value.dispose();
		        this._value = null;
		        this._gtz.dispose();
		        this._gtz = null;
		        return this;
		    };
		    return Tone.GreaterThan;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Output 1 if the signal is less than the value, otherwise outputs 0.
			 *          Can compare two signals or a signal and a number. 
			 *  
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number=} value The value to compare to the incoming signal. 
			 *                            If no value is provided, it will compare 
			 *                            <code>input[0]</code> and <code>input[1]</code>
			 *  @example
			 * var lt = new Tone.LessThan(2);
			 * var sig = new Tone.Signal(-1).connect(lt);
			 * //if (sig < 2) lt outputs 1
			 */
		    Tone.LessThan = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  negate the incoming signal
				 *  @type {Tone.Negate}
				 *  @private
				 */
		        this._neg = this.input[0] = new Tone.Negate();
		        /**
				 *  input < value === -input > -value
				 *  @type {Tone.GreaterThan}
				 *  @private
				 */
		        this._gt = this.output = new Tone.GreaterThan();
		        /**
				 *  negate the signal coming from the second input
				 *  @private
				 *  @type {Tone.Negate}
				 */
		        this._rhNeg = new Tone.Negate();
		        /**
				 *  the node where the value is set
				 *  @private
				 *  @type {Tone.Signal}
				 */
		        this._value = this.input[1] = new Tone.Signal(value);
		        //connect
		        this._neg.connect(this._gt);
		        this._value.connect(this._rhNeg);
		        this._rhNeg.connect(this._gt, 0, 1);
		    };
		    Tone.extend(Tone.LessThan, Tone.Signal);
		    /**
			 *  Clean up.
			 *  @returns {Tone.LessThan} this
			 */
		    Tone.LessThan.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._neg.dispose();
		        this._neg = null;
		        this._gt.dispose();
		        this._gt = null;
		        this._rhNeg.dispose();
		        this._rhNeg = null;
		        this._value.dispose();
		        this._value = null;
		        return this;
		    };
		    return Tone.LessThan;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Return the absolute value of an incoming signal. 
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var signal = new Tone.Signal(-1);
			 * var abs = new Tone.Abs();
			 * signal.connect(abs);
			 * //the output of abs is 1. 
			 */
		    Tone.Abs = function () {
		        Tone.call(this, 1, 0);
		        /**
				 *  @type {Tone.LessThan}
				 *  @private
				 */
		        this._ltz = new Tone.LessThan(0);
		        /**
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._switch = this.output = new Tone.Select(2);
		        /**
				 *  @type {Tone.Negate}
				 *  @private
				 */
		        this._negate = new Tone.Negate();
		        //two signal paths, positive and negative
		        this.input.connect(this._switch, 0, 0);
		        this.input.connect(this._negate);
		        this._negate.connect(this._switch, 0, 1);
		        //the control signal
		        this.input.chain(this._ltz, this._switch.gate);
		    };
		    Tone.extend(Tone.Abs, Tone.SignalBase);
		    /**
			 *  dispose method
			 *  @returns {Tone.Abs} this
			 */
		    Tone.Abs.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._switch.dispose();
		        this._switch = null;
		        this._ltz.dispose();
		        this._ltz = null;
		        this._negate.dispose();
		        this._negate = null;
		        return this;
		    };
		    return Tone.Abs;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Outputs the greater of two signals. If a number is provided in the constructor
			 * 	        it will use that instead of the signal. 
			 * 	
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number=} max Max value if provided. if not provided, it will use the
			 *                       signal value from input 1. 
			 *  @example
			 * var max = new Tone.Max(2);
			 * var sig = new Tone.Signal(3).connect(max);
			 * //max outputs 3
			 * sig.value = 1;
			 * //max outputs 2
			 *  @example
			 * var max = new Tone.Max();
			 * var sigA = new Tone.Signal(3);
			 * var sigB = new Tone.Signal(4);
			 * sigA.connect(max, 0, 0);
			 * sigB.connect(max, 0, 1);
			 * //output of max is 4.
			 */
		    Tone.Max = function (max) {
		        Tone.call(this, 2, 0);
		        this.input[0] = this.context.createGain();
		        /**
				 *  the max signal
				 *  @type {Tone.Signal}
				 *  @private
				 */
		        this._value = this.input[1] = new Tone.Signal(max);
		        /**
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._ifThenElse = this.output = new Tone.IfThenElse();
		        /**
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._gt = new Tone.GreaterThan();
		        //connections
		        this.input[0].chain(this._gt, this._ifThenElse.if);
		        this.input[0].connect(this._ifThenElse.then);
		        this._value.connect(this._ifThenElse.else);
		        this._value.connect(this._gt, 0, 1);
		    };
		    Tone.extend(Tone.Max, Tone.Signal);
		    /**
			 * 	Clean up.
			 *  @returns {Tone.Max} this
			 */
		    Tone.Max.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._value.dispose();
		        this._ifThenElse.dispose();
		        this._gt.dispose();
		        this._value = null;
		        this._ifThenElse = null;
		        this._gt = null;
		        return this;
		    };
		    return Tone.Max;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Outputs the lesser of two signals. If a number is given 
			 * 	        in the constructor, it will use a signal and a number. 
			 * 	
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number} min The minimum to compare to the incoming signal
			 *  @example
			 * var min = new Tone.Min(2);
			 * var sig = new Tone.Signal(3).connect(min);
			 * //min outputs 2
			 * sig.value = 1;
			 * //min outputs 1
			 * 	 @example
			 * var min = new Tone.Min();
			 * var sigA = new Tone.Signal(3);
			 * var sigB = new Tone.Signal(4);
			 * sigA.connect(min, 0, 0);
			 * sigB.connect(min, 0, 1);
			 * //output of min is 3.
			 */
		    Tone.Min = function (min) {
		        Tone.call(this, 2, 0);
		        this.input[0] = this.context.createGain();
		        /**
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._ifThenElse = this.output = new Tone.IfThenElse();
		        /**
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._lt = new Tone.LessThan();
		        /**
				 *  the min signal
				 *  @type {Tone.Signal}
				 *  @private
				 */
		        this._value = this.input[1] = new Tone.Signal(min);
		        //connections
		        this.input[0].chain(this._lt, this._ifThenElse.if);
		        this.input[0].connect(this._ifThenElse.then);
		        this._value.connect(this._ifThenElse.else);
		        this._value.connect(this._lt, 0, 1);
		    };
		    Tone.extend(Tone.Min, Tone.Signal);
		    /**
			 *  clean up
			 *  @returns {Tone.Min} this
			 */
		    Tone.Min.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._value.dispose();
		        this._ifThenElse.dispose();
		        this._lt.dispose();
		        this._value = null;
		        this._ifThenElse = null;
		        this._lt = null;
		        return this;
		    };
		    return Tone.Min;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Signal-rate modulo operator. Only works in AudioRange [-1, 1] and for modulus
			 *         values in the NormalRange. 
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {NormalRange} modulus The modulus to apply.
			 *  @example
			 * var mod = new Tone.Modulo(0.2)
			 * var sig = new Tone.Signal(0.5).connect(mod);
			 * //mod outputs 0.1
			 */
		    Tone.Modulo = function (modulus) {
		        Tone.call(this, 1, 1);
		        /**
				 *  A waveshaper gets the integer multiple of 
				 *  the input signal and the modulus.
				 *  @private
				 *  @type {Tone.WaveShaper}
				 */
		        this._shaper = new Tone.WaveShaper(Math.pow(2, 16));
		        /**
				 *  the integer multiple is multiplied by the modulus
				 *  @type  {Tone.Multiply}
				 *  @private
				 */
		        this._multiply = new Tone.Multiply();
		        /**
				 *  and subtracted from the input signal
				 *  @type  {Tone.Subtract}
				 *  @private
				 */
		        this._subtract = this.output = new Tone.Subtract();
		        /**
				 *  the modulus signal
				 *  @type  {Tone.Signal}
				 *  @private
				 */
		        this._modSignal = new Tone.Signal(modulus);
		        //connections
		        this.input.fan(this._shaper, this._subtract);
		        this._modSignal.connect(this._multiply, 0, 0);
		        this._shaper.connect(this._multiply, 0, 1);
		        this._multiply.connect(this._subtract, 0, 1);
		        this._setWaveShaper(modulus);
		    };
		    Tone.extend(Tone.Modulo, Tone.SignalBase);
		    /**
			 *  @param  {number}  mod  the modulus to apply
			 *  @private
			 */
		    Tone.Modulo.prototype._setWaveShaper = function (mod) {
		        this._shaper.setMap(function (val) {
		            var multiple = Math.floor((val + 0.0001) / mod);
		            return multiple;
		        });
		    };
		    /**
			 * The modulus value.
			 * @memberOf Tone.Modulo#
			 * @type {NormalRange}
			 * @name value
			 */
		    Object.defineProperty(Tone.Modulo.prototype, 'value', {
		        get: function () {
		            return this._modSignal.value;
		        },
		        set: function (mod) {
		            this._modSignal.value = mod;
		            this._setWaveShaper(mod);
		        }
		    });
		    /**
			 * clean up
			 *  @returns {Tone.Modulo} this
			 */
		    Tone.Modulo.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._shaper.dispose();
		        this._shaper = null;
		        this._multiply.dispose();
		        this._multiply = null;
		        this._subtract.dispose();
		        this._subtract = null;
		        this._modSignal.dispose();
		        this._modSignal = null;
		        return this;
		    };
		    return Tone.Modulo;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Evaluate an expression at audio rate. <br><br>
			 *         Parsing code modified from https://code.google.com/p/tapdigit/
			 *         Copyright 2011 2012 Ariya Hidayat, New BSD License
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {string} expr the expression to generate
			 *  @example
			 * //adds the signals from input[0] and input[1].
			 * var expr = new Tone.Expr("$0 + $1");
			 */
		    Tone.Expr = function () {
		        var expr = this._replacements(Array.prototype.slice.call(arguments));
		        var inputCount = this._parseInputs(expr);
		        /**
				 *  hold onto all of the nodes for disposal
				 *  @type {Array}
				 *  @private
				 */
		        this._nodes = [];
		        /**
				 *  The inputs. The length is determined by the expression. 
				 *  @type {Array}
				 */
		        this.input = new Array(inputCount);
		        //create a gain for each input
		        for (var i = 0; i < inputCount; i++) {
		            this.input[i] = this.context.createGain();
		        }
		        //parse the syntax tree
		        var tree = this._parseTree(expr);
		        //evaluate the results
		        var result;
		        try {
		            result = this._eval(tree);
		        } catch (e) {
		            this._disposeNodes();
		            throw new Error('Could evaluate expression: ' + expr);
		        }
		        /**
				 *  The output node is the result of the expression
				 *  @type {Tone}
				 */
		        this.output = result;
		    };
		    Tone.extend(Tone.Expr, Tone.SignalBase);
		    //some helpers to cut down the amount of code
		    function applyBinary(Constructor, args, self) {
		        var op = new Constructor();
		        self._eval(args[0]).connect(op, 0, 0);
		        self._eval(args[1]).connect(op, 0, 1);
		        return op;
		    }
		    function applyUnary(Constructor, args, self) {
		        var op = new Constructor();
		        self._eval(args[0]).connect(op, 0, 0);
		        return op;
		    }
		    function getNumber(arg) {
		        return arg ? parseFloat(arg) : undefined;
		    }
		    function literalNumber(arg) {
		        return arg && arg.args ? parseFloat(arg.args) : undefined;
		    }
		    /*
			 *  the Expressions that Tone.Expr can parse.
			 *
			 *  each expression belongs to a group and contains a regexp 
			 *  for selecting the operator as well as that operators method
			 *  
			 *  @type {Object}
			 *  @private
			 */
		    Tone.Expr._Expressions = {
		        //values
		        'value': {
		            'signal': {
		                regexp: /^\d+\.\d+|^\d+/,
		                method: function (arg) {
		                    var sig = new Tone.Signal(getNumber(arg));
		                    return sig;
		                }
		            },
		            'input': {
		                regexp: /^\$\d/,
		                method: function (arg, self) {
		                    return self.input[getNumber(arg.substr(1))];
		                }
		            }
		        },
		        //syntactic glue
		        'glue': {
		            '(': { regexp: /^\(/ },
		            ')': { regexp: /^\)/ },
		            ',': { regexp: /^,/ }
		        },
		        //functions
		        'func': {
		            'abs': {
		                regexp: /^abs/,
		                method: applyUnary.bind(this, Tone.Abs)
		            },
		            'min': {
		                regexp: /^min/,
		                method: applyBinary.bind(this, Tone.Min)
		            },
		            'max': {
		                regexp: /^max/,
		                method: applyBinary.bind(this, Tone.Max)
		            },
		            'if': {
		                regexp: /^if/,
		                method: function (args, self) {
		                    var op = new Tone.IfThenElse();
		                    self._eval(args[0]).connect(op.if);
		                    self._eval(args[1]).connect(op.then);
		                    self._eval(args[2]).connect(op.else);
		                    return op;
		                }
		            },
		            'gt0': {
		                regexp: /^gt0/,
		                method: applyUnary.bind(this, Tone.GreaterThanZero)
		            },
		            'eq0': {
		                regexp: /^eq0/,
		                method: applyUnary.bind(this, Tone.EqualZero)
		            },
		            'mod': {
		                regexp: /^mod/,
		                method: function (args, self) {
		                    var modulus = literalNumber(args[1]);
		                    var op = new Tone.Modulo(modulus);
		                    self._eval(args[0]).connect(op);
		                    return op;
		                }
		            },
		            'pow': {
		                regexp: /^pow/,
		                method: function (args, self) {
		                    var exp = literalNumber(args[1]);
		                    var op = new Tone.Pow(exp);
		                    self._eval(args[0]).connect(op);
		                    return op;
		                }
		            }
		        },
		        //binary expressions
		        'binary': {
		            '+': {
		                regexp: /^\+/,
		                precedence: 1,
		                method: applyBinary.bind(this, Tone.Add)
		            },
		            '-': {
		                regexp: /^\-/,
		                precedence: 1,
		                method: function (args, self) {
		                    //both unary and binary op
		                    if (args.length === 1) {
		                        return applyUnary(Tone.Negate, args, self);
		                    } else {
		                        return applyBinary(Tone.Subtract, args, self);
		                    }
		                }
		            },
		            '*': {
		                regexp: /^\*/,
		                precedence: 0,
		                method: applyBinary.bind(this, Tone.Multiply)
		            },
		            '>': {
		                regexp: /^\>/,
		                precedence: 2,
		                method: applyBinary.bind(this, Tone.GreaterThan)
		            },
		            '<': {
		                regexp: /^</,
		                precedence: 2,
		                method: applyBinary.bind(this, Tone.LessThan)
		            },
		            '==': {
		                regexp: /^==/,
		                precedence: 3,
		                method: applyBinary.bind(this, Tone.Equal)
		            },
		            '&&': {
		                regexp: /^&&/,
		                precedence: 4,
		                method: applyBinary.bind(this, Tone.AND)
		            },
		            '||': {
		                regexp: /^\|\|/,
		                precedence: 5,
		                method: applyBinary.bind(this, Tone.OR)
		            }
		        },
		        //unary expressions
		        'unary': {
		            '-': {
		                regexp: /^\-/,
		                method: applyUnary.bind(this, Tone.Negate)
		            },
		            '!': {
		                regexp: /^\!/,
		                method: applyUnary.bind(this, Tone.NOT)
		            }
		        }
		    };
		    /**
			 *  @param   {string} expr the expression string
			 *  @return  {number}      the input count
			 *  @private
			 */
		    Tone.Expr.prototype._parseInputs = function (expr) {
		        var inputArray = expr.match(/\$\d/g);
		        var inputMax = 0;
		        if (inputArray !== null) {
		            for (var i = 0; i < inputArray.length; i++) {
		                var inputNum = parseInt(inputArray[i].substr(1)) + 1;
		                inputMax = Math.max(inputMax, inputNum);
		            }
		        }
		        return inputMax;
		    };
		    /**
			 *  @param   {Array} args 	an array of arguments
			 *  @return  {string} the results of the replacements being replaced
			 *  @private
			 */
		    Tone.Expr.prototype._replacements = function (args) {
		        var expr = args.shift();
		        for (var i = 0; i < args.length; i++) {
		            expr = expr.replace(/\%/i, args[i]);
		        }
		        return expr;
		    };
		    /**
			 *  tokenize the expression based on the Expressions object
			 *  @param   {string} expr 
			 *  @return  {Object}      returns two methods on the tokenized list, next and peek
			 *  @private
			 */
		    Tone.Expr.prototype._tokenize = function (expr) {
		        var position = -1;
		        var tokens = [];
		        while (expr.length > 0) {
		            expr = expr.trim();
		            var token = getNextToken(expr);
		            tokens.push(token);
		            expr = expr.substr(token.value.length);
		        }
		        function getNextToken(expr) {
		            for (var type in Tone.Expr._Expressions) {
		                var group = Tone.Expr._Expressions[type];
		                for (var opName in group) {
		                    var op = group[opName];
		                    var reg = op.regexp;
		                    var match = expr.match(reg);
		                    if (match !== null) {
		                        return {
		                            type: type,
		                            value: match[0],
		                            method: op.method
		                        };
		                    }
		                }
		            }
		            throw new SyntaxError('Unexpected token ' + expr);
		        }
		        return {
		            next: function () {
		                return tokens[++position];
		            },
		            peek: function () {
		                return tokens[position + 1];
		            }
		        };
		    };
		    /**
			 *  recursively parse the string expression into a syntax tree
			 *  
			 *  @param   {string} expr 
			 *  @return  {Object}
			 *  @private
			 */
		    Tone.Expr.prototype._parseTree = function (expr) {
		        var lexer = this._tokenize(expr);
		        var isUndef = this.isUndef.bind(this);
		        function matchSyntax(token, syn) {
		            return !isUndef(token) && token.type === 'glue' && token.value === syn;
		        }
		        function matchGroup(token, groupName, prec) {
		            var ret = false;
		            var group = Tone.Expr._Expressions[groupName];
		            if (!isUndef(token)) {
		                for (var opName in group) {
		                    var op = group[opName];
		                    if (op.regexp.test(token.value)) {
		                        if (!isUndef(prec)) {
		                            if (op.precedence === prec) {
		                                return true;
		                            }
		                        } else {
		                            return true;
		                        }
		                    }
		                }
		            }
		            return ret;
		        }
		        function parseExpression(precedence) {
		            if (isUndef(precedence)) {
		                precedence = 5;
		            }
		            var expr;
		            if (precedence < 0) {
		                expr = parseUnary();
		            } else {
		                expr = parseExpression(precedence - 1);
		            }
		            var token = lexer.peek();
		            while (matchGroup(token, 'binary', precedence)) {
		                token = lexer.next();
		                expr = {
		                    operator: token.value,
		                    method: token.method,
		                    args: [
		                        expr,
		                        parseExpression(precedence)
		                    ]
		                };
		                token = lexer.peek();
		            }
		            return expr;
		        }
		        function parseUnary() {
		            var token, expr;
		            token = lexer.peek();
		            if (matchGroup(token, 'unary')) {
		                token = lexer.next();
		                expr = parseUnary();
		                return {
		                    operator: token.value,
		                    method: token.method,
		                    args: [expr]
		                };
		            }
		            return parsePrimary();
		        }
		        function parsePrimary() {
		            var token, expr;
		            token = lexer.peek();
		            if (isUndef(token)) {
		                throw new SyntaxError('Unexpected termination of expression');
		            }
		            if (token.type === 'func') {
		                token = lexer.next();
		                return parseFunctionCall(token);
		            }
		            if (token.type === 'value') {
		                token = lexer.next();
		                return {
		                    method: token.method,
		                    args: token.value
		                };
		            }
		            if (matchSyntax(token, '(')) {
		                lexer.next();
		                expr = parseExpression();
		                token = lexer.next();
		                if (!matchSyntax(token, ')')) {
		                    throw new SyntaxError('Expected )');
		                }
		                return expr;
		            }
		            throw new SyntaxError('Parse error, cannot process token ' + token.value);
		        }
		        function parseFunctionCall(func) {
		            var token, args = [];
		            token = lexer.next();
		            if (!matchSyntax(token, '(')) {
		                throw new SyntaxError('Expected ( in a function call "' + func.value + '"');
		            }
		            token = lexer.peek();
		            if (!matchSyntax(token, ')')) {
		                args = parseArgumentList();
		            }
		            token = lexer.next();
		            if (!matchSyntax(token, ')')) {
		                throw new SyntaxError('Expected ) in a function call "' + func.value + '"');
		            }
		            return {
		                method: func.method,
		                args: args,
		                name: name
		            };
		        }
		        function parseArgumentList() {
		            var token, expr, args = [];
		            while (true) {
		                expr = parseExpression();
		                if (isUndef(expr)) {
		                    // TODO maybe throw exception?
		                    break;
		                }
		                args.push(expr);
		                token = lexer.peek();
		                if (!matchSyntax(token, ',')) {
		                    break;
		                }
		                lexer.next();
		            }
		            return args;
		        }
		        return parseExpression();
		    };
		    /**
			 *  recursively evaluate the expression tree
			 *  @param   {Object} tree 
			 *  @return  {AudioNode}      the resulting audio node from the expression
			 *  @private
			 */
		    Tone.Expr.prototype._eval = function (tree) {
		        if (!this.isUndef(tree)) {
		            var node = tree.method(tree.args, this);
		            this._nodes.push(node);
		            return node;
		        }
		    };
		    /**
			 *  dispose all the nodes
			 *  @private
			 */
		    Tone.Expr.prototype._disposeNodes = function () {
		        for (var i = 0; i < this._nodes.length; i++) {
		            var node = this._nodes[i];
		            if (this.isFunction(node.dispose)) {
		                node.dispose();
		            } else if (this.isFunction(node.disconnect)) {
		                node.disconnect();
		            }
		            node = null;
		            this._nodes[i] = null;
		        }
		        this._nodes = null;
		    };
		    /**
			 *  clean up
			 */
		    Tone.Expr.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._disposeNodes();
		    };
		    return Tone.Expr;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Convert an incoming signal between 0, 1 to an equal power gain scale.
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @example
			 * var eqPowGain = new Tone.EqualPowerGain();
			 */
		    Tone.EqualPowerGain = function () {
		        /**
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._eqPower = this.input = this.output = new Tone.WaveShaper(function (val) {
		            if (Math.abs(val) < 0.001) {
		                //should output 0 when input is 0
		                return 0;
		            } else {
		                return this.equalPowerScale(val);
		            }
		        }.bind(this), 4096);
		    };
		    Tone.extend(Tone.EqualPowerGain, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.EqualPowerGain} this
			 */
		    Tone.EqualPowerGain.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._eqPower.dispose();
		        this._eqPower = null;
		        return this;
		    };
		    return Tone.EqualPowerGain;
		});
		Module(function (Tone) {
		    
		    /**
			 * @class  Tone.Crossfade provides equal power fading between two inputs. 
			 *         More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).
			 *
			 * @constructor
			 * @extends {Tone}
			 * @param {NormalRange} [initialFade=0.5]
			 * @example
			 * var crossFade = new Tone.CrossFade(0.5);
			 * //connect effect A to crossfade from
			 * //effect output 0 to crossfade input 0
			 * effectA.connect(crossFade, 0, 0);
			 * //connect effect B to crossfade from
			 * //effect output 0 to crossfade input 1
			 * effectB.connect(crossFade, 0, 1);
			 * crossFade.fade.value = 0;
			 * // ^ only effectA is output
			 * crossFade.fade.value = 1;
			 * // ^ only effectB is output
			 * crossFade.fade.value = 0.5;
			 * // ^ the two signals are mixed equally. 
			 */
		    Tone.CrossFade = function (initialFade) {
		        Tone.call(this, 2, 1);
		        /**
				 *  Alias for <code>input[0]</code>. 
				 *  @type {GainNode}
				 */
		        this.a = this.input[0] = this.context.createGain();
		        /**
				 *  Alias for <code>input[1]</code>. 
				 *  @type {GainNode}
				 */
		        this.b = this.input[1] = this.context.createGain();
		        /**
				 * 	The mix between the two inputs. A fade value of 0
				 * 	will output 100% <code>input[0]</code> and 
				 * 	a value of 1 will output 100% <code>input[1]</code>. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.fade = new Tone.Signal(this.defaultArg(initialFade, 0.5), Tone.Type.NormalRange);
		        /**
				 *  equal power gain cross fade
				 *  @private
				 *  @type {Tone.EqualPowerGain}
				 */
		        this._equalPowerA = new Tone.EqualPowerGain();
		        /**
				 *  equal power gain cross fade
				 *  @private
				 *  @type {Tone.EqualPowerGain}
				 */
		        this._equalPowerB = new Tone.EqualPowerGain();
		        /**
				 *  invert the incoming signal
				 *  @private
				 *  @type {Tone}
				 */
		        this._invert = new Tone.Expr('1 - $0');
		        //connections
		        this.a.connect(this.output);
		        this.b.connect(this.output);
		        this.fade.chain(this._equalPowerB, this.b.gain);
		        this.fade.chain(this._invert, this._equalPowerA, this.a.gain);
		        this._readOnly('fade');
		    };
		    Tone.extend(Tone.CrossFade);
		    /**
			 *  clean up
			 *  @returns {Tone.CrossFade} this
			 */
		    Tone.CrossFade.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('fade');
		        this._equalPowerA.dispose();
		        this._equalPowerA = null;
		        this._equalPowerB.dispose();
		        this._equalPowerB = null;
		        this.fade.dispose();
		        this.fade = null;
		        this._invert.dispose();
		        this._invert = null;
		        this.a.disconnect();
		        this.a = null;
		        this.b.disconnect();
		        this.b = null;
		        return this;
		    };
		    return Tone.CrossFade;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Filter is a filter which allows for all of the same native methods
			 *          as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface). 
			 *          Tone.Filter has the added ability to set the filter rolloff at -12 
			 *          (default), -24 and -48. 
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Frequency|Object} [frequency] The cutoff frequency of the filter.
			 *  @param {string=} type The type of filter.
			 *  @param {number=} rolloff The drop in decibels per octave after the cutoff frequency.
			 *                            3 choices: -12, -24, and -48
			 *  @example
			 *  var filter = new Tone.Filter(200, "highpass");
			 */
		    Tone.Filter = function () {
		        Tone.call(this);
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type',
		            'rolloff'
		        ], Tone.Filter.defaults);
		        /**
				 *  the filter(s)
				 *  @type {Array}
				 *  @private
				 */
		        this._filters = [];
		        /**
				 *  The cutoff frequency of the filter. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The detune parameter
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(0, Tone.Type.Cents);
		        /**
				 *  The gain of the filter, only used in certain filter types
				 *  @type {Gain}
				 *  @signal
				 */
		        this.gain = new Tone.Signal({
		            'value': options.gain,
		            'units': Tone.Type.Decibels,
		            'convert': false
		        });
		        /**
				 *  The Q or Quality of the filter
				 *  @type {Positive}
				 *  @signal
				 */
		        this.Q = new Tone.Signal(options.Q);
		        /**
				 *  the type of the filter
				 *  @type {string}
				 *  @private
				 */
		        this._type = options.type;
		        /**
				 *  the rolloff value of the filter
				 *  @type {number}
				 *  @private
				 */
		        this._rolloff = options.rolloff;
		        //set the rolloff;
		        this.rolloff = options.rolloff;
		        this._readOnly([
		            'detune',
		            'frequency',
		            'gain',
		            'Q'
		        ]);
		    };
		    Tone.extend(Tone.Filter);
		    /**
			 *  the default parameters
			 *
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Filter.defaults = {
		        'type': 'lowpass',
		        'frequency': 350,
		        'rolloff': -12,
		        'Q': 1,
		        'gain': 0
		    };
		    /**
			 * The type of the filter. Types: "lowpass", "highpass", 
			 * "bandpass", "lowshelf", "highshelf", "notch", "allpass", or "peaking". 
			 * @memberOf Tone.Filter#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.Filter.prototype, 'type', {
		        get: function () {
		            return this._type;
		        },
		        set: function (type) {
		            var types = [
		                'lowpass',
		                'highpass',
		                'bandpass',
		                'lowshelf',
		                'highshelf',
		                'notch',
		                'allpass',
		                'peaking'
		            ];
		            if (types.indexOf(type) === -1) {
		                throw new TypeError('Tone.Filter does not have filter type ' + type);
		            }
		            this._type = type;
		            for (var i = 0; i < this._filters.length; i++) {
		                this._filters[i].type = type;
		            }
		        }
		    });
		    /**
			 * The rolloff of the filter which is the drop in db
			 * per octave. Implemented internally by cascading filters.
			 * Only accepts the values -12, -24, and -48.
			 * @memberOf Tone.Filter#
			 * @type {number}
			 * @name rolloff
			 */
		    Object.defineProperty(Tone.Filter.prototype, 'rolloff', {
		        get: function () {
		            return this._rolloff;
		        },
		        set: function (rolloff) {
		            var possibilities = [
		                -12,
		                -24,
		                -48
		            ];
		            var cascadingCount = possibilities.indexOf(rolloff);
		            //check the rolloff is valid
		            if (cascadingCount === -1) {
		                throw new RangeError('Filter rolloff can only be -12, -24, or -48');
		            }
		            cascadingCount++;
		            this._rolloff = rolloff;
		            //first disconnect the filters and throw them away
		            this.input.disconnect();
		            for (var i = 0; i < this._filters.length; i++) {
		                this._filters[i].disconnect();
		                this._filters[i] = null;
		            }
		            this._filters = new Array(cascadingCount);
		            for (var count = 0; count < cascadingCount; count++) {
		                var filter = this.context.createBiquadFilter();
		                filter.type = this._type;
		                this.frequency.connect(filter.frequency);
		                this.detune.connect(filter.detune);
		                this.Q.connect(filter.Q);
		                this.gain.connect(filter.gain);
		                this._filters[count] = filter;
		            }
		            //connect them up
		            var connectionChain = [this.input].concat(this._filters).concat([this.output]);
		            this.connectSeries.apply(this, connectionChain);
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @return {Tone.Filter} this
			 */
		    Tone.Filter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        for (var i = 0; i < this._filters.length; i++) {
		            this._filters[i].disconnect();
		            this._filters[i] = null;
		        }
		        this._filters = null;
		        this._writable([
		            'detune',
		            'frequency',
		            'gain',
		            'Q'
		        ]);
		        this.frequency.dispose();
		        this.Q.dispose();
		        this.frequency = null;
		        this.Q = null;
		        this.detune.dispose();
		        this.detune = null;
		        this.gain.dispose();
		        this.gain = null;
		        return this;
		    };
		    return Tone.Filter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Split the incoming signal into three bands (low, mid, high)
			 *         with two crossover frequency controls. 
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Frequency|Object} [lowFrequency] the low/mid crossover frequency
			 *  @param {Frequency} [highFrequency] the mid/high crossover frequency
			 */
		    Tone.MultibandSplit = function () {
		        var options = this.optionsObject(arguments, [
		            'lowFrequency',
		            'highFrequency'
		        ], Tone.MultibandSplit.defaults);
		        /**
				 *  the input
				 *  @type {GainNode}
				 *  @private
				 */
		        this.input = this.context.createGain();
		        /**
				 *  the outputs
				 *  @type {Array}
				 *  @private
				 */
		        this.output = new Array(3);
		        /**
				 *  The low band. Alias for <code>output[0]</code>
				 *  @type {Tone.Filter}
				 */
		        this.low = this.output[0] = new Tone.Filter(0, 'lowpass');
		        /**
				 *  the lower filter of the mid band
				 *  @type {Tone.Filter}
				 *  @private
				 */
		        this._lowMidFilter = new Tone.Filter(0, 'highpass');
		        /**
				 *  The mid band output. Alias for <code>output[1]</code>
				 *  @type {Tone.Filter}
				 */
		        this.mid = this.output[1] = new Tone.Filter(0, 'lowpass');
		        /**
				 *  The high band output. Alias for <code>output[2]</code>
				 *  @type {Tone.Filter}
				 */
		        this.high = this.output[2] = new Tone.Filter(0, 'highpass');
		        /**
				 *  The low/mid crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.lowFrequency = new Tone.Signal(options.lowFrequency, Tone.Type.Frequency);
		        /**
				 *  The mid/high crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.highFrequency = new Tone.Signal(options.highFrequency, Tone.Type.Frequency);
		        /**
				 *  The quality of all the filters
				 *  @type {Number}
				 *  @signal
				 */
		        this.Q = new Tone.Signal(options.Q);
		        this.input.fan(this.low, this.high);
		        this.input.chain(this._lowMidFilter, this.mid);
		        //the frequency control signal
		        this.lowFrequency.connect(this.low.frequency);
		        this.lowFrequency.connect(this._lowMidFilter.frequency);
		        this.highFrequency.connect(this.mid.frequency);
		        this.highFrequency.connect(this.high.frequency);
		        //the Q value
		        this.Q.connect(this.low.Q);
		        this.Q.connect(this._lowMidFilter.Q);
		        this.Q.connect(this.mid.Q);
		        this.Q.connect(this.high.Q);
		        this._readOnly([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		    };
		    Tone.extend(Tone.MultibandSplit);
		    /**
			 *  @private
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MultibandSplit.defaults = {
		        'lowFrequency': 400,
		        'highFrequency': 2500,
		        'Q': 1
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.MultibandSplit} this
			 */
		    Tone.MultibandSplit.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		        this.low.dispose();
		        this.low = null;
		        this._lowMidFilter.dispose();
		        this._lowMidFilter = null;
		        this.mid.dispose();
		        this.mid = null;
		        this.high.dispose();
		        this.high = null;
		        this.lowFrequency.dispose();
		        this.lowFrequency = null;
		        this.highFrequency.dispose();
		        this.highFrequency = null;
		        this.Q.dispose();
		        this.Q = null;
		        return this;
		    };
		    return Tone.MultibandSplit;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.EQ3 is a three band EQ with control over low, mid, and high gain as
			 *         well as the low and high crossover frequencies.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  
			 *  @param {Decibels|Object} [lowLevel] The gain applied to the lows.
			 *  @param {Decibels} [midLevel] The gain applied to the mid.
			 *  @param {Decibels} [highLevel] The gain applied to the high.
			 *  @example
			 * var eq = new Tone.EQ3(-10, 3, -20);
			 */
		    Tone.EQ3 = function () {
		        var options = this.optionsObject(arguments, [
		            'low',
		            'mid',
		            'high'
		        ], Tone.EQ3.defaults);
		        /**
				 *  the output node
				 *  @type {GainNode}
				 *  @private
				 */
		        this.output = this.context.createGain();
		        /**
				 *  the multiband split
				 *  @type {Tone.MultibandSplit}
				 *  @private
				 */
		        this._multibandSplit = this.input = new Tone.MultibandSplit({
		            'lowFrequency': options.lowFrequency,
		            'highFrequency': options.highFrequency
		        });
		        /**
				 *  the low gain
				 *  @type {GainNode}
				 *  @private
				 */
		        this._lowGain = this.context.createGain();
		        /**
				 *  the mid gain
				 *  @type {GainNode}
				 *  @private
				 */
		        this._midGain = this.context.createGain();
		        /**
				 *  the high gain
				 *  @type {GainNode}
				 *  @private
				 */
		        this._highGain = this.context.createGain();
		        /**
				 * The gain in decibels of the low part
				 * @type {Decibels}
				 * @signal
				 */
		        this.low = new Tone.Signal(this._lowGain.gain, Tone.Type.Decibels);
		        /**
				 * The gain in decibels of the mid part
				 * @type {Decibels}
				 * @signal
				 */
		        this.mid = new Tone.Signal(this._midGain.gain, Tone.Type.Decibels);
		        /**
				 * The gain in decibels of the high part
				 * @type {Decibels}
				 * @signal
				 */
		        this.high = new Tone.Signal(this._highGain.gain, Tone.Type.Decibels);
		        /**
				 *  The Q value for all of the filters. 
				 *  @type {Positive}
				 *  @signal
				 */
		        this.Q = this._multibandSplit.Q;
		        /**
				 *  The low/mid crossover frequency. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.lowFrequency = this._multibandSplit.lowFrequency;
		        /**
				 *  The mid/high crossover frequency. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.highFrequency = this._multibandSplit.highFrequency;
		        //the frequency bands
		        this._multibandSplit.low.chain(this._lowGain, this.output);
		        this._multibandSplit.mid.chain(this._midGain, this.output);
		        this._multibandSplit.high.chain(this._highGain, this.output);
		        //set the gains
		        this.low.value = options.low;
		        this.mid.value = options.mid;
		        this.high.value = options.high;
		        this._readOnly([
		            'low',
		            'mid',
		            'high',
		            'lowFrequency',
		            'highFrequency'
		        ]);
		    };
		    Tone.extend(Tone.EQ3);
		    /**
			 *  the default values
			 */
		    Tone.EQ3.defaults = {
		        'low': 0,
		        'mid': 0,
		        'high': 0,
		        'lowFrequency': 400,
		        'highFrequency': 2500
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.EQ3} this
			 */
		    Tone.EQ3.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'low',
		            'mid',
		            'high',
		            'lowFrequency',
		            'highFrequency'
		        ]);
		        this._multibandSplit.dispose();
		        this._multibandSplit = null;
		        this.lowFrequency = null;
		        this.highFrequency = null;
		        this._lowGain.disconnect();
		        this._lowGain = null;
		        this._midGain.disconnect();
		        this._midGain = null;
		        this._highGain.disconnect();
		        this._highGain = null;
		        this.low.dispose();
		        this.low = null;
		        this.mid.dispose();
		        this.mid = null;
		        this.high.dispose();
		        this.high = null;
		        this.Q = null;
		        return this;
		    };
		    return Tone.EQ3;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Performs a linear scaling on an input signal.
			 *          Scales a NormalRange input to between
			 *          outputMin and outputMax.
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} [outputMin=0] The output value when the input is 0. 
			 *  @param {number} [outputMax=1]	The output value when the input is 1. 
			 *  @example
			 * var scale = new Tone.Scale(50, 100);
			 * var signal = new Tone.Signal(0.5).connect(scale);
			 * //the output of scale equals 75
			 */
		    Tone.Scale = function (outputMin, outputMax) {
		        /** 
				 *  @private
				 *  @type {number}
				 */
		        this._outputMin = this.defaultArg(outputMin, 0);
		        /** 
				 *  @private
				 *  @type {number}
				 */
		        this._outputMax = this.defaultArg(outputMax, 1);
		        /** 
				 *  @private
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = this.input = new Tone.Multiply(1);
		        /** 
				 *  @private
				 *  @type {Tone.Add}
				 *  @private
				 */
		        this._add = this.output = new Tone.Add(0);
		        this._scale.connect(this._add);
		        this._setRange();
		    };
		    Tone.extend(Tone.Scale, Tone.SignalBase);
		    /**
			 * The minimum output value. This number is output when 
			 * the value input value is 0. 
			 * @memberOf Tone.Scale#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.Scale.prototype, 'min', {
		        get: function () {
		            return this._outputMin;
		        },
		        set: function (min) {
		            this._outputMin = min;
		            this._setRange();
		        }
		    });
		    /**
			 * The maximum output value. This number is output when 
			 * the value input value is 1. 
			 * @memberOf Tone.Scale#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.Scale.prototype, 'max', {
		        get: function () {
		            return this._outputMax;
		        },
		        set: function (max) {
		            this._outputMax = max;
		            this._setRange();
		        }
		    });
		    /**
			 *  set the values
			 *  @private
			 */
		    Tone.Scale.prototype._setRange = function () {
		        this._add.value = this._outputMin;
		        this._scale.value = this._outputMax - this._outputMin;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Scale} this
			 */
		    Tone.Scale.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._add.dispose();
		        this._add = null;
		        this._scale.dispose();
		        this._scale = null;
		        return this;
		    };
		    return Tone.Scale;
		});
		Module(function (Tone) {
		    /**
			 *  @class  Performs an exponential scaling on an input signal.
			 *          Scales a NormalRange value [0,1] exponentially
			 *          to the output range of outputMin to outputMax.
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} [outputMin=0] The output value when the input is 0. 
			 *  @param {number} [outputMax=1]	The output value when the input is 1. 
			 *  @param {number} [exponent=2] The exponent which scales the incoming signal.
			 *  @example
			 * var scaleExp = new Tone.ScaleExp(0, 100, 2);
			 * var signal = new Tone.Signal(0.5).connect(scaleExp);
			 */
		    Tone.ScaleExp = function (outputMin, outputMax, exponent) {
		        /**
				 *  scale the input to the output range
				 *  @type {Tone.Scale}
				 *  @private
				 */
		        this._scale = this.output = new Tone.Scale(outputMin, outputMax);
		        /**
				 *  @private
				 *  @type {Tone.Pow}
				 *  @private
				 */
		        this._exp = this.input = new Tone.Pow(this.defaultArg(exponent, 2));
		        this._exp.connect(this._scale);
		    };
		    Tone.extend(Tone.ScaleExp, Tone.SignalBase);
		    /**
			 * Instead of interpolating linearly between the <code>min</code> and 
			 * <code>max</code> values, setting the exponent will interpolate between
			 * the two values with an exponential curve. 
			 * @memberOf Tone.ScaleExp#
			 * @type {number}
			 * @name exponent
			 */
		    Object.defineProperty(Tone.ScaleExp.prototype, 'exponent', {
		        get: function () {
		            return this._exp.value;
		        },
		        set: function (exp) {
		            this._exp.value = exp;
		        }
		    });
		    /**
			 * The minimum output value. This number is output when 
			 * the value input value is 0. 
			 * @memberOf Tone.ScaleExp#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.ScaleExp.prototype, 'min', {
		        get: function () {
		            return this._scale.min;
		        },
		        set: function (min) {
		            this._scale.min = min;
		        }
		    });
		    /**
			 * The maximum output value. This number is output when 
			 * the value input value is 1. 
			 * @memberOf Tone.ScaleExp#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.ScaleExp.prototype, 'max', {
		        get: function () {
		            return this._scale.max;
		        },
		        set: function (max) {
		            this._scale.max = max;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.ScaleExp} this
			 */
		    Tone.ScaleExp.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._scale.dispose();
		        this._scale = null;
		        this._exp.dispose();
		        this._exp = null;
		        return this;
		    };
		    return Tone.ScaleExp;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Comb filters are basic building blocks for physical modeling. Read more
			 *         about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Time|Object} [delayTime] The delay time of the filter. 
			 *  @param {NormalRange=} resonance The amount of feedback the filter has. 
			 */
		    Tone.FeedbackCombFilter = function () {
		        Tone.call(this);
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'resonance'
		        ], Tone.FeedbackCombFilter.defaults);
		        /**
				 *  The amount of feedback of the delayed signal. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.resonance = new Tone.Signal(options.resonance, Tone.Type.NormalRange);
		        /**
				 *  the delay node
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delay = this.input = this.output = this.context.createDelay(1);
		        /**
				 *  The amount of delay of the comb filter. 
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
		        /**
				 *  the feedback node
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedback = this.context.createGain();
		        this._delay.chain(this._feedback, this._delay);
		        this.resonance.connect(this._feedback.gain);
		        this.delayTime.connect(this._delay.delayTime);
		        this._readOnly([
		            'resonance',
		            'delayTime'
		        ]);
		    };
		    Tone.extend(Tone.FeedbackCombFilter);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.FeedbackCombFilter.defaults = {
		        'delayTime': 0.1,
		        'resonance': 0.5
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.FeedbackCombFilter} this
			 */
		    Tone.FeedbackCombFilter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'resonance',
		            'delayTime'
		        ]);
		        this._delay.disconnect();
		        this._delay = null;
		        this.delayTime.dispose();
		        this.delayTime = null;
		        this.resonance.dispose();
		        this.resonance = null;
		        this._feedback.disconnect();
		        this._feedback = null;
		        return this;
		    };
		    return Tone.FeedbackCombFilter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Follower is a  crude envelope follower which will follow 
			 *          the amplitude of an incoming signal. 
			 *          Take care with small (< 0.02) attack or decay values 
			 *          as follower has some ripple which is exaggerated
			 *          at these values. Read more about envelope followers (also known 
			 *          as envelope detectors) on [Wikipedia](https://en.wikipedia.org/wiki/Envelope_detector).
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Time|Object} [attack] The rate at which the follower rises.
			 *  @param {Time=} release The rate at which the folower falls. 
			 *  @example
			 * var follower = new Tone.Follower(0.2, 0.4);
			 */
		    Tone.Follower = function () {
		        Tone.call(this);
		        var options = this.optionsObject(arguments, [
		            'attack',
		            'release'
		        ], Tone.Follower.defaults);
		        /**
				 *  @type {Tone.Abs}
				 *  @private
				 */
		        this._abs = new Tone.Abs();
		        /**
				 *  the lowpass filter which smooths the input
				 *  @type {BiquadFilterNode}
				 *  @private
				 */
		        this._filter = this.context.createBiquadFilter();
		        this._filter.type = 'lowpass';
		        this._filter.frequency.value = 0;
		        this._filter.Q.value = -100;
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._frequencyValues = new Tone.WaveShaper();
		        /**
				 *  @type {Tone.Subtract}
				 *  @private
				 */
		        this._sub = new Tone.Subtract();
		        /**
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delay = this.context.createDelay();
		        this._delay.delayTime.value = this.bufferTime;
		        /**
				 *  this keeps it far from 0, even for very small differences
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._mult = new Tone.Multiply(10000);
		        /**
				 *  @private
				 *  @type {number}
				 */
		        this._attack = options.attack;
		        /**
				 *  @private
				 *  @type {number}
				 */
		        this._release = options.release;
		        //the smoothed signal to get the values
		        this.input.chain(this._abs, this._filter, this.output);
		        //the difference path
		        this._abs.connect(this._sub, 0, 1);
		        this._filter.chain(this._delay, this._sub);
		        //threshold the difference and use the thresh to set the frequency
		        this._sub.chain(this._mult, this._frequencyValues, this._filter.frequency);
		        //set the attack and release values in the table
		        this._setAttackRelease(this._attack, this._release);
		    };
		    Tone.extend(Tone.Follower);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Follower.defaults = {
		        'attack': 0.05,
		        'release': 0.5
		    };
		    /**
			 *  sets the attack and release times in the wave shaper
			 *  @param   {Time} attack  
			 *  @param   {Time} release 
			 *  @private
			 */
		    Tone.Follower.prototype._setAttackRelease = function (attack, release) {
		        var minTime = this.bufferTime;
		        attack = this.secondsToFrequency(this.toSeconds(attack));
		        release = this.secondsToFrequency(this.toSeconds(release));
		        attack = Math.max(attack, minTime);
		        release = Math.max(release, minTime);
		        this._frequencyValues.setMap(function (val) {
		            if (val <= 0) {
		                return attack;
		            } else {
		                return release;
		            }
		        });
		    };
		    /**
			 * The attack time.
			 * @memberOf Tone.Follower#
			 * @type {Time}
			 * @name attack
			 */
		    Object.defineProperty(Tone.Follower.prototype, 'attack', {
		        get: function () {
		            return this._attack;
		        },
		        set: function (attack) {
		            this._attack = attack;
		            this._setAttackRelease(this._attack, this._release);
		        }
		    });
		    /**
			 * The release time.
			 * @memberOf Tone.Follower#
			 * @type {Time}
			 * @name release
			 */
		    Object.defineProperty(Tone.Follower.prototype, 'release', {
		        get: function () {
		            return this._release;
		        },
		        set: function (release) {
		            this._release = release;
		            this._setAttackRelease(this._attack, this._release);
		        }
		    });
		    /**
			 *  Borrows the connect method from Signal so that the output can be used
			 *  as a Tone.Signal control signal.
			 *  @function
			 */
		    Tone.Follower.prototype.connect = Tone.Signal.prototype.connect;
		    /**
			 *  dispose
			 *  @returns {Tone.Follower} this
			 */
		    Tone.Follower.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._filter.disconnect();
		        this._filter = null;
		        this._frequencyValues.disconnect();
		        this._frequencyValues = null;
		        this._delay.disconnect();
		        this._delay = null;
		        this._sub.disconnect();
		        this._sub = null;
		        this._abs.dispose();
		        this._abs = null;
		        this._mult.dispose();
		        this._mult = null;
		        this._curve = null;
		        return this;
		    };
		    return Tone.Follower;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Gate only passes a signal through when the incoming 
			 *          signal exceeds a specified threshold. To do this, Gate uses 
			 *          a Tone.Follower to follow the amplitude of the incoming signal. 
			 *          A common implementation of this class is a [Noise Gate](https://en.wikipedia.org/wiki/Noise_gate).
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Decibels|Object} [threshold] The threshold above which the gate will open. 
			 *  @param {Time=} attack The follower's attack time
			 *  @param {Time=} release The follower's release time
			 *  @example
			 * var gate = new Tone.Gate(-30, 0.2, 0.3).toMaster();
			 * var mic = new Tone.Microphone().connect(gate);
			 * //the gate will only pass through the incoming 
			 * //signal when it's louder than -30db
			 */
		    Tone.Gate = function () {
		        Tone.call(this);
		        var options = this.optionsObject(arguments, [
		            'threshold',
		            'attack',
		            'release'
		        ], Tone.Gate.defaults);
		        /**
				 *  @type {Tone.Follower}
				 *  @private
				 */
		        this._follower = new Tone.Follower(options.attack, options.release);
		        /**
				 *  @type {Tone.GreaterThan}
				 *  @private
				 */
		        this._gt = new Tone.GreaterThan(this.dbToGain(options.threshold));
		        //the connections
		        this.input.connect(this.output);
		        //the control signal
		        this.input.chain(this._gt, this._follower, this.output.gain);
		    };
		    Tone.extend(Tone.Gate);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Gate.defaults = {
		        'attack': 0.1,
		        'release': 0.1,
		        'threshold': -40
		    };
		    /**
			 * The threshold of the gate in decibels
			 * @memberOf Tone.Gate#
			 * @type {Decibels}
			 * @name threshold
			 */
		    Object.defineProperty(Tone.Gate.prototype, 'threshold', {
		        get: function () {
		            return this.gainToDb(this._gt.value);
		        },
		        set: function (thresh) {
		            this._gt.value = this.dbToGain(thresh);
		        }
		    });
		    /**
			 * The attack speed of the gate
			 * @memberOf Tone.Gate#
			 * @type {Time}
			 * @name attack
			 */
		    Object.defineProperty(Tone.Gate.prototype, 'attack', {
		        get: function () {
		            return this._follower.attack;
		        },
		        set: function (attackTime) {
		            this._follower.attack = attackTime;
		        }
		    });
		    /**
			 * The release speed of the gate
			 * @memberOf Tone.Gate#
			 * @type {Time}
			 * @name release
			 */
		    Object.defineProperty(Tone.Gate.prototype, 'release', {
		        get: function () {
		            return this._follower.release;
		        },
		        set: function (releaseTime) {
		            this._follower.release = releaseTime;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Gate} this
			 */
		    Tone.Gate.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._follower.dispose();
		        this._gt.dispose();
		        this._follower = null;
		        this._gt = null;
		        return this;
		    };
		    return Tone.Gate;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A sample accurate clock which provides a callback at the given rate. 
			 *          While the callback is not sample-accurate (it is still susceptible to
			 *          loose JS timing), the time passed in as the argument to the callback
			 *          is precise. For most applications, it is better to use Tone.Transport
			 *          instead of the clock. 
			 *
			 * 	@constructor
			 * 	@extends {Tone}
			 * 	@param {Frequency} frequency The rate of the callback
			 * 	@param {function} callback The callback to be invoked with the time of the audio event
			 * 	@example
			 * //the callback will be invoked approximately once a second
			 * //and will print the time exactly once a second apart.
			 * var clock = new Tone.Clock(1, function(time){
			 * 	console.log(time);
			 * });
			 */
		    Tone.Clock = function (frequency, callback) {
		        /**
				 *  the oscillator
				 *  @type {OscillatorNode}
				 *  @private
				 */
		        this._oscillator = null;
		        /**
				 *  the script processor which listens to the oscillator
				 *  @type {ScriptProcessorNode}
				 *  @private
				 */
		        this._jsNode = this.context.createScriptProcessor(this.bufferSize, 1, 1);
		        this._jsNode.onaudioprocess = this._processBuffer.bind(this);
		        /**
				 *  The frequency in which the callback will be invoked.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(frequency, Tone.Type.Frequency);
		        /**
				 *  whether the tick is on the up or down
				 *  @type {boolean}
				 *  @private
				 */
		        this._upTick = false;
		        /**
				 *  The callback which is invoked on every tick
				 *  with the time of that tick as the argument
				 *  @type {function(number)}
				 */
		        this.tick = callback;
		        /**
				 * Callback is invoked when the clock is stopped.
				 * @type {function}
				 * @example
				 * clock.onended = function(){
				 * 	console.log("the clock is stopped");
				 * }
				 */
		        this.onended = Tone.noOp;
		        //setup
		        this._jsNode.noGC();
		    };
		    Tone.extend(Tone.Clock);
		    /**
			 *  Start the clock.
			 *  @param {Time} [time=now] the time when the clock should start
			 *  @returns {Tone.Clock} this
			 *  @example
			 * clock.start();
			 */
		    Tone.Clock.prototype.start = function (time) {
		        if (!this._oscillator) {
		            this._oscillator = this.context.createOscillator();
		            this._oscillator.type = 'square';
		            this._oscillator.connect(this._jsNode);
		            //connect it up
		            this.frequency.connect(this._oscillator.frequency);
		            this._upTick = false;
		            var startTime = this.toSeconds(time);
		            this._oscillator.start(startTime);
		        }
		        return this;
		    };
		    /**
			 *  Stop the clock.
			 *  @param {Time} [time=now] The time when the clock should stop.
			 *  @returns {Tone.Clock} this
			 *  @example
			 * clock.stop();
			 */
		    Tone.Clock.prototype.stop = function (time) {
		        if (this._oscillator) {
		            var now = this.now();
		            var stopTime = this.toSeconds(time, now);
		            this._oscillator.stop(stopTime);
		            this._oscillator = null;
		            if (time) {
		                //set a timeout for when it stops
		                setTimeout(this.onended, (stopTime - now) * 1000);
		            } else {
		                this.onended();
		            }
		        }
		        return this;
		    };
		    /**
			 *  @private
			 *  @param  {AudioProcessingEvent} event
			 */
		    Tone.Clock.prototype._processBuffer = function (event) {
		        var now = this.defaultArg(event.playbackTime, this.now());
		        var bufferSize = this._jsNode.bufferSize;
		        var incomingBuffer = event.inputBuffer.getChannelData(0);
		        var upTick = this._upTick;
		        var self = this;
		        for (var i = 0; i < bufferSize; i++) {
		            var sample = incomingBuffer[i];
		            if (sample > 0 && !upTick) {
		                upTick = true;
		                //get the callback out of audio thread
		                setTimeout(function () {
		                    //to account for the double buffering
		                    var tickTime = now + self.samplesToSeconds(i + bufferSize * 2);
		                    return function () {
		                        if (self.tick) {
		                            self.tick(tickTime);
		                        }
		                    };
		                }(), 0);    // jshint ignore:line
		            } else if (sample < 0 && upTick) {
		                upTick = false;
		            }
		        }
		        this._upTick = upTick;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Clock} this
			 */
		    Tone.Clock.prototype.dispose = function () {
		        this._jsNode.disconnect();
		        this.frequency.dispose();
		        this.frequency = null;
		        if (this._oscillator) {
		            this._oscillator.disconnect();
		            this._oscillator = null;
		        }
		        this._jsNode.onaudioprocess = Tone.noOp;
		        this._jsNode = null;
		        this.tick = null;
		        this.onended = Tone.noOp;
		        return this;
		    };
		    return Tone.Clock;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Oscillator-based transport allows for timing musical events.
			 *          Supports tempo curves and time changes. A single transport is created
			 *          on initialization. Unlike browser-based timing (setInterval, requestAnimationFrame)
			 *          Tone.Transport timing events pass in the exact time of the scheduled event
			 *          in the argument of the callback function. Pass that time value to the object
			 *          you're scheduling. <br><br>
			 *          A single transport is created for you when the library is initialized. 
			 *
			 *  @extends {Tone}
			 *  @singleton
			 *  @example
			 * //repeated event every 8th note
			 * Tone.Transport.setInterval(function(time){
			 * 	//do something with the time
			 * }, "8n");
			 *  @example
			 * //one time event 1 second in the future
			 * Tone.Transport.setTimeout(function(time){
			 * 	//do something with the time
			 * }, 1);
			 *  @example
			 * //event fixed to the Transports timeline. 
			 * Tone.Transport.setTimeline(function(time){
			 * 	//do something with the time
			 * }, "16:0:0");
			 */
		    Tone.Transport = function () {
		        /**
				 *  watches the main oscillator for timing ticks
				 *  initially starts at 120bpm
				 *  
				 *  @private
				 *  @type {Tone.Clock}
				 */
		        this._clock = new Tone.Clock(0, this._processTick.bind(this));
		        this._clock.onended = this._onended.bind(this);
		        /** 
				 * 	If the transport loops or not.
				 *  @type {boolean}
				 */
		        this.loop = false;
		        /**
				 *  The Beats Per Minute of the Transport. 
				 *  @type {BPM}
				 *  @signal
				 *  @example
				 * Tone.Transport.bpm.value = 80;
				 * //ramp the bpm to 120 over 10 seconds
				 * Tone.Transport.bpm.rampTo(120, 10);
				 */
		        this.bpm = new Tone.Signal(120, Tone.Type.BPM);
		        /**
				 *  the signal scalar
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._bpmMult = new Tone.Multiply(1 / 60 * tatum);
		        /**
				 * 	The state of the transport. READ ONLY. 
				 *  @type {Tone.State}
				 */
		        this.state = Tone.State.Stopped;
		        //connect it all up
		        this.bpm.chain(this._bpmMult, this._clock.frequency);
		    };
		    Tone.extend(Tone.Transport);
		    /**
			 *  the defaults
			 *  @type {Object}
			 *  @const
			 *  @static
			 */
		    Tone.Transport.defaults = {
		        'bpm': 120,
		        'swing': 0,
		        'swingSubdivision': '16n',
		        'timeSignature': 4,
		        'loopStart': 0,
		        'loopEnd': '4m'
		    };
		    /** 
			 * @private
			 * @type {number}
			 */
		    var tatum = 12;
		    /** 
			 * @private 
			 * @type {number} 
			 */
		    var timelineTicks = 0;
		    /** 
			 * @private 
			 * @type {number} 
			 */
		    var transportTicks = 0;
		    /**
			 *  Which subdivision the swing is applied to.
			 *  defaults to an 16th note
			 *  @private
			 *  @type {number}
			 */
		    var swingSubdivision = '16n';
		    /**
			 *  controls which beat the swing is applied to
			 *  defaults to an 16th note
			 *  @private
			 *  @type {number}
			 */
		    var swingTatum = 3;
		    /**
			 *  controls which beat the swing is applied to
			 *  @private
			 *  @type {number}
			 */
		    var swingAmount = 0;
		    /** 
			 * @private
			 * @type {number}
			 */
		    var transportTimeSignature = 4;
		    /** 
			 * @private
			 * @type {number}
			 */
		    var loopStart = 0;
		    /** 
			 * @private
			 * @type {number}
			 */
		    var loopEnd = tatum * 4;
		    /** 
			 * @private
			 * @type {Array}
			 */
		    var intervals = [];
		    /** 
			 * @private
			 * @type {Array}
			 */
		    var timeouts = [];
		    /** 
			 * @private
			 * @type {Array}
			 */
		    var transportTimeline = [];
		    /** 
			 * @private
			 * @type {number}
			 */
		    var timelineProgress = 0;
		    /** 
			 *  All of the synced components
			 *  @private 
			 *  @type {Array}
			 */
		    var SyncedSources = [];
		    /** 
			 *  All of the synced Signals
			 *  @private 
			 *  @type {Array}
			 */
		    var SyncedSignals = [];
		    ///////////////////////////////////////////////////////////////////////////////
		    //	TICKS
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  called on every tick
			 *  @param   {number} tickTime clock relative tick time
			 *  @private
			 */
		    Tone.Transport.prototype._processTick = function (tickTime) {
		        if (this.state === Tone.State.Started) {
		            if (swingAmount > 0 && timelineTicks % tatum !== 0 && //not on a downbeat
		                timelineTicks % swingTatum === 0) {
		                //add some swing
		                tickTime += this._ticksToSeconds(swingTatum) * swingAmount;
		            }
		            processIntervals(tickTime);
		            processTimeouts(tickTime);
		            processTimeline(tickTime);
		            transportTicks += 1;
		            timelineTicks += 1;
		            if (this.loop) {
		                if (timelineTicks === loopEnd) {
		                    this._setTicks(loopStart);
		                }
		            }
		        }
		    };
		    /**
			 *  jump to a specific tick in the timeline
			 *  updates the timeline callbacks
			 *  
			 *  @param   {number} ticks the tick to jump to
			 *  @private
			 */
		    Tone.Transport.prototype._setTicks = function (ticks) {
		        timelineTicks = ticks;
		        for (var i = 0; i < transportTimeline.length; i++) {
		            var timeout = transportTimeline[i];
		            if (timeout.callbackTick() >= ticks) {
		                timelineProgress = i;
		                break;
		            }
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	EVENT PROCESSING
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  process the intervals
			 *  @param  {number} time 
			 */
		    var processIntervals = function (time) {
		        for (var i = 0, len = intervals.length; i < len; i++) {
		            var interval = intervals[i];
		            if (interval.testInterval(transportTicks)) {
		                interval.doCallback(time);
		            }
		        }
		    };
		    /**
			 *  process the timeouts
			 *  @param  {number} time 
			 */
		    var processTimeouts = function (time) {
		        var removeTimeouts = 0;
		        for (var i = 0, len = timeouts.length; i < len; i++) {
		            var timeout = timeouts[i];
		            var callbackTick = timeout.callbackTick();
		            if (callbackTick <= transportTicks) {
		                timeout.doCallback(time);
		                removeTimeouts++;
		            } else if (callbackTick > transportTicks) {
		                break;
		            }
		        }
		        //remove the timeouts off the front of the array after they've been called
		        timeouts.splice(0, removeTimeouts);
		    };
		    /**
			 *  process the transportTimeline events
			 *  @param  {number} time 
			 */
		    var processTimeline = function (time) {
		        for (var i = timelineProgress, len = transportTimeline.length; i < len; i++) {
		            var evnt = transportTimeline[i];
		            var callbackTick = evnt.callbackTick();
		            if (callbackTick === timelineTicks) {
		                timelineProgress = i;
		                evnt.doCallback(time);
		            } else if (callbackTick > timelineTicks) {
		                break;
		            }
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	INTERVAL
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Set a callback for a recurring event.
			 *  @param {function} callback
			 *  @param {Time}   interval 
			 *  @return {number} the id of the interval
			 *  @example
			 *  //triggers a callback every 8th note with the exact time of the event
			 *  Tone.Transport.setInterval(function(time){
			 *  	envelope.triggerAttack(time);
			 *  }, "8n");
			 */
		    Tone.Transport.prototype.setInterval = function (callback, interval, ctx) {
		        var tickTime = this._toTicks(interval);
		        var timeout = new TimelineEvent(callback, ctx, tickTime, transportTicks);
		        intervals.push(timeout);
		        return timeout.id;
		    };
		    /**
			 *  Stop and ongoing interval.
			 *  @param  {number} intervalID  The ID of interval to remove. The interval
			 *                               ID is given as the return value in Tone.Transport.setInterval.
			 *  @return {boolean}            	true if the event was removed
			 */
		    Tone.Transport.prototype.clearInterval = function (rmInterval) {
		        for (var i = 0; i < intervals.length; i++) {
		            var interval = intervals[i];
		            if (interval.id === rmInterval) {
		                intervals.splice(i, 1);
		                return true;
		            }
		        }
		        return false;
		    };
		    /**
			 *  Removes all of the intervals that are currently set. 
			 *  @return {boolean}            	true if the event was removed
			 */
		    Tone.Transport.prototype.clearIntervals = function () {
		        var willRemove = intervals.length > 0;
		        intervals = [];
		        return willRemove;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	TIMEOUT
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Set a timeout to occur after time from now. NB: the transport must be 
			 *  running for this to be triggered. All timeout events are cleared when the 
			 *  transport is stopped. 
			 *
			 *  @param {function} callback 
			 *  @param {Time}   time    The time (from now) that the callback will be invoked.
			 *  @return {number} The id of the timeout.
			 *  @example
			 *  //trigger an event to happen 1 second from now
			 *  Tone.Transport.setTimeout(function(time){
			 *  	player.start(time);
			 *  }, 1)
			 */
		    Tone.Transport.prototype.setTimeout = function (callback, time, ctx) {
		        var ticks = this._toTicks(time);
		        var timeout = new TimelineEvent(callback, ctx, ticks + transportTicks, 0);
		        //put it in the right spot
		        for (var i = 0, len = timeouts.length; i < len; i++) {
		            var testEvnt = timeouts[i];
		            if (testEvnt.callbackTick() > timeout.callbackTick()) {
		                timeouts.splice(i, 0, timeout);
		                return timeout.id;
		            }
		        }
		        //otherwise push it on the end
		        timeouts.push(timeout);
		        return timeout.id;
		    };
		    /**
			 *  Clear a timeout using it's ID.
			 *  @param  {number} intervalID  The ID of timeout to remove. The timeout
			 *                               ID is given as the return value in Tone.Transport.setTimeout.
			 *  @return {boolean}           true if the timeout was removed
			 */
		    Tone.Transport.prototype.clearTimeout = function (timeoutID) {
		        for (var i = 0; i < timeouts.length; i++) {
		            var testTimeout = timeouts[i];
		            if (testTimeout.id === timeoutID) {
		                timeouts.splice(i, 1);
		                return true;
		            }
		        }
		        return false;
		    };
		    /**
			 *  Removes all of the timeouts that are currently set. 
			 *  @return {boolean}            	true if the event was removed
			 */
		    Tone.Transport.prototype.clearTimeouts = function () {
		        var willRemove = timeouts.length > 0;
		        timeouts = [];
		        return willRemove;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	TIMELINE
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Timeline events are synced to the timeline of the Tone.Transport.
			 *  Unlike Timeout, Timeline events will restart after the 
			 *  Tone.Transport has been stopped and restarted. 
			 *
			 *  @param {function} 	callback 	
			 *  @param {Tome.Time}  timeout  
			 *  @return {number} 				the id for clearing the transportTimeline event
			 *  @example
			 *  //trigger the start of a part on the 16th measure
			 *  Tone.Transport.setTimeline(function(time){
			 *  	part.start(time);
			 *  }, "16m");
			 */
		    Tone.Transport.prototype.setTimeline = function (callback, timeout, ctx) {
		        var ticks = this._toTicks(timeout);
		        var timelineEvnt = new TimelineEvent(callback, ctx, ticks, 0);
		        //put it in the right spot
		        for (var i = timelineProgress, len = transportTimeline.length; i < len; i++) {
		            var testEvnt = transportTimeline[i];
		            if (testEvnt.callbackTick() > timelineEvnt.callbackTick()) {
		                transportTimeline.splice(i, 0, timelineEvnt);
		                return timelineEvnt.id;
		            }
		        }
		        //otherwise push it on the end
		        transportTimeline.push(timelineEvnt);
		        return timelineEvnt.id;
		    };
		    /**
			 *  Clear the timeline event.
			 *  @param  {number} timelineID 
			 *  @return {boolean} true if it was removed
			 */
		    Tone.Transport.prototype.clearTimeline = function (timelineID) {
		        for (var i = 0; i < transportTimeline.length; i++) {
		            var testTimeline = transportTimeline[i];
		            if (testTimeline.id === timelineID) {
		                transportTimeline.splice(i, 1);
		                return true;
		            }
		        }
		        return false;
		    };
		    /**
			 *  Remove all events from the timeline.
			 *  @returns {boolean} true if the events were removed
			 */
		    Tone.Transport.prototype.clearTimelines = function () {
		        timelineProgress = 0;
		        var willRemove = transportTimeline.length > 0;
		        transportTimeline = [];
		        return willRemove;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	TIME CONVERSIONS
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  turns the time into
			 *  @param  {Time} time
			 *  @return {number}   
			 *  @private   
			 */
		    Tone.Transport.prototype._toTicks = function (time) {
		        //get the seconds
		        var seconds = this.toSeconds(time);
		        var quarter = this.notationToSeconds('4n');
		        var quarters = seconds / quarter;
		        var tickNum = quarters * tatum;
		        //quantize to tick value
		        return Math.round(tickNum);
		    };
		    /**
			 *  convert ticks into seconds
			 *  
			 *  @param  {number} ticks 
			 *  @param {number=} bpm 
			 *  @param {number=} timeSignature
			 *  @return {number}               seconds
			 *  @private
			 */
		    Tone.Transport.prototype._ticksToSeconds = function (ticks, bpm, timeSignature) {
		        ticks = Math.floor(ticks);
		        var quater = this.notationToSeconds('4n', bpm, timeSignature);
		        return quater * ticks / tatum;
		    };
		    /**
			 *  Returns the time of the next beat.
			 *  @param  {string} [subdivision="4n"]
			 *  @return {number} 	the time in seconds of the next subdivision
			 */
		    Tone.Transport.prototype.nextBeat = function (subdivision) {
		        subdivision = this.defaultArg(subdivision, '4n');
		        var tickNum = this._toTicks(subdivision);
		        var remainingTicks = transportTicks % tickNum;
		        var nextTick = remainingTicks;
		        if (remainingTicks > 0) {
		            nextTick = tickNum - remainingTicks;
		        }
		        return this._ticksToSeconds(nextTick);
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	START/STOP/PAUSE
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Start the transport and all sources synced to the transport.
			 *  @param  {Time} [time=now] The time when the transport should start.
			 *  @param  {Time=} offset The timeline offset to start the transport.
			 *  @returns {Tone.Transport} this
			 *  @example
			 * //start the transport in one second starting at beginning of the 5th measure. 
			 * Tone.Transport.start("+1", "4:0:0");
			 */
		    Tone.Transport.prototype.start = function (time, offset) {
		        if (this.state === Tone.State.Stopped || this.state === Tone.State.Paused) {
		            if (!this.isUndef(offset)) {
		                this._setTicks(this._toTicks(offset));
		            }
		            this.state = Tone.State.Started;
		            var startTime = this.toSeconds(time);
		            this._clock.start(startTime);
		            //call start on each of the synced sources
		            for (var i = 0; i < SyncedSources.length; i++) {
		                var source = SyncedSources[i].source;
		                var delay = SyncedSources[i].delay;
		                source.start(startTime + delay);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Stop the transport and all sources synced to the transport.
			 *  @param  {Time} [time=now] The time when the transport should stop. 
			 *  @returns {Tone.Transport} this
			 *  @example
			 * Tone.Transport.stop();
			 */
		    Tone.Transport.prototype.stop = function (time) {
		        if (this.state === Tone.State.Started || this.state === Tone.State.Paused) {
		            var stopTime = this.toSeconds(time);
		            this._clock.stop(stopTime);
		            //call start on each of the synced sources
		            for (var i = 0; i < SyncedSources.length; i++) {
		                var source = SyncedSources[i].source;
		                source.stop(stopTime);
		            }
		        } else {
		            this._onended();
		        }
		        return this;
		    };
		    /**
			 *  invoked when the transport is stopped
			 *  @private
			 */
		    Tone.Transport.prototype._onended = function () {
		        transportTicks = 0;
		        this._setTicks(0);
		        this.clearTimeouts();
		        this.state = Tone.State.Stopped;
		    };
		    /**
			 *  Pause the transport and all sources synced to the transport.
			 *  @param  {Time} [time=now]
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.pause = function (time) {
		        if (this.state === Tone.State.Started) {
		            this.state = Tone.State.Paused;
		            var stopTime = this.toSeconds(time);
		            this._clock.stop(stopTime);
		            //call pause on each of the synced sources
		            for (var i = 0; i < SyncedSources.length; i++) {
		                var source = SyncedSources[i].source;
		                source.pause(stopTime);
		            }
		        }
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	SETTERS/GETTERS
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  The time signature as just the numerator over 4. 
			 *  For example 4/4 would be just 4 and 6/8 would be 3.
			 *  @memberOf Tone.Transport#
			 *  @type {number}
			 *  @name timeSignature
			 *  @example
			 * //common time
			 * Tone.Transport.timeSignature = 4;
			 * // 7/8
			 * Tone.Transport.timeSignature = 3.5;
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'timeSignature', {
		        get: function () {
		            return transportTimeSignature;
		        },
		        set: function (numerator) {
		            transportTimeSignature = numerator;
		        }
		    });
		    /**
			 * When the Tone.Transport.loop = true, this is the starting position of the loop.
			 * @memberOf Tone.Transport#
			 * @type {Time}
			 * @name loopStart
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'loopStart', {
		        get: function () {
		            return this._ticksToSeconds(loopStart);
		        },
		        set: function (startPosition) {
		            loopStart = this._toTicks(startPosition);
		        }
		    });
		    /**
			 * When the Tone.Transport.loop = true, this is the ending position of the loop.
			 * @memberOf Tone.Transport#
			 * @type {Time}
			 * @name loopEnd
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'loopEnd', {
		        get: function () {
		            return this._ticksToSeconds(loopEnd);
		        },
		        set: function (endPosition) {
		            loopEnd = this._toTicks(endPosition);
		        }
		    });
		    /**
			 *  Set the loop start and stop at the same time. 
			 *  @param {Time} startPosition 
			 *  @param {Time} endPosition   
			 *  @returns {Tone.Transport} this
			 *  @example
			 * //loop over the first measure
			 * Tone.Transport.setLoopPoints(0, "1m");
			 * Tone.Transport.loop = true;
			 */
		    Tone.Transport.prototype.setLoopPoints = function (startPosition, endPosition) {
		        this.loopStart = startPosition;
		        this.loopEnd = endPosition;
		        return this;
		    };
		    /**
			 *  The swing value. Between 0-1 where 1 equal to 
			 *  the note + half the subdivision.
			 *  @memberOf Tone.Transport#
			 *  @type {NormalRange}
			 *  @name swing
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'swing', {
		        get: function () {
		            return swingAmount * 2;
		        },
		        set: function (amount) {
		            //scale the values to a normal range
		            swingAmount = amount * 0.5;
		        }
		    });
		    /**
			 *  Set the subdivision which the swing will be applied to. 
			 *  The default values is a 16th note. Value must be less 
			 *  than a quarter note.
			 *  
			 *  @memberOf Tone.Transport#
			 *  @type {Time}
			 *  @name swingSubdivision
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'swingSubdivision', {
		        get: function () {
		            return swingSubdivision;
		        },
		        set: function (subdivision) {
		            //scale the values to a normal range
		            swingSubdivision = subdivision;
		            swingTatum = this._toTicks(subdivision);
		        }
		    });
		    /**
			 *  The Transport's position in MEASURES:BEATS:SIXTEENTHS.
			 *  Setting the value will jump to that position right away. 
			 *  
			 *  @memberOf Tone.Transport#
			 *  @type {TransportTime}
			 *  @name position
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'position', {
		        get: function () {
		            var quarters = timelineTicks / tatum;
		            var measures = Math.floor(quarters / transportTimeSignature);
		            var sixteenths = Math.floor(quarters % 1 * 4);
		            quarters = Math.floor(quarters) % transportTimeSignature;
		            var progress = [
		                measures,
		                quarters,
		                sixteenths
		            ];
		            return progress.join(':');
		        },
		        set: function (progress) {
		            var ticks = this._toTicks(progress);
		            this._setTicks(ticks);
		        }
		    });
		    ///////////////////////////////////////////////////////////////////////////////
		    //	SYNCING
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Sync a source to the transport so that 
			 *  @param  {Tone.Source} source the source to sync to the transport
			 *  @param {Time} delay (optionally) start the source with a delay from the transport
			 *  @returns {Tone.Transport} this
			 *  @example
			 * Tone.Transport.syncSource(player, "1m");
			 * Tone.Transport.start();
			 * //the player will start 1 measure after the transport starts
			 */
		    Tone.Transport.prototype.syncSource = function (source, startDelay) {
		        SyncedSources.push({
		            source: source,
		            delay: this.toSeconds(this.defaultArg(startDelay, 0))
		        });
		        return this;
		    };
		    /**
			 *  Unsync the source from the transport. See Tone.Transport.syncSource. 
			 *  
			 *  @param  {Tone.Source} source [description]
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.unsyncSource = function (source) {
		        for (var i = 0; i < SyncedSources.length; i++) {
		            if (SyncedSources[i].source === source) {
		                SyncedSources.splice(i, 1);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Attaches the signal to the tempo control signal so that 
			 *  any changes in the tempo will change the signal in the same
			 *  ratio. 
			 *  
			 *  @param  {Tone.Signal} signal 
			 *  @param {number=} ratio Optionally pass in the ratio between
			 *                         the two signals. Otherwise it will be computed
			 *                         based on their current values. 
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.syncSignal = function (signal, ratio) {
		        if (!ratio) {
		            //get the sync ratio
		            if (signal._value.value !== 0) {
		                ratio = signal._value.value / this.bpm.value;
		            } else {
		                ratio = 0;
		            }
		        }
		        var ratioSignal = this.context.createGain();
		        ratioSignal.gain.value = ratio;
		        this.bpm.chain(ratioSignal, signal._value);
		        SyncedSignals.push({
		            'ratio': ratioSignal,
		            'signal': signal,
		            'initial': signal._value.value
		        });
		        signal._value.value = 0;
		        return this;
		    };
		    /**
			 *  Unsyncs a previously synced signal from the transport's control. 
			 *  See Tone.Transport.syncSignal.
			 *  @param  {Tone.Signal} signal 
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.unsyncSignal = function (signal) {
		        for (var i = 0; i < SyncedSignals.length; i++) {
		            var syncedSignal = SyncedSignals[i];
		            if (syncedSignal.signal === signal) {
		                syncedSignal.ratio.disconnect();
		                syncedSignal.signal._value.value = syncedSignal.initial;
		                SyncedSignals.splice(i, 1);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Transport} this
			 *  @private
			 */
		    Tone.Transport.prototype.dispose = function () {
		        this._clock.dispose();
		        this._clock = null;
		        this.bpm.dispose();
		        this.bpm = null;
		        this._bpmMult.dispose();
		        this._bpmMult = null;
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	TIMELINE EVENT
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  @static
			 *  @type {number}
			 */
		    var TimelineEventIDCounter = 0;
		    /**
			 *  A Timeline event
			 *
			 *  @constructor
			 *  @private
			 *  @param {function(number)} callback   
			 *  @param {Object}   context    
			 *  @param {number}   tickTime
		 	 *  @param {number}   startTicks
			 */
		    var TimelineEvent = function (callback, context, tickTime, startTicks) {
		        this.startTicks = startTicks;
		        this.tickTime = tickTime;
		        this.callback = callback;
		        this.context = context;
		        this.id = TimelineEventIDCounter++;
		    };
		    /**
			 *  invoke the callback in the correct context
			 *  passes in the playback time
			 *  
			 *  @param  {number} playbackTime 
			 */
		    TimelineEvent.prototype.doCallback = function (playbackTime) {
		        this.callback.call(this.context, playbackTime);
		    };
		    /**
			 *  get the tick which the callback is supposed to occur on
			 *  
			 *  @return {number} 
			 */
		    TimelineEvent.prototype.callbackTick = function () {
		        return this.startTicks + this.tickTime;
		    };
		    /**
			 *  test if the tick occurs on the interval
			 *  
			 *  @param  {number} tick 
			 *  @return {boolean}      
			 */
		    TimelineEvent.prototype.testInterval = function (tick) {
		        return (tick - this.startTicks) % this.tickTime === 0;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	AUGMENT TONE'S PROTOTYPE TO INCLUDE TRANSPORT TIMING
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  tests if a string is musical notation
			 *  i.e.:
			 *  	4n = quarter note
			 *   	2m = two measures
			 *    	8t = eighth-note triplet
			 *  
			 *  @return {boolean} 
			 *  @method isNotation
			 *  @lends Tone.prototype.isNotation
			 */
		    Tone.prototype.isNotation = function () {
		        var notationFormat = new RegExp(/[0-9]+[mnt]$/i);
		        return function (note) {
		            return notationFormat.test(note);
		        };
		    }();
		    /**
			 *  tests if a string is transportTime
			 *  i.e. :
			 *  	1:2:0 = 1 measure + two quarter notes + 0 sixteenth notes
			 *  	
			 *  @return {boolean} 
			 *
			 *  @method isTransportTime
			 *  @lends Tone.prototype.isTransportTime
			 */
		    Tone.prototype.isTransportTime = function () {
		        var transportTimeFormat = new RegExp(/^\d+(\.\d+)?:\d+(\.\d+)?(:\d+(\.\d+)?)?$/i);
		        return function (transportTime) {
		            return transportTimeFormat.test(transportTime);
		        };
		    }();
		    /**
			 *
			 *  convert notation format strings to seconds
			 *  
			 *  @param  {string} notation     
			 *  @param {number=} bpm 
			 *  @param {number=} timeSignature 
			 *  @return {number} 
			 *                
			 */
		    Tone.prototype.notationToSeconds = function (notation, bpm, timeSignature) {
		        bpm = this.defaultArg(bpm, Tone.Transport.bpm.value);
		        timeSignature = this.defaultArg(timeSignature, transportTimeSignature);
		        var beatTime = 60 / bpm;
		        var subdivision = parseInt(notation, 10);
		        var beats = 0;
		        if (subdivision === 0) {
		            beats = 0;
		        }
		        var lastLetter = notation.slice(-1);
		        if (lastLetter === 't') {
		            beats = 4 / subdivision * 2 / 3;
		        } else if (lastLetter === 'n') {
		            beats = 4 / subdivision;
		        } else if (lastLetter === 'm') {
		            beats = subdivision * timeSignature;
		        } else {
		            beats = 0;
		        }
		        return beatTime * beats;
		    };
		    /**
			 *  convert transportTime into seconds.
			 *  
			 *  ie: 4:2:3 == 4 measures + 2 quarters + 3 sixteenths
			 *
			 *  @param  {string} transportTime 
			 *  @param {number=} bpm 
			 *  @param {number=} timeSignature
			 *  @return {number}               seconds
			 *
			 *  @lends Tone.prototype.transportTimeToSeconds
			 */
		    Tone.prototype.transportTimeToSeconds = function (transportTime, bpm, timeSignature) {
		        bpm = this.defaultArg(bpm, Tone.Transport.bpm.value);
		        timeSignature = this.defaultArg(timeSignature, transportTimeSignature);
		        var measures = 0;
		        var quarters = 0;
		        var sixteenths = 0;
		        var split = transportTime.split(':');
		        if (split.length === 2) {
		            measures = parseFloat(split[0]);
		            quarters = parseFloat(split[1]);
		        } else if (split.length === 1) {
		            quarters = parseFloat(split[0]);
		        } else if (split.length === 3) {
		            measures = parseFloat(split[0]);
		            quarters = parseFloat(split[1]);
		            sixteenths = parseFloat(split[2]);
		        }
		        var beats = measures * timeSignature + quarters + sixteenths / 4;
		        return beats * this.notationToSeconds('4n');
		    };
		    /**
			 *  Convert seconds to the closest transportTime in the form 
			 *  	measures:quarters:sixteenths
			 *
			 *  @method toTransportTime
			 *  
			 *  @param {Time} seconds 
			 *  @param {number=} bpm 
			 *  @param {number=} timeSignature
			 *  @return {string}  
			 *  
			 *  @lends Tone.prototype.toTransportTime
			 */
		    Tone.prototype.toTransportTime = function (time, bpm, timeSignature) {
		        var seconds = this.toSeconds(time, bpm, timeSignature);
		        bpm = this.defaultArg(bpm, Tone.Transport.bpm.value);
		        timeSignature = this.defaultArg(timeSignature, transportTimeSignature);
		        var quarterTime = this.notationToSeconds('4n');
		        var quarters = seconds / quarterTime;
		        var measures = Math.floor(quarters / timeSignature);
		        var sixteenths = Math.floor(quarters % 1 * 4);
		        quarters = Math.floor(quarters) % timeSignature;
		        var progress = [
		            measures,
		            quarters,
		            sixteenths
		        ];
		        return progress.join(':');
		    };
		    /**
			 *  Convert a frequency representation into a number.
			 *  	
			 *  @param  {Frequency} freq 
			 *  @param {number=} 	now 	if passed in, this number will be 
			 *                        		used for all 'now' relative timings
			 *  @return {number}      the frequency in hertz
			 */
		    Tone.prototype.toFrequency = function (freq, now) {
		        if (this.isFrequency(freq)) {
		            return parseFloat(freq);
		        } else if (this.isNotation(freq) || this.isTransportTime(freq)) {
		            return this.secondsToFrequency(this.toSeconds(freq, now));
		        } else {
		            return freq;
		        }
		    };
		    /**
			 *  Convert Time into seconds.
			 *  
			 *  Unlike the method which it overrides, this takes into account 
			 *  transporttime and musical notation.
			 *
			 *  Time : 1.40
			 *  Notation: 4n|1m|2t
			 *  TransportTime: 2:4:1 (measure:quarters:sixteens)
			 *  Now Relative: +3n
			 *  Math: 3n+16n or even very complicated expressions ((3n*2)/6 + 1)
			 *
			 *  @override
			 *  @param  {Time} time       
			 *  @param {number=} 	now 	if passed in, this number will be 
			 *                        		used for all 'now' relative timings
			 *  @return {number} 
			 */
		    Tone.prototype.toSeconds = function (time, now) {
		        now = this.defaultArg(now, this.now());
		        if (typeof time === 'number') {
		            return time;    //assuming that it's seconds
		        } else if (typeof time === 'string') {
		            var plusTime = 0;
		            if (time.charAt(0) === '+') {
		                plusTime = now;
		                time = time.slice(1);
		            }
		            var components = time.split(/[\(\)\-\+\/\*]/);
		            if (components.length > 1) {
		                var originalTime = time;
		                for (var i = 0; i < components.length; i++) {
		                    var symb = components[i].trim();
		                    if (symb !== '') {
		                        var val = this.toSeconds(symb);
		                        time = time.replace(symb, val);
		                    }
		                }
		                try {
		                    //i know eval is evil, but i think it's safe here
		                    time = eval(time);    // jshint ignore:line
		                } catch (e) {
		                    throw new EvalError('problem evaluating Tone.Type.Time: ' + originalTime);
		                }
		            } else if (this.isNotation(time)) {
		                time = this.notationToSeconds(time);
		            } else if (this.isTransportTime(time)) {
		                time = this.transportTimeToSeconds(time);
		            } else if (this.isFrequency(time)) {
		                time = this.frequencyToSeconds(time);
		            } else {
		                time = parseFloat(time);
		            }
		            return time + plusTime;
		        } else {
		            return now;
		        }
		    };
		    var TransportConstructor = Tone.Transport;
		    Tone._initAudioContext(function () {
		        if (typeof Tone.Transport === 'function') {
		            //a single transport object
		            Tone.Transport = new Tone.Transport();
		        } else {
		            //stop the clock
		            Tone.Transport.stop();
		            //get the previous bpm
		            var bpm = Tone.Transport.bpm.value;
		            //destory the old clock
		            Tone.Transport._clock.dispose();
		            //make new Transport insides
		            TransportConstructor.call(Tone.Transport);
		            //set the bpm
		            Tone.Transport.bpm.value = bpm;
		        }
		    });
		    return Tone.Transport;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A single master output which is connected to the
			 *          AudioDestinationNode (aka your speakers). 
			 *          It provides useful conveniences such as the ability 
			 *          to set the volume and mute the entire application. 
			 *          It also gives you the ability to apply master effects to your application. 
			 *          <br><br>
			 *          Like Tone.Transport, A single Tone.Master is created
			 *          on initialization and you do not need to explicitly construct one.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @singleton
			 *  @example
			 * //the audio will go from the oscillator to the speakers
			 * oscillator.connect(Tone.Master);
			 * //a convenience for connecting to the master output is also provided:
			 * oscillator.toMaster();
			 * //the above two examples are equivalent.
			 */
		    Tone.Master = function () {
		        Tone.call(this);
		        /**
				 * the unmuted volume
				 * @type {number}
				 * @private
				 */
		        this._unmutedVolume = 1;
		        /**
				 *  if the master is muted
				 *  @type {boolean}
				 *  @private
				 */
		        this._muted = false;
		        /**
				 * The volume of the master output.
				 * @type {Decibels}
				 * @signal
				 */
		        this.volume = new Tone.Signal(this.output.gain, Tone.Type.Decibels);
		        //connections
		        this.input.chain(this.output, this.context.destination);
		    };
		    Tone.extend(Tone.Master);
		    /**
			 *  @type {Object}
			 *  @const
			 */
		    Tone.Master.defaults = {
		        'volume': 0,
		        'mute': false
		    };
		    /**
			 * Mute the output. 
			 * @memberOf Tone.Master#
			 * @type {boolean}
			 * @name mute
			 * @example
			 * //mute the output
			 * Tone.Master.mute = true;
			 */
		    Object.defineProperty(Tone.Master.prototype, 'mute', {
		        get: function () {
		            return this._muted;
		        },
		        set: function (mute) {
		            if (!this._muted && mute) {
		                this._unmutedVolume = this.volume.value;
		                //maybe it should ramp here?
		                this.volume.value = -Infinity;
		            } else if (this._muted && !mute) {
		                this.volume.value = this._unmutedVolume;
		            }
		            this._muted = mute;
		        }
		    });
		    /**
			 *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously 
			 *  chained in the master effects chain. 
			 *  @param {AudioNode|Tone...} args All arguments will be connected in a row
			 *                                  and the Master will be routed through it.
			 *  @return  {Tone.Master}  this
			 *  @example
			 * //some overall compression to keep the levels in check
			 * var masterCompressor = new Tone.Compressor({
			 * 	"threshold" : -6,
			 * 	"ratio" : 3,
			 * 	"attack" : 0.5,
			 * 	"release" : 0.1
			 * });
			 * //give a little boost to the lows
			 * var lowBump = new Tone.Filter(200, "lowshelf");
			 * //route everything through the filter 
			 * //and compressor before going to the speakers
			 * Tone.Master.chain(lowBump, masterCompressor);
			 */
		    Tone.Master.prototype.chain = function () {
		        this.input.disconnect();
		        this.input.chain.apply(this.input, arguments);
		        arguments[arguments.length - 1].connect(this.output);
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	AUGMENT TONE's PROTOTYPE
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Connect 'this' to the master output. Shorthand for this.connect(Tone.Master)
			 *  @returns {Tone} this
			 *  @example
			 * //connect an oscillator to the master output
			 * var osc = new Tone.Oscillator().toMaster();
			 */
		    Tone.prototype.toMaster = function () {
		        this.connect(Tone.Master);
		        return this;
		    };
		    /**
			 *  Also augment AudioNode's prototype to include toMaster
			 *  as a convenience
			 *  @returns {AudioNode} this
			 */
		    AudioNode.prototype.toMaster = function () {
		        this.connect(Tone.Master);
		        return this;
		    };
		    var MasterConstructor = Tone.Master;
		    /**
			 *  initialize the module and listen for new audio contexts
			 */
		    Tone._initAudioContext(function () {
		        //a single master output
		        if (!Tone.prototype.isUndef(Tone.Master)) {
		            Tone.Master = new MasterConstructor();
		        } else {
		            MasterConstructor.prototype.dispose.call(Tone.Master);
		            MasterConstructor.call(Tone.Master);
		        }
		    });
		    return Tone.Master;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Base class for sources. Sources have start/stop methods
			 *          and the ability to be synced to the 
			 *          start/stop of Tone.Transport.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 */
		    Tone.Source = function (options) {
		        //unlike most ToneNodes, Sources only have an output and no input
		        Tone.call(this, 0, 1);
		        options = this.defaultArg(options, Tone.Source.defaults);
		        /**
				 * Callback is invoked when the source is done playing.
				 * @type {function}
				 * @example
				 * source.onended = function(){
				 * 	console.log("the source is done playing");
				 * }
				 */
		        this.onended = options.onended;
		        /**
				 *  the next time the source is started
				 *  @type {number}
				 *  @private
				 */
		        this._nextStart = Infinity;
		        /**
				 *  the next time the source is stopped
				 *  @type {number}
				 *  @private
				 */
		        this._nextStop = Infinity;
		        /**
				 * The volume of the output in decibels.
				 * @type {Decibels}
				 * @signal
				 * @example
				 * source.volume.value = -6;
				 */
		        this.volume = new Tone.Signal({
		            'param': this.output.gain,
		            'value': options.volume,
		            'units': Tone.Type.Decibels
		        });
		        this._readOnly('volume');
		        /**
				 * 	keeps track of the timeout for chaning the state
				 * 	and calling the onended
				 *  @type {number}
				 *  @private
				 */
		        this._timeout = -1;
		        //make the output explicitly stereo
		        this.output.channelCount = 2;
		        this.output.channelCountMode = 'explicit';
		    };
		    Tone.extend(Tone.Source);
		    /**
			 *  The default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Source.defaults = {
		        'onended': Tone.noOp,
		        'volume': 0
		    };
		    /**
			 *  Returns the playback state of the source, either "started" or "stopped".
			 *  @type {Tone.State}
			 *  @readOnly
			 *  @memberOf Tone.Source#
			 *  @name state
			 */
		    Object.defineProperty(Tone.Source.prototype, 'state', {
		        get: function () {
		            return this._stateAtTime(this.now());
		        }
		    });
		    /**
			 *  Get the state of the source at the specified time.
			 *  @param  {Time}  time
			 *  @return  {Tone.State} 
			 *  @private
			 */
		    Tone.Source.prototype._stateAtTime = function (time) {
		        time = this.toSeconds(time);
		        if (this._nextStart <= time && this._nextStop > time) {
		            return Tone.State.Started;
		        } else if (this._nextStop <= time) {
		            return Tone.State.Stopped;
		        } else {
		            return Tone.State.Stopped;
		        }
		    };
		    /**
			 *  Start the source at the specified time. If no time is given, 
			 *  start the source now.
			 *  @param  {Time} [time=now] When the source should be started.
			 *  @returns {Tone.Source} this
			 *  @example
			 * source.start("+0.5"); //starts the source 0.5 seconds from now
			 */
		    Tone.Source.prototype.start = function (time) {
		        time = this.toSeconds(time);
		        if (this._stateAtTime(time) !== Tone.State.Started || this.retrigger) {
		            this._nextStart = time;
		            this._nextStop = Infinity;
		            this._start.apply(this, arguments);
		        }
		        return this;
		    };
		    /**
			 *  Stop the source at the specified time. If no time is given, 
			 *  stop the source now.
			 *  @param  {Time} [time=now] When the source should be stopped. 
			 *  @returns {Tone.Source} this
			 *  @example
			 * source.stop(); // stops the source immediately
			 */
		    Tone.Source.prototype.stop = function (time) {
		        var now = this.now();
		        time = this.toSeconds(time, now);
		        if (this._stateAtTime(time) === Tone.State.Started) {
		            this._nextStop = this.toSeconds(time);
		            clearTimeout(this._timeout);
		            var diff = time - now;
		            if (diff > 0) {
		                //add a small buffer before invoking the callback
		                this._timeout = setTimeout(this.onended, diff * 1000 + 20);
		            } else {
		                this.onended();
		            }
		            this._stop.apply(this, arguments);
		        }
		        return this;
		    };
		    /**
			 *  Not ready yet. 
		 	 *  @private
		 	 *  @abstract
			 *  @param  {Time} time 
			 *  @returns {Tone.Source} this
			 */
		    Tone.Source.prototype.pause = function (time) {
		        //if there is no pause, just stop it
		        this.stop(time);
		        return this;
		    };
		    /**
			 *  Sync the source to the Transport so that when the transport
			 *  is started, this source is started and when the transport is stopped
			 *  or paused, so is the source. 
			 *
			 *  @param {Time} [delay=0] Delay time before starting the source after the
			 *                               Transport has started. 
			 *  @returns {Tone.Source} this
			 *  @example
			 * //sync the source to start 1 measure after the transport starts
			 * source.sync("1m");
			 * //start the transport. the source will start 1 measure later. 
			 * Tone.Transport.start();
			 */
		    Tone.Source.prototype.sync = function (delay) {
		        Tone.Transport.syncSource(this, delay);
		        return this;
		    };
		    /**
			 *  Unsync the source to the Transport. See Tone.Source.sync
			 *  @returns {Tone.Source} this
			 */
		    Tone.Source.prototype.unsync = function () {
		        Tone.Transport.unsyncSource(this);
		        return this;
		    };
		    /**
			 *	Clean up.
			 *  @return {Tone.Source} this
			 */
		    Tone.Source.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.stop();
		        clearTimeout(this._timeout);
		        this.onended = Tone.noOp;
		        this._writable('volume');
		        this.volume.dispose();
		        this.volume = null;
		    };
		    return Tone.Source;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Oscillator supports a number of features including
			 *         phase rotation, multiple oscillator types (see Tone.Oscillator.type), 
			 *         and Transport syncing (see Tone.Oscillator.syncFrequency).
			 *
			 *  @constructor
			 *  @extends {Tone.Source}
			 *  @param {Frequency} [frequency] Starting frequency
			 *  @param {string} [type] The oscillator type. Read more about type below.
			 *  @example
			 * //make and start a 440hz sine tone
			 * var osc = new Tone.Oscillator(440, "sine").toMaster().start();
			 */
		    Tone.Oscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type'
		        ], Tone.Oscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  the main oscillator
				 *  @type {OscillatorNode}
				 *  @private
				 */
		        this._oscillator = null;
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The detune control signal.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
		        /**
				 *  the periodic wave
				 *  @type {PeriodicWave}
				 *  @private
				 */
		        this._wave = null;
		        /**
				 *  the phase of the oscillator
				 *  between 0 - 360
				 *  @type {number}
				 *  @private
				 */
		        this._phase = options.phase;
		        /**
				 *  the type of the oscillator
				 *  @type {string}
				 *  @private
				 */
		        this._type = null;
		        //setup
		        this.type = options.type;
		        this.phase = this._phase;
		        this._readOnly([
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.Oscillator, Tone.Source);
		    /**
			 *  the default parameters
			 *  @type {Object}
			 */
		    Tone.Oscillator.defaults = {
		        'type': 'sine',
		        'frequency': 440,
		        'detune': 0,
		        'phase': 0
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} [time=now] 
			 *  @private
			 */
		    Tone.Oscillator.prototype._start = function (time) {
		        //new oscillator with previous values
		        this._oscillator = this.context.createOscillator();
		        this._oscillator.setPeriodicWave(this._wave);
		        //connect the control signal to the oscillator frequency & detune
		        this._oscillator.connect(this.output);
		        this.frequency.connect(this._oscillator.frequency);
		        this.detune.connect(this._oscillator.detune);
		        //start the oscillator
		        this._oscillator.start(this.toSeconds(time));
		    };
		    /**
			 *  stop the oscillator
			 *  @private
			 *  @param  {Time} [time=now] (optional) timing parameter
			 *  @returns {Tone.Oscillator} this
			 */
		    Tone.Oscillator.prototype._stop = function (time) {
		        if (this._oscillator) {
		            this._oscillator.stop(this.toSeconds(time));
		            this._oscillator = null;
		        }
		        return this;
		    };
		    /**
			 *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,
			 *  will also affect the oscillators frequency. 
			 *  @returns {Tone.Oscillator} this
			 *  @example
			 * Tone.Transport.bpm.value = 120;
			 * osc.frequency.value = 440;
			 * //the ration between the bpm and the frequency will be maintained
			 * osc.syncFrequency();
			 * Tone.Transport.bpm.value = 240; 
			 * // the frequency of the oscillator is doubled to 880
			 */
		    Tone.Oscillator.prototype.syncFrequency = function () {
		        Tone.Transport.syncSignal(this.frequency);
		        return this;
		    };
		    /**
			 *  Unsync the oscillator's frequency from the Transport. 
			 *  See Tone.Oscillator.syncFrequency
			 *  @returns {Tone.Oscillator} this
			 */
		    Tone.Oscillator.prototype.unsyncFrequency = function () {
		        Tone.Transport.unsyncSignal(this.frequency);
		        return this;
		    };
		    /**
			 * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of
			 * setting the first x number of partials of the oscillator. For example: "sine4" would
			 * set be the first 4 partials of the sine wave and "triangle8" would set the first
			 * 8 partials of the triangle wave.
			 * <br><br> 
			 * Uses PeriodicWave internally even for native types so that it can set the phase. 
			 * PeriodicWave equations are from the 
			 * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).
			 *  
			 * @memberOf Tone.Oscillator#
			 * @type {string}
			 * @name type
			 * @example
			 * //set it to a square wave
			 * osc.type = "square";
			 * @example
			 * //set the first 6 partials of a sawtooth wave
			 * osc.type = "sawtooth6";
			 */
		    Object.defineProperty(Tone.Oscillator.prototype, 'type', {
		        get: function () {
		            return this._type;
		        },
		        set: function (type) {
		            var originalType = type;
		            var fftSize = 4096;
		            var periodicWaveSize = fftSize / 2;
		            var real = new Float32Array(periodicWaveSize);
		            var imag = new Float32Array(periodicWaveSize);
		            var partialCount = 1;
		            var partial = /(sine|triangle|square|sawtooth)(\d+)$/.exec(type);
		            if (partial) {
		                partialCount = parseInt(partial[2]);
		                type = partial[1];
		                partialCount = Math.max(partialCount, 2);
		                periodicWaveSize = partialCount;
		            }
		            var shift = this._phase;
		            for (var n = 1; n < periodicWaveSize; ++n) {
		                var piFactor = 2 / (n * Math.PI);
		                var b;
		                switch (type) {
		                case 'sine':
		                    b = n <= partialCount ? 1 : 0;
		                    break;
		                case 'square':
		                    b = n & 1 ? 2 * piFactor : 0;
		                    break;
		                case 'sawtooth':
		                    b = piFactor * (n & 1 ? 1 : -1);
		                    break;
		                case 'triangle':
		                    if (n & 1) {
		                        b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);
		                    } else {
		                        b = 0;
		                    }
		                    break;
		                default:
		                    throw new TypeError('invalid oscillator type: ' + type);
		                }
		                if (b !== 0) {
		                    real[n] = -b * Math.sin(shift * n);
		                    imag[n] = b * Math.cos(shift * n);
		                } else {
		                    real[n] = 0;
		                    imag[n] = 0;
		                }
		            }
		            var periodicWave = this.context.createPeriodicWave(real, imag);
		            this._wave = periodicWave;
		            if (this._oscillator !== null) {
		                this._oscillator.setPeriodicWave(this._wave);
		            }
		            this._type = originalType;
		        }
		    });
		    /**
			 * The phase of the oscillator in degrees. 
			 * @memberOf Tone.Oscillator#
			 * @type {Degrees}
			 * @name phase
			 * @example
			 * osc.phase = 180; //flips the phase of the oscillator
			 */
		    Object.defineProperty(Tone.Oscillator.prototype, 'phase', {
		        get: function () {
		            return this._phase * (180 / Math.PI);
		        },
		        set: function (phase) {
		            this._phase = phase * Math.PI / 180;
		            //reset the type
		            this.type = this._type;
		        }
		    });
		    /**
			 *  Dispose and disconnect.
			 *  @return {Tone.Oscillator} this
			 */
		    Tone.Oscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        if (this._oscillator !== null) {
		            this._oscillator.disconnect();
		            this._oscillator = null;
		        }
		        this._wave = null;
		        this._writable([
		            'frequency',
		            'detune'
		        ]);
		        this.frequency.dispose();
		        this.frequency = null;
		        this.detune.dispose();
		        this.detune = null;
		        return this;
		    };
		    return Tone.Oscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1]. 
			 *         See Tone.GainToAudio.
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @example
			 *  var a2g = new Tone.AudioToGain();
			 */
		    Tone.AudioToGain = function () {
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
		            return (x + 1) / 2;
		        });
		    };
		    Tone.extend(Tone.AudioToGain, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.AudioToGain} this
			 */
		    Tone.AudioToGain.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._norm.dispose();
		        this._norm = null;
		        return this;
		    };
		    return Tone.AudioToGain;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  LFO stands for low frequency oscillator. Tone.LFO produces an output signal 
			 *          which can be attached to an AudioParam or Tone.Signal 
			 *          in order to modulate that parameter with an oscillator. The LFO can 
			 *          also be synced to the transport to start/stop and change when the tempo changes.
			 *
			 *  @constructor
			 *  @extends {Tone.Oscillator}
			 *  @param {Frequency|Object} [frequency] The frequency of the oscillation. Typically, LFOs will be
			 *                               in the frequency range of 0.1 to 10 hertz. 
			 *  @param {number=} min The minimum output value of the LFO. The LFO starts 
			 *                      at it's minimum value. 
			 *  @param {number=} max The maximum value of the LFO. 
			 *  @example
			 * var lfo = new Tone.LFO("4n", 400, 4000);
			 * lfo.connect(filter.frequency);
			 */
		    Tone.LFO = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'min',
		            'max'
		        ], Tone.LFO.defaults);
		        /** 
				 *  The oscillator. 
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this.oscillator = new Tone.Oscillator({
		            'frequency': options.frequency,
		            'type': options.type,
		            'phase': options.phase + 90
		        });
		        /**
				 *  the lfo's frequency
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this.oscillator.frequency;
		        /**
				 * The amplitude of the LFO, which controls the output range between
				 * the min and max output. For example if the min is -10 and the max 
				 * is 10, setting the amplitude to 0.5 would make the LFO modulate
				 * between -5 and 5. 
				 * @type {Number}
				 * @signal
				 */
		        this.amplitude = this.oscillator.volume;
		        this.amplitude.units = Tone.Type.NormalRange;
		        this.amplitude.value = options.amplitude;
		        /**
				 *  @type {Tone.AudioToGain} 
				 *  @private
				 */
		        this._a2g = new Tone.AudioToGain();
		        /**
				 *  @type {Tone.Scale} 
				 *  @private
				 */
		        this._scaler = this.output = new Tone.Scale(options.min, options.max);
		        /**
				 *  the units of the LFO (used for converting)
				 *  @type {string} 
				 *  @private
				 */
		        this._units = Tone.Type.Default;
		        //connect it up
		        this.oscillator.chain(this._a2g, this._scaler);
		        this._readOnly([
		            'amplitude',
		            'frequency',
		            'oscillator'
		        ]);
		    };
		    Tone.extend(Tone.LFO, Tone.Oscillator);
		    /**
			 *  the default parameters
			 *
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.LFO.defaults = {
		        'type': 'sine',
		        'min': 0,
		        'max': 1,
		        'phase': 0,
		        'frequency': '4n',
		        'amplitude': 1
		    };
		    /**
			 *  Start the LFO. 
			 *  @param  {Time} [time=now] the time the LFO will start
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.start = function (time) {
		        this.oscillator.start(time);
		        return this;
		    };
		    /**
			 *  Stop the LFO. 
			 *  @param  {Time} [time=now] the time the LFO will stop
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.stop = function (time) {
		        this.oscillator.stop(time);
		        return this;
		    };
		    /**
			 *  Sync the start/stop/pause to the transport 
			 *  and the frequency to the bpm of the transport
			 *
			 *  @param {Time} [delay=0] the time to delay the start of the
			 *                                LFO from the start of the transport
			 *  @returns {Tone.LFO} this
			 *  @example
			 *  lfo.frequency.value = "8n";
			 *  lfo.sync();
			 *  //the rate of the LFO will always be an eighth note, 
			 *  //even as the tempo changes
			 */
		    Tone.LFO.prototype.sync = function (delay) {
		        this.oscillator.sync(delay);
		        this.oscillator.syncFrequency();
		        return this;
		    };
		    /**
			 *  unsync the LFO from transport control
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.unsync = function () {
		        this.oscillator.unsync();
		        this.oscillator.unsyncFrequency();
		        return this;
		    };
		    /**
			 * The miniumum output of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'min', {
		        get: function () {
		            return this._toUnits(this._scaler.min);
		        },
		        set: function (min) {
		            min = this._fromUnits(min);
		            this._scaler.min = min;
		        }
		    });
		    /**
			 * The maximum output of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'max', {
		        get: function () {
		            return this._toUnits(this._scaler.max);
		        },
		        set: function (max) {
		            max = this._fromUnits(max);
		            this._scaler.max = max;
		        }
		    });
		    /**
			 * The type of the oscillator: sine, square, sawtooth, triangle. 
			 * @memberOf Tone.LFO#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'type', {
		        get: function () {
		            return this.oscillator.type;
		        },
		        set: function (type) {
		            this.oscillator.type = type;
		        }
		    });
		    /**
			 * The phase of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {number}
			 * @name phase
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'phase', {
		        get: function () {
		            return this.oscillator.phase - 90;
		        },
		        set: function (phase) {
		            this.oscillator.phase = phase + 90;
		        }
		    });
		    /**
			 * The output units of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {Tone.Type}
			 * @name units
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'units', {
		        get: function () {
		            return this._units;
		        },
		        set: function (val) {
		            var currentMin = this.min;
		            var currentMax = this.max;
		            //convert the min and the max
		            this._units = val;
		            this.min = currentMin;
		            this.max = currentMax;
		        }
		    });
		    /**
			 *  Connect the output of a ToneNode to an AudioParam, AudioNode, or Tone Node. 
			 *  will get the units from the connected node.
			 *  @param  {Tone | AudioParam | AudioNode} node 
			 *  @param {number} [outputNum=0] optionally which output to connect from
			 *  @param {number} [inputNum=0] optionally which input to connect to
			 *  @returns {Tone.LFO} this
			 *  @private
			 */
		    Tone.LFO.prototype.connect = function (node) {
		        if (node.constructor === Tone.Signal) {
		            this.convert = node.convert;
		            this.units = node.units;
		        }
		        Tone.Signal.prototype.connect.apply(this, arguments);
		        return this;
		    };
		    /**
			 *  private method borroed from Signal converts 
			 *  units from their destination value
			 *  @function
			 *  @private
			 */
		    Tone.LFO.prototype._fromUnits = Tone.Signal.prototype._fromUnits;
		    /**
			 *  private method borroed from Signal converts 
			 *  units to their destination value
			 *  @function
			 *  @private
			 */
		    Tone.LFO.prototype._toUnits = Tone.Signal.prototype._toUnits;
		    /**
			 *  disconnect and dispose
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'amplitude',
		            'frequency',
		            'oscillator'
		        ]);
		        this.oscillator.dispose();
		        this.oscillator = null;
		        this._scaler.dispose();
		        this._scaler = null;
		        this._a2g.dispose();
		        this._a2g = null;
		        this.frequency = null;
		        this.amplitude = null;
		        return this;
		    };
		    return Tone.LFO;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Limiter will limit the loudness of an incoming signal. 
			 *         It is composed of a Tone.Compressor with a fast attack 
			 *         and release. Limiters are commonly used to safeguard against 
			 *         signal clipping. Unlike a compressor, limiters do not provide 
			 *         smooth gain reduction and almost completely prevent 
			 *         additional gain above the threshold.
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {number} threshold The theshold above which the limiting is applied. 
			 *  @example
			 *  var limiter = new Tone.Limiter(-6);
			 */
		    Tone.Limiter = function (threshold) {
		        /**
				 *  the compressor
				 *  @private
				 *  @type {Tone.Compressor}
				 */
		        this._compressor = this.input = this.output = new Tone.Compressor({
		            'attack': 0.001,
		            'decay': 0.001,
		            'threshold': threshold
		        });
		        /**
				 * The threshold of of the limiter
				 * @type {Decibel}
				 * @signal
				 */
		        this.threshold = this._compressor.threshold;
		        this._readOnly('threshold');
		    };
		    Tone.extend(Tone.Limiter);
		    /**
			 *  Clean up.
			 *  @returns {Tone.Limiter} this
			 */
		    Tone.Limiter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._compressor.dispose();
		        this._compressor = null;
		        this._writable('threshold');
		        this.threshold = null;
		        return this;
		    };
		    return Tone.Limiter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Lowpass is a lowpass feedback comb filter. It is similar to 
			 *         Tone.FeedbackCombFilter, but includes a lowpass filter.
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Time|Object} [delayTime] The delay time of the comb filter
			 *  @param {NormalRange=} resonance The resonance (feedback) of the comb filter
			 *  @param {Frequency=} dampening The cutoff of the lowpass filter dampens the
			 *                                signal as it is fedback. 
			 */
		    Tone.LowpassCombFilter = function () {
		        Tone.call(this);
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'resonance',
		            'dampening'
		        ], Tone.LowpassCombFilter.defaults);
		        /**
				 *  the delay node
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delay = this.input = this.context.createDelay(1);
		        /**
				 *  The delayTime of the comb filter. 
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
		        /**
				 *  the lowpass filter
				 *  @type  {BiquadFilterNode}
				 *  @private
				 */
		        this._lowpass = this.output = this.context.createBiquadFilter();
		        this._lowpass.Q.value = 0;
		        this._lowpass.type = 'lowpass';
		        /**
				 *  The dampening control of the feedback
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.dampening = new Tone.Signal(this._lowpass.frequency, Tone.Type.Frequency);
		        this.dampening.value = options.dampening;
		        /**
				 *  the feedback gain
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedback = this.context.createGain();
		        /**
				 *  The amount of feedback of the delayed signal. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.resonance = new Tone.Signal(options.resonance, Tone.Type.NormalRange);
		        //connections
		        this._delay.chain(this._lowpass, this._feedback, this._delay);
		        this.delayTime.connect(this._delay.delayTime);
		        this.resonance.connect(this._feedback.gain);
		        this.dampening.connect(this._lowpass.frequency);
		        this._readOnly([
		            'dampening',
		            'resonance',
		            'delayTime'
		        ]);
		    };
		    Tone.extend(Tone.LowpassCombFilter);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.LowpassCombFilter.defaults = {
		        'delayTime': 0.1,
		        'resonance': 0.5,
		        'dampening': 3000
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.LowpassCombFilter} this
			 */
		    Tone.LowpassCombFilter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'dampening',
		            'resonance',
		            'delayTime'
		        ]);
		        this.dampening.dispose();
		        this.dampening = null;
		        this.resonance.dispose();
		        this.resonance = null;
		        this._delay.disconnect();
		        this._delay = null;
		        this._lowpass.disconnect();
		        this._lowpass = null;
		        this._feedback.disconnect();
		        this._feedback = null;
		        this.delayTime.dispose();
		        this.delayTime = null;
		        return this;
		    };
		    return Tone.LowpassCombFilter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Merge brings two signals into the left and right 
			 *          channels of a single stereo channel.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @example
			 * var merge = new Tone.Merge().toMaster();
			 * //routing a sine tone in the left channel
			 * //and noise in the right channel
			 * var osc = new Tone.Oscillator().connect(merge.left);
			 * var noise = new Tone.Noise().connect(merge.right);
			 * //starting our oscillators
			 * noise.start();
			 * osc.start();
			 */
		    Tone.Merge = function () {
		        Tone.call(this, 2, 0);
		        /**
				 *  The left input channel.
				 *  Alias for <code>input[0]</code>
				 *  @type {GainNode}
				 */
		        this.left = this.input[0] = this.context.createGain();
		        /**
				 *  The right input channel.
				 *  Alias for <code>input[1]</code>.
				 *  @type {GainNode}
				 */
		        this.right = this.input[1] = this.context.createGain();
		        /**
				 *  the merger node for the two channels
				 *  @type {ChannelMergerNode}
				 *  @private
				 */
		        this._merger = this.output = this.context.createChannelMerger(2);
		        //connections
		        this.left.connect(this._merger, 0, 0);
		        this.right.connect(this._merger, 0, 1);
		    };
		    Tone.extend(Tone.Merge);
		    /**
			 *  Clean up.
			 *  @returns {Tone.Merge} this
			 */
		    Tone.Merge.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.left.disconnect();
		        this.left = null;
		        this.right.disconnect();
		        this.right = null;
		        this._merger.disconnect();
		        this._merger = null;
		        return this;
		    };
		    return Tone.Merge;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)
			 *          of an input signal with some averaging applied. 
			 *          It can also get the raw value of the signal or the value in dB. For signal 
			 *          processing, it's better to use Tone.Follower which will produce an audio-rate 
			 *          envelope follower instead of needing to poll the Meter to get the output.
			 *          <br><br>
			 *          Meter was inspired by [Chris Wilsons Volume Meter](https://github.com/cwilso/volume-meter/blob/master/volume-meter.js).
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {number} [channels=1] number of channels being metered
			 *  @param {number} [smoothing=0.8] amount of smoothing applied to the volume
			 *  @param {number} [clipMemory=0.5] number in seconds that a "clip" should be remembered
			 *  @example
			 * var meter = new Tone.Meter();
			 * var mic = new Tone.Microphone().start();
			 * //connect mic to the meter
			 * mic.connect(meter);
			 * //use getLevel or getDb 
			 * //to access meter level
			 * meter.getLevel();
			 */
		    Tone.Meter = function (channels, smoothing, clipMemory) {
		        //extends Unit
		        Tone.call(this);
		        /** 
				 *  The channel count
				 *  @type  {number}
				 *  @private
				 */
		        this._channels = this.defaultArg(channels, 1);
		        /** 
				 *  the smoothing value
				 *  @type  {number}
				 *  @private
				 */
		        this._smoothing = this.defaultArg(smoothing, 0.8);
		        /** 
				 *  the amount of time a clip is remember for. 
				 *  @type  {number}
				 *  @private
				 */
		        this._clipMemory = this.defaultArg(clipMemory, 0.5) * 1000;
		        /** 
				 *  the rms for each of the channels
				 *  @private
				 *  @type {Array}
				 */
		        this._volume = new Array(this._channels);
		        /** 
				 *  the raw values for each of the channels
				 *  @private
				 *  @type {Array}
				 */
		        this._values = new Array(this._channels);
		        //zero out the volume array
		        for (var i = 0; i < this._channels; i++) {
		            this._volume[i] = 0;
		            this._values[i] = 0;
		        }
		        /** 
				 *  last time the values clipped
				 *  @private
				 *  @type {number}
				 */
		        this._lastClip = 0;
		        /** 
				 *  @private
				 *  @type {ScriptProcessorNode}
				 */
		        this._jsNode = this.context.createScriptProcessor(this.bufferSize, this._channels, 1);
		        this._jsNode.onaudioprocess = this._onprocess.bind(this);
		        //so it doesn't get garbage collected
		        this._jsNode.noGC();
		        //signal just passes
		        this.input.connect(this.output);
		        this.input.connect(this._jsNode);
		    };
		    Tone.extend(Tone.Meter);
		    /**
			 *  called on each processing frame
			 *  @private
			 *  @param  {AudioProcessingEvent} event 
			 */
		    Tone.Meter.prototype._onprocess = function (event) {
		        var bufferSize = this._jsNode.bufferSize;
		        var smoothing = this._smoothing;
		        for (var channel = 0; channel < this._channels; channel++) {
		            var input = event.inputBuffer.getChannelData(channel);
		            var sum = 0;
		            var total = 0;
		            var x;
		            var clipped = false;
		            for (var i = 0; i < bufferSize; i++) {
		                x = input[i];
		                if (!clipped && x > 0.95) {
		                    clipped = true;
		                    this._lastClip = Date.now();
		                }
		                total += x;
		                sum += x * x;
		            }
		            var average = total / bufferSize;
		            var rms = Math.sqrt(sum / bufferSize);
		            this._volume[channel] = Math.max(rms, this._volume[channel] * smoothing);
		            this._values[channel] = average;
		        }
		    };
		    /**
			 *  Get the rms of the signal.
			 *  @param  {number} [channel=0] which channel
			 *  @return {number}         the value
			 */
		    Tone.Meter.prototype.getLevel = function (channel) {
		        channel = this.defaultArg(channel, 0);
		        var vol = this._volume[channel];
		        if (vol < 0.00001) {
		            return 0;
		        } else {
		            return vol;
		        }
		    };
		    /**
			 *  Get the raw value of the signal. 
			 *  @param  {number=} channel 
			 *  @return {number}         
			 */
		    Tone.Meter.prototype.getValue = function (channel) {
		        channel = this.defaultArg(channel, 0);
		        return this._values[channel];
		    };
		    /**
			 *  Get the volume of the signal in dB
			 *  @param  {number=} channel 
			 *  @return {Decibels}         
			 */
		    Tone.Meter.prototype.getDb = function (channel) {
		        return this.gainToDb(this.getLevel(channel));
		    };
		    /**
			 * @returns {boolean} if the audio has clipped. The value resets
			 *                       based on the clipMemory defined. 
			 */
		    Tone.Meter.prototype.isClipped = function () {
		        return Date.now() - this._lastClip < this._clipMemory;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Meter} this
			 */
		    Tone.Meter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._jsNode.disconnect();
		        this._jsNode.onaudioprocess = null;
		        this._volume = null;
		        this._values = null;
		        return this;
		    };
		    return Tone.Meter;
		});
		Module(function (Tone) {
		    
		    /**
			 *	@class  Tone.Split splits an incoming signal into left and right channels.
			 *	
			 *  @constructor
			 *  @extends {Tone}
			 *  @example
			 * var split = new Tone.Split();
			 * stereoSignal.connect(split);
			 */
		    Tone.Split = function () {
		        Tone.call(this, 0, 2);
		        /** 
				 *  @type {ChannelSplitterNode}
				 *  @private
				 */
		        this._splitter = this.input = this.context.createChannelSplitter(2);
		        /** 
				 *  Left channel output. 
				 *  Alias for <code>output[0]</code>
				 *  @type {GainNode}
				 */
		        this.left = this.output[0] = this.context.createGain();
		        /**
				 *  Right channel output.
				 *  Alias for <code>output[1]</code>
				 *  @type {GainNode}
				 */
		        this.right = this.output[1] = this.context.createGain();
		        //connections
		        this._splitter.connect(this.left, 0, 0);
		        this._splitter.connect(this.right, 1, 0);
		    };
		    Tone.extend(Tone.Split);
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Split} this
			 */
		    Tone.Split.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._splitter.disconnect();
		        this.left.disconnect();
		        this.right.disconnect();
		        this.left = null;
		        this.right = null;
		        this._splitter = null;
		        return this;
		    };
		    return Tone.Split;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Mid/Side processing separates the the 'mid' signal 
			 *         (which comes out of both the left and the right channel) 
			 *         and the 'side' (which only comes out of the the side channels). <br><br>
			 *         <code>
			 *         Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right<br>
			 *         Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and righ<br>
			 *         </code>
			 *
			 *  @extends {Tone}
			 *  @constructor
			 */
		    Tone.MidSideSplit = function () {
		        Tone.call(this, 0, 2);
		        /**
				 *  split the incoming signal into left and right channels
				 *  @type  {Tone.Split}
				 *  @private
				 */
		        this._split = this.input = new Tone.Split();
		        /**
				 *  The mid send. Connect to mid processing. Alias for
				 *  <code>output[0]</code>
				 *  @type {Tone.Expr}
				 */
		        this.mid = this.output[0] = new Tone.Expr('($0 + $1) * $2');
		        /**
				 *  The side output. Connect to side processing. Alias for
				 *  <code>output[1]</code>
				 *  @type {Tone.Expr}
				 */
		        this.side = this.output[1] = new Tone.Expr('($0 - $1) * $2');
		        this._split.connect(this.mid, 0, 0);
		        this._split.connect(this.mid, 1, 1);
		        this._split.connect(this.side, 0, 0);
		        this._split.connect(this.side, 1, 1);
		        sqrtTwo.connect(this.mid, 0, 2);
		        sqrtTwo.connect(this.side, 0, 2);
		    };
		    Tone.extend(Tone.MidSideSplit);
		    /**
			 *  a constant signal equal to 1 / sqrt(2)
			 *  @type {Number}
			 *  @signal
			 *  @private
			 *  @static
			 */
		    var sqrtTwo = null;
		    Tone._initAudioContext(function () {
		        sqrtTwo = new Tone.Signal(1 / Math.sqrt(2));
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.MidSideSplit} this
			 */
		    Tone.MidSideSplit.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.mid.dispose();
		        this.mid = null;
		        this.side.dispose();
		        this.side = null;
		        this._split.dispose();
		        this._split = null;
		        return this;
		    };
		    return Tone.MidSideSplit;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Mid/Side processing separates the the 'mid' signal 
			 *         (which comes out of both the left and the right channel) 
			 *         and the 'side' (which only comes out of the the side channels). 
			 *         MidSideMerge merges the mid and side signal after they've been seperated
			 *         by Tone.MidSideSplit.<br><br>
			 *         <code>
			 *         Left = (Mid+Side)/sqrt(2);   // obtain left signal from mid and side<br>
			 *         Right = (Mid-Side)/sqrt(2);   // obtain right signal from mid and side<br>
			 *         </code>
			 *
			 *  @extends {Tone.StereoEffect}
			 *  @constructor
			 */
		    Tone.MidSideMerge = function () {
		        Tone.call(this, 2, 0);
		        /**
				 *  The mid signal input. Alias for
				 *  <code>input[0]</code>
				 *  @type  {GainNode}
				 */
		        this.mid = this.input[0] = this.context.createGain();
		        /**
				 *  recombine the mid/side into Left
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._left = new Tone.Expr('($0 + $1) * $2');
		        /**
				 *  The side signal input. Alias for
				 *  <code>input[1]</code>
				 *  @type  {GainNode}
				 */
		        this.side = this.input[1] = this.context.createGain();
		        /**
				 *  recombine the mid/side into Right
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._right = new Tone.Expr('($0 - $1) * $2');
		        /**
				 *  Merge the left/right signal back into a stereo signal.
				 *  @type {Tone.Merge}
				 *  @private
				 */
		        this._merge = this.output = new Tone.Merge();
		        this.mid.connect(this._left, 0, 0);
		        this.side.connect(this._left, 0, 1);
		        this.mid.connect(this._right, 0, 0);
		        this.side.connect(this._right, 0, 1);
		        this._left.connect(this._merge, 0, 0);
		        this._right.connect(this._merge, 0, 1);
		        sqrtTwo.connect(this._left, 0, 2);
		        sqrtTwo.connect(this._right, 0, 2);
		    };
		    Tone.extend(Tone.MidSideMerge);
		    /**
			 *  A constant signal equal to 1 / sqrt(2).
			 *  @type {Number}
			 *  @signal
			 *  @private
			 *  @static
			 */
		    var sqrtTwo = null;
		    Tone._initAudioContext(function () {
		        sqrtTwo = new Tone.Signal(1 / Math.sqrt(2));
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.MidSideMerge} this
			 */
		    Tone.MidSideMerge.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.mid.disconnect();
		        this.mid = null;
		        this.side.disconnect();
		        this.side = null;
		        this._left.dispose();
		        this._left = null;
		        this._right.dispose();
		        this._right = null;
		        this._merge.dispose();
		        this._merge = null;
		        return this;
		    };
		    return Tone.MidSideMerge;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.MidSideCompressor applies two different compressors to the mid
			 *         and side signal components. See Tone.MidSideSplit. 
			 *
			 *  @extends {Tone}
			 *  @param {Object} options The options that are passed to the mid and side
			 *                          compressors. 
			 *  @constructor
			 */
		    Tone.MidSideCompressor = function (options) {
		        options = this.defaultArg(options, Tone.MidSideCompressor.defaults);
		        /**
				 *  the mid/side split
				 *  @type  {Tone.MidSideSplit}
				 *  @private
				 */
		        this._midSideSplit = this.input = new Tone.MidSideSplit();
		        /**
				 *  the mid/side recombination
				 *  @type  {Tone.MidSideMerge}
				 *  @private
				 */
		        this._midSideMerge = this.output = new Tone.MidSideMerge();
		        /**
				 *  The compressor applied to the mid signal
				 *  @type  {Tone.Compressor}
				 */
		        this.mid = new Tone.Compressor(options.mid);
		        /**
				 *  The compressor applied to the side signal
				 *  @type  {Tone.Compressor}
				 */
		        this.side = new Tone.Compressor(options.side);
		        this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);
		        this._midSideSplit.side.chain(this.side, this._midSideMerge.side);
		        this._readOnly([
		            'mid',
		            'side'
		        ]);
		    };
		    Tone.extend(Tone.MidSideCompressor);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MidSideCompressor.defaults = {
		        'mid': {
		            'ratio': 3,
		            'threshold': -24,
		            'release': 0.03,
		            'attack': 0.02,
		            'knee': 16
		        },
		        'side': {
		            'ratio': 6,
		            'threshold': -30,
		            'release': 0.25,
		            'attack': 0.03,
		            'knee': 10
		        }
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.MidSideCompressor} this
			 */
		    Tone.MidSideCompressor.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'mid',
		            'side'
		        ]);
		        this.mid.dispose();
		        this.mid = null;
		        this.side.dispose();
		        this.side = null;
		        this._midSideSplit.dispose();
		        this._midSideSplit = null;
		        this._midSideMerge.dispose();
		        this._midSideMerge = null;
		        return this;
		    };
		    return Tone.MidSideCompressor;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Mono coerces the incoming mono or stereo signal into a mono signal
			 *         where both left and right channels have the same value. This can be useful 
			 *         for [stereo imaging](https://en.wikipedia.org/wiki/Stereo_imaging).
			 *
			 *  @extends {Tone}
			 *  @constructor
			 */
		    Tone.Mono = function () {
		        Tone.call(this, 1, 0);
		        /**
				 *  merge the signal
				 *  @type {Tone.Merge}
				 *  @private
				 */
		        this._merge = this.output = new Tone.Merge();
		        this.input.connect(this._merge, 0, 0);
		        this.input.connect(this._merge, 0, 1);
		        this.input.gain.value = this.dbToGain(-10);
		    };
		    Tone.extend(Tone.Mono);
		    /**
			 *  clean up
			 *  @returns {Tone.Mono} this
			 */
		    Tone.Mono.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._merge.dispose();
		        this._merge = null;
		        return this;
		    };
		    return Tone.Mono;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class A compressor with seperate controls over low/mid/high dynamics
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Object} options The low/mid/high compressor settings.
			 *  @example
			 *  var multiband = new Tone.MultibandCompressor({
			 *  	"lowFrequency" : 200,
			 *  	"highFrequency" : 1300
			 *  	"low" : {
			 *  		"threshold" : -12
			 *  	}
			 *  })
			 */
		    Tone.MultibandCompressor = function (options) {
		        options = this.defaultArg(arguments, Tone.MultibandCompressor.defaults);
		        /**
				 *  split the incoming signal into high/mid/low
				 *  @type {Tone.MultibandSplit}
				 *  @private
				 */
		        this._splitter = this.input = new Tone.MultibandSplit({
		            'lowFrequency': options.lowFrequency,
		            'highFrequency': options.highFrequency
		        });
		        /**
				 *  low/mid crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.lowFrequency = this._splitter.lowFrequency;
		        /**
				 *  mid/high crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.highFrequency = this._splitter.highFrequency;
		        /**
				 *  the output
				 *  @type {GainNode}
				 *  @private
				 */
		        this.output = this.context.createGain();
		        /**
				 *  The compressor applied to the low frequencies.
				 *  @type {Tone.Compressor}
				 */
		        this.low = new Tone.Compressor(options.low);
		        /**
				 *  The compressor applied to the mid frequencies.
				 *  @type {Tone.Compressor}
				 */
		        this.mid = new Tone.Compressor(options.mid);
		        /**
				 *  The compressor applied to the high frequencies.
				 *  @type {Tone.Compressor}
				 */
		        this.high = new Tone.Compressor(options.high);
		        //connect the compressor
		        this._splitter.low.chain(this.low, this.output);
		        this._splitter.mid.chain(this.mid, this.output);
		        this._splitter.high.chain(this.high, this.output);
		        this._readOnly([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		    };
		    Tone.extend(Tone.MultibandCompressor);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MultibandCompressor.defaults = {
		        'low': Tone.Compressor.defaults,
		        'mid': Tone.Compressor.defaults,
		        'high': Tone.Compressor.defaults,
		        'lowFrequency': 250,
		        'highFrequency': 2000
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.MultibandCompressor} this
			 */
		    Tone.MultibandCompressor.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._splitter.dispose();
		        this._writable([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		        this.low.dispose();
		        this.mid.dispose();
		        this.high.dispose();
		        this._splitter = null;
		        this.low = null;
		        this.mid = null;
		        this.high = null;
		        this.lowFrequency = null;
		        this.highFrequency = null;
		        return this;
		    };
		    return Tone.MultibandCompressor;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Maps a NormalRange [0, 1] to an AudioRange [-1, 1]. 
			 *         See also Tone.AudioToGain. 
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @example
			 * var g2a = new Tone.GainToAudio();
			 */
		    Tone.GainToAudio = function () {
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
		            return Math.abs(x) * 2 - 1;
		        });
		    };
		    Tone.extend(Tone.GainToAudio, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.GainToAudio} this
			 */
		    Tone.GainToAudio.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._norm.dispose();
		        this._norm = null;
		        return this;
		    };
		    return Tone.GainToAudio;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Panner is an equal power Left/Right Panner and does not
			 *  support 3D. Panner uses the StereoPannerNode when available. 
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {NormalRange} [initialPan=0.5] The initail panner value (defaults to 0.5 = center)
			 *  @example
			 *  //pan the input signal hard right. 
			 *  var panner = new Tone.Panner(1);
			 */
		    Tone.Panner = function (initialPan) {
		        Tone.call(this);
		        /**
				 *  indicates if the panner is using the new StereoPannerNode internally
				 *  @type  {boolean}
				 *  @private
				 */
		        this._hasStereoPanner = this.isFunction(this.context.createStereoPanner);
		        if (this._hasStereoPanner) {
		            /**
					 *  the panner node
					 *  @type {StereoPannerNode}
					 *  @private
					 */
		            this._panner = this.input = this.output = this.context.createStereoPanner();
		            /**
					 *  The pan control. 0 = hard left, 1 = hard right. 
					 *  @type {NormalRange}
					 *  @signal
					 */
		            this.pan = new Tone.Signal(0, Tone.Type.NormalRange);
		            /**
					 *  scale the pan signal to between -1 and 1
					 *  @type {Tone.WaveShaper}
					 *  @private
					 */
		            this._scalePan = new Tone.GainToAudio();
		            //connections
		            this.pan.chain(this._scalePan, this._panner.pan);
		        } else {
		            /**
					 *  the dry/wet knob
					 *  @type {Tone.CrossFade}
					 *  @private
					 */
		            this._crossFade = new Tone.CrossFade();
		            /**
					 *  @type {Tone.Merge}
					 *  @private
					 */
		            this._merger = this.output = new Tone.Merge();
		            /**
					 *  @type {Tone.Split}
					 *  @private
					 */
		            this._splitter = this.input = new Tone.Split();
		            /**
					 *  The pan control. 0 = hard left, 1 = hard right. 
					 *  @type {NormalRange}
					 *  @signal
					 */
		            this.pan = this._crossFade.fade;
		            //CONNECTIONS:
		            //left channel is a, right channel is b
		            this._splitter.connect(this._crossFade, 0, 0);
		            this._splitter.connect(this._crossFade, 1, 1);
		            //merge it back together
		            this._crossFade.a.connect(this._merger, 0, 0);
		            this._crossFade.b.connect(this._merger, 0, 1);
		        }
		        //initial value
		        this.pan.value = this.defaultArg(initialPan, 0.5);
		        this._readOnly('pan');
		    };
		    Tone.extend(Tone.Panner);
		    /**
			 *  Clean up.
			 *  @returns {Tone.Panner} this
			 */
		    Tone.Panner.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('pan');
		        if (this._hasStereoPanner) {
		            this._panner.disconnect();
		            this._panner = null;
		            this.pan.dispose();
		            this.pan = null;
		            this._scalePan.dispose();
		            this._scalePan = null;
		        } else {
		            this._crossFade.dispose();
		            this._crossFade = null;
		            this._splitter.dispose();
		            this._splitter = null;
		            this._merger.dispose();
		            this._merger = null;
		            this.pan = null;
		        }
		        return this;
		    };
		    return Tone.Panner;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Volume is a simple volume node, useful for creating a volume fader. 
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Decibels} [volume=0] the initial volume
			 *  @example
			 * var vol = new Tone.Volume(-12);
			 * instrument.chain(vol, Tone.Master);
			 */
		    Tone.Volume = function (volume) {
		        /**
				 * the output node
				 * @type {GainNode}
				 * @private
				 */
		        this.output = this.input = this.context.createGain();
		        /**
				 *  The volume control in decibels. 
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.volume = new Tone.Signal(this.output.gain, Tone.Type.Decibels);
		        this.volume.value = this.defaultArg(volume, 0);
		        this._readOnly('volume');
		    };
		    Tone.extend(Tone.Volume);
		    /**
			 *  clean up
			 *  @returns {Tone.Volume} this
			 */
		    Tone.Volume.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('volume');
		        this.volume.dispose();
		        this.volume = null;
		        return this;
		    };
		    return Tone.Volume;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.PanVol is a Tone.Panner and Tone.Volume in one.
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {NormalRange} pan the initial pan
			 *  @param {number} volume The output volume. 
			 *  @example
			 * //pan the incoming signal left and drop the volume
			 * var panVol = new Tone.PanVol(0.25, -12);
			 */
		    Tone.PanVol = function (pan, volume) {
		        /**
				 *  The panning node
				 *  @type {Tone.Panner}
				 *  @private
				 */
		        this._panner = this.input = new Tone.Panner(pan);
		        /**
				 *  The L/R panning control.
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.pan = this._panner.pan;
		        /**
				 * The volume object. 
				 * @type {Tone.Volume}
				 * @signal
				 * @private
				 */
		        this._volume = this.output = new Tone.Volume(volume);
		        /**
				 *  The volume control in decibels. 
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.volume = this._volume.volume;
		        //connections
		        this._panner.connect(this._volume);
		        this._readOnly([
		            'pan',
		            'volume'
		        ]);
		    };
		    Tone.extend(Tone.PanVol);
		    /**
			 *  clean up
			 *  @returns {Tone.PanVol} this
			 */
		    Tone.PanVol.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'pan',
		            'volume'
		        ]);
		        this._panner.dispose();
		        this._panner = null;
		        this._volume.dispose();
		        this._volume = null;
		        this.pan = null;
		        this.volume = null;
		        return this;
		    };
		    return Tone.PanVol;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.ScaledEnvelop is an envelope which can be scaled 
			 *         to any range. It's useful for applying an envelope 
			 *         to a frequency or any other non-NormalRange signal 
			 *         parameter. 
			 *
			 *  @extends {Tone.Envelope}
			 *  @constructor
			 *  @param {Time|Object} [attack]	the attack time in seconds
			 *  @param {Time} [decay]	the decay time in seconds
			 *  @param {number} [sustain] 	a percentage (0-1) of the full amplitude
			 *  @param {Time} [release]	the release time in seconds
			 *  @example
			 *  var scaledEnv = new Tone.ScaledEnvelope({
			 *  	"attack" : 0.2,
			 *  	"min" : 200,
			 *  	"max" : 2000
			 *  });
			 *  scaledEnv.connect(oscillator.frequency);
			 */
		    Tone.ScaledEnvelope = function () {
		        //get all of the defaults
		        var options = this.optionsObject(arguments, [
		            'attack',
		            'decay',
		            'sustain',
		            'release'
		        ], Tone.Envelope.defaults);
		        Tone.Envelope.call(this, options);
		        options = this.defaultArg(options, Tone.ScaledEnvelope.defaults);
		        /** 
				 *  scale the incoming signal by an exponent
				 *  @type {Tone.Pow}
				 *  @private
				 */
		        this._exp = this.output = new Tone.Pow(options.exponent);
		        /**
				 *  scale the signal to the desired range
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = this.output = new Tone.Scale(options.min, options.max);
		        this._sig.chain(this._exp, this._scale);
		    };
		    Tone.extend(Tone.ScaledEnvelope, Tone.Envelope);
		    /**
			 *  the default parameters
			 *  @static
			 */
		    Tone.ScaledEnvelope.defaults = {
		        'min': 0,
		        'max': 1,
		        'exponent': 1
		    };
		    /**
			 * The envelope's min output value. This is the value which it
			 * starts at. 
			 * @memberOf Tone.ScaledEnvelope#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'min', {
		        get: function () {
		            return this._scale.min;
		        },
		        set: function (min) {
		            this._scale.min = min;
		        }
		    });
		    /**
			 * The envelope's max output value. In other words, the value
			 * at the peak of the attack portion of the envelope. 
			 * @memberOf Tone.ScaledEnvelope#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'max', {
		        get: function () {
		            return this._scale.max;
		        },
		        set: function (max) {
		            this._scale.max = max;
		        }
		    });
		    /**
			 * The envelope's exponent value. 
			 * @memberOf Tone.ScaledEnvelope#
			 * @type {number}
			 * @name exponent
			 */
		    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'exponent', {
		        get: function () {
		            return this._exp.value;
		        },
		        set: function (exp) {
		            this._exp.value = exp;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.ScaledEnvelope} this
			 */
		    Tone.ScaledEnvelope.prototype.dispose = function () {
		        Tone.Envelope.prototype.dispose.call(this);
		        this._scale.dispose();
		        this._scale = null;
		        this._exp.dispose();
		        this._exp = null;
		        return this;
		    };
		    return Tone.ScaledEnvelope;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Buffer loading and storage. Tone.Buffer is used internally by all 
			 *          classes that make requests for audio files such as Tone.Player,
			 *          Tone.Sampler and Tone.Convolver.
			 *          <br><br>
			 *          Aside from load callbacks from individual buffers, Tone.Buffer 
			 *  		provides static methods which keep track of the loading progress 
			 *  		of all of the buffers. These methods are Tone.Buffer.onload, Tone.Buffer.onprogress,
			 *  		and Tone.Buffer.onerror. 
			 *
			 *  @constructor 
			 *  @extends {Tone}
			 *  @param {AudioBuffer|string} url The url to load, or the audio buffer to set. 
			 *  @param {function=} onload A callback which is invoked after the buffer is loaded. 
			 *                            It's recommended to use Tone.Buffer.onload instead 
			 *                            since it will give you a callback when ALL buffers are loaded.
			 *  @example
			 * var buffer = new Tone.Buffer("path/to/sound.mp3", function(){
			 * 	//the buffer is now available.
			 * 	var buff = buffer.get();
			 * });
			 */
		    Tone.Buffer = function () {
		        var options = this.optionsObject(arguments, [
		            'url',
		            'onload'
		        ], Tone.Buffer.defaults);
		        /**
				 *  stores the loaded AudioBuffer
				 *  @type {AudioBuffer}
				 *  @private
				 */
		        this._buffer = null;
		        /**
				 *  indicates if the buffer should be reversed or not
				 *  @type {boolean}
				 *  @private
				 */
		        this._reversed = options.reverse;
		        /**
				 *  The url of the buffer. <code>undefined</code> if it was 
				 *  constructed with a buffer
				 *  @type {string}
				 *  @readOnly
				 */
		        this.url = undefined;
		        /**
				 *  Indicates if the buffer is loaded or not. 
				 *  @type {boolean}
				 *  @readOnly
				 */
		        this.loaded = false;
		        /**
				 *  The callback to invoke when everything is loaded. 
				 *  @type {function}
				 */
		        this.onload = options.onload.bind(this, this);
		        if (options.url instanceof AudioBuffer) {
		            this._buffer.set(options.url);
		            this.onload(this);
		        } else if (typeof options.url === 'string') {
		            this.url = options.url;
		            Tone.Buffer._addToQueue(options.url, this);
		        }
		    };
		    Tone.extend(Tone.Buffer);
		    /**
			 *  the default parameters
			 *  @type {Object}
			 */
		    Tone.Buffer.defaults = {
		        'url': undefined,
		        'onload': Tone.noOp,
		        'reverse': false
		    };
		    /**
			 *  Pass in an AudioBuffer or Tone.Buffer to set the value
			 *  of this buffer.
			 *  @param {AudioBuffer|Tone.Buffer} buffer the buffer
			 *  @returns {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype.set = function (buffer) {
		        if (buffer instanceof Tone.Buffer) {
		            this._buffer = buffer.get();
		        } else {
		            this._buffer = buffer;
		        }
		        this.loaded = true;
		        return this;
		    };
		    /**
			 *  @return {AudioBuffer} The audio buffer stored in the object.
			 */
		    Tone.Buffer.prototype.get = function () {
		        return this._buffer;
		    };
		    /**
			 *  Load url into the buffer. 
			 *  @param {String} url The url to load
			 *  @param {Function=} callback The callback to invoke on load. 
			 *                              don't need to set if `onload` is
			 *                              already set.
			 *  @returns {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype.load = function (url, callback) {
		        this.url = url;
		        this.onload = this.defaultArg(callback, this.onload);
		        Tone.Buffer._addToQueue(url, this);
		        return this;
		    };
		    /**
			 *  dispose and disconnect
			 *  @returns {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        Tone.Buffer._removeFromQueue(this);
		        this._buffer = null;
		        this.onload = Tone.Buffer.defaults.onload;
		        return this;
		    };
		    /**
			 * The duration of the buffer. 
			 * @memberOf Tone.Buffer#
			 * @type {number}
			 * @name duration
			 * @readOnly
			 */
		    Object.defineProperty(Tone.Buffer.prototype, 'duration', {
		        get: function () {
		            if (this._buffer) {
		                return this._buffer.duration;
		            } else {
		                return 0;
		            }
		        }
		    });
		    /**
			 *  Reverse the buffer.
			 *  @private
			 *  @return {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype._reverse = function () {
		        if (this.loaded) {
		            for (var i = 0; i < this._buffer.numberOfChannels; i++) {
		                Array.prototype.reverse.call(this._buffer.getChannelData(i));
		            }
		        }
		        return this;
		    };
		    /**
			 * Reverse the buffer.
			 * @memberOf Tone.Buffer#
			 * @type {boolean}
			 * @name reverse
			 */
		    Object.defineProperty(Tone.Buffer.prototype, 'reverse', {
		        get: function () {
		            return this._reversed;
		        },
		        set: function (rev) {
		            if (this._reversed !== rev) {
		                this._reversed = rev;
		                this._reverse();
		            }
		        }
		    });
		    ///////////////////////////////////////////////////////////////////////////
		    // STATIC METHODS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  the static queue for all of the xhr requests
			 *  @type {Array}
			 *  @private
			 */
		    Tone.Buffer._queue = [];
		    /**
			 *  the array of current downloads
			 *  @type {Array}
			 *  @private
			 */
		    Tone.Buffer._currentDownloads = [];
		    /**
			 *  the total number of downloads
			 *  @type {number}
			 *  @private
			 */
		    Tone.Buffer._totalDownloads = 0;
		    /**
			 *  the maximum number of simultaneous downloads
			 *  @static
			 *  @type {number}
			 */
		    Tone.Buffer.MAX_SIMULTANEOUS_DOWNLOADS = 6;
		    /**
			 *  Adds a file to be loaded to the loading queue
			 *  @param   {string}   url      the url to load
			 *  @param   {function} callback the callback to invoke once it's loaded
			 *  @private
			 */
		    Tone.Buffer._addToQueue = function (url, buffer) {
		        Tone.Buffer._queue.push({
		            url: url,
		            Buffer: buffer,
		            progress: 0,
		            xhr: null
		        });
		        this._totalDownloads++;
		        Tone.Buffer._next();
		    };
		    /**
			 *  Remove an object from the queue's (if it's still there)
			 *  Abort the XHR if it's in progress
			 *  @param {Tone.Buffer} buffer the buffer to remove
			 *  @private
			 */
		    Tone.Buffer._removeFromQueue = function (buffer) {
		        var i;
		        for (i = 0; i < Tone.Buffer._queue.length; i++) {
		            var q = Tone.Buffer._queue[i];
		            if (q.Buffer === buffer) {
		                Tone.Buffer._queue.splice(i, 1);
		            }
		        }
		        for (i = 0; i < Tone.Buffer._currentDownloads.length; i++) {
		            var dl = Tone.Buffer._currentDownloads[i];
		            if (dl.Buffer === buffer) {
		                Tone.Buffer._currentDownloads.splice(i, 1);
		                dl.xhr.abort();
		                dl.xhr.onprogress = null;
		                dl.xhr.onload = null;
		                dl.xhr.onerror = null;
		            }
		        }
		    };
		    /**
			 *  load the next buffer in the queue
			 *  @private
			 */
		    Tone.Buffer._next = function () {
		        if (Tone.Buffer._queue.length > 0) {
		            if (Tone.Buffer._currentDownloads.length < Tone.Buffer.MAX_SIMULTANEOUS_DOWNLOADS) {
		                var next = Tone.Buffer._queue.shift();
		                Tone.Buffer._currentDownloads.push(next);
		                next.xhr = Tone.Buffer.load(next.url, function (buffer) {
		                    //remove this one from the queue
		                    var index = Tone.Buffer._currentDownloads.indexOf(next);
		                    Tone.Buffer._currentDownloads.splice(index, 1);
		                    next.Buffer.set(buffer);
		                    if (next.Buffer._reversed) {
		                        next.Buffer._reverse();
		                    }
		                    next.Buffer.onload(next.Buffer);
		                    Tone.Buffer._onprogress();
		                    Tone.Buffer._next();
		                });
		                next.xhr.onprogress = function (event) {
		                    next.progress = event.loaded / event.total;
		                    Tone.Buffer._onprogress();
		                };
		                next.xhr.onerror = Tone.Buffer.onerror;
		            }
		        } else if (Tone.Buffer._currentDownloads.length === 0) {
		            Tone.Buffer.onload();
		            //reset the downloads
		            Tone.Buffer._totalDownloads = 0;
		        }
		    };
		    /**
			 *  internal progress event handler
			 *  @private
			 */
		    Tone.Buffer._onprogress = function () {
		        var curretDownloadsProgress = 0;
		        var currentDLLen = Tone.Buffer._currentDownloads.length;
		        var inprogress = 0;
		        if (currentDLLen > 0) {
		            for (var i = 0; i < currentDLLen; i++) {
		                var dl = Tone.Buffer._currentDownloads[i];
		                curretDownloadsProgress += dl.progress;
		            }
		            inprogress = curretDownloadsProgress;
		        }
		        var currentDownloadProgress = currentDLLen - inprogress;
		        var completed = Tone.Buffer._totalDownloads - Tone.Buffer._queue.length - currentDownloadProgress;
		        Tone.Buffer.onprogress(completed / Tone.Buffer._totalDownloads);
		    };
		    /**
			 *  Makes an xhr reqest for the selected url then decodes
			 *  the file as an audio buffer. Invokes
			 *  the callback once the audio buffer loads.
			 *  @param {string} url The url of the buffer to load.
			 *                      filetype support depends on the
			 *                      browser.
			 *  @param {function} callback The function to invoke when the url is loaded. 
			 *  @returns {XMLHttpRequest} returns the XHR
			 */
		    Tone.Buffer.load = function (url, callback) {
		        var request = new XMLHttpRequest();
		        request.open('GET', url, true);
		        request.responseType = 'arraybuffer';
		        // decode asynchronously
		        request.onload = function () {
		            Tone.context.decodeAudioData(request.response, function (buff) {
		                if (!buff) {
		                    throw new Error('could not decode audio data:' + url);
		                }
		                callback(buff);
		            });
		        };
		        //send the request
		        request.send();
		        return request;
		    };
		    /**
			 *  Callback when all of the buffers in the queue have loaded
			 *  @static
			 *  @function
			 *  @example
			 * //invoked when all of the queued samples are done loading
			 * Tone.Buffer.onload = function(){
			 * 	console.log("everything is loaded");
			 * };
			 */
		    Tone.Buffer.onload = Tone.noOp;
		    /**
			 *  Callback function is invoked with the progress of all of the loads in the queue. 
			 *  The value passed to the callback is between 0-1.
			 *  @static
			 *  @param {Number} percent The progress between 0 and 1. 
			 *  @function
			 *  @example
			 * Tone.Buffer.onprogress = function(percent){
			 * 	console.log("progress:" + (percent * 100).toFixed(1) + "%");
			 * };
			 */
		    Tone.Buffer.onprogress = Tone.noOp;
		    /**
			 *  Callback if one of the buffers in the queue encounters an error. The error
			 *  is passed in as the argument. 
			 *  @static
			 *  @param {Error} err
			 *  @function
			 *  @example
			 * Tone.Buffer.onerror = function(e){
			 * 	console.log("there was an error while loading the buffers: "+e);
			 * }
			 */
		    Tone.Buffer.onerror = Tone.noOp;
		    return Tone.Buffer;
		});
		Module(function (Tone) {
		    
		    /**
			 *  buses are another way of routing audio
			 *
			 *  augments Tone.prototype to include send and recieve
			 */
		    /**
			  *  All of the routes
			  *  
			  *  @type {Object}
			  *  @static
			  *  @private
			  */
		    var Buses = {};
		    /**
			 *  Send this signal to the channel name. 
			 *  @param  {string} channelName A named channel to send the signal to.
			 *  @param  {Decibels} amount The amount of the source to send to the bus. 
			 *  @return {GainNode} The gain node which connects this node to the desired channel. 
			 *                     Can be used to adjust the levels of the send.
			 *  @example
			 * source.send("reverb", -12);
			 */
		    Tone.prototype.send = function (channelName, amount) {
		        if (!Buses.hasOwnProperty(channelName)) {
		            Buses[channelName] = this.context.createGain();
		        }
		        var sendKnob = this.context.createGain();
		        sendKnob.gain.value = this.dbToGain(this.defaultArg(amount, 1));
		        this.output.chain(sendKnob, Buses[channelName]);
		        return sendKnob;
		    };
		    /**
			 *  Recieve the input from the desired channelName to the input
			 *
			 *  @param  {string} channelName A named channel to send the signal to.
			 *  @param {AudioNode} [input] If no input is selected, the
			 *                                         input of the current node is
			 *                                         chosen. 
			 *  @returns {Tone} this
			 *  @example
			 * reverbEffect.receive("reverb");
			 */
		    Tone.prototype.receive = function (channelName, input) {
		        if (!Buses.hasOwnProperty(channelName)) {
		            Buses[channelName] = this.context.createGain();
		        }
		        if (this.isUndef(input)) {
		            input = this.input;
		        }
		        Buses[channelName].connect(input);
		        return this;
		    };
		    return Tone;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A timed note. Creating a note will register a callback 
			 *          which will be invoked on the channel at the time with
			 *          whatever value was specified. 
			 *
			 *  @constructor
			 *  @param {number|string} channel the channel name of the note
			 *  @param {Time} time the time when the note will occur
			 *  @param {string|number|Object|Array} value the value of the note
			 */
		    Tone.Note = function (channel, time, value) {
		        /**
				 *  the value of the note. This value is returned
				 *  when the channel callback is invoked.
				 *  
				 *  @type {string|number|Object}
				 */
		        this.value = value;
		        /**
				 *  the channel name or number
				 *  
				 *  @type {string|number}
				 *  @private
				 */
		        this._channel = channel;
		        /**
				 *  an internal reference to the id of the timeline
				 *  callback which is set. 
				 *  
				 *  @type {number}
				 *  @private
				 */
		        this._timelineID = Tone.Transport.setTimeline(this._trigger.bind(this), time);
		    };
		    /**
			 *  invoked by the timeline
			 *  @private
			 *  @param {number} time the time at which the note should play
			 */
		    Tone.Note.prototype._trigger = function (time) {
		        //invoke the callback
		        channelCallbacks(this._channel, time, this.value);
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Note} this
			 */
		    Tone.Note.prototype.dispose = function () {
		        Tone.Tranport.clearTimeline(this._timelineID);
		        this.value = null;
		        return this;
		    };
		    /**
			 *  @private
			 *  @static
			 *  @type {Object}
			 */
		    var NoteChannels = {};
		    /**
			 *  invoke all of the callbacks on a specific channel
			 *  @private
			 */
		    function channelCallbacks(channel, time, value) {
		        if (NoteChannels.hasOwnProperty(channel)) {
		            var callbacks = NoteChannels[channel];
		            for (var i = 0, len = callbacks.length; i < len; i++) {
		                var callback = callbacks[i];
		                if (Array.isArray(value)) {
		                    callback.apply(window, [time].concat(value));
		                } else {
		                    callback(time, value);
		                }
		            }
		        }
		    }
		    /**
			 *  listen to a specific channel, get all of the note callbacks
			 *  @static
			 *  @param {string|number} channel the channel to route note events from
			 *  @param {function(*)} callback callback to be invoked when a note will occur
			 *                                        on the specified channel
			 */
		    Tone.Note.route = function (channel, callback) {
		        if (NoteChannels.hasOwnProperty(channel)) {
		            NoteChannels[channel].push(callback);
		        } else {
		            NoteChannels[channel] = [callback];
		        }
		    };
		    /**
			 *  Remove a previously routed callback from a channel. 
			 *  @static
			 *  @param {string|number} channel The channel to unroute note events from
			 *  @param {function(*)} callback Callback which was registered to the channel.
			 */
		    Tone.Note.unroute = function (channel, callback) {
		        if (NoteChannels.hasOwnProperty(channel)) {
		            var channelCallback = NoteChannels[channel];
		            var index = channelCallback.indexOf(callback);
		            if (index !== -1) {
		                NoteChannels[channel].splice(index, 1);
		            }
		        }
		    };
		    /**
			 *  Parses a score and registers all of the notes along the timeline. 
			 *  <br><br>
			 *  Scores are a JSON object with instruments at the top level
			 *  and an array of time and values. The value of a note can be 0 or more 
			 *  parameters. 
			 *  <br><br>
			 *  The only requirement for the score format is that the time is the first (or only)
			 *  value in the array. All other values are optional and will be passed into the callback
			 *  function registered using `Note.route(channelName, callback)`.
			 *  <br><br>
			 *  To convert MIDI files to score notation, take a look at utils/MidiToScore.js
			 *
			 *  @example
			 * //an example JSON score which sets up events on channels
			 * var score = { 
			 * 	"synth"  : [["0", "C3"], ["0:1", "D3"], ["0:2", "E3"], ... ],
			 * 	"bass"  : [["0", "C2"], ["1:0", "A2"], ["2:0", "C2"], ["3:0", "A2"], ... ],
			 * 	"kick"  : ["0", "0:2", "1:0", "1:2", "2:0", ... ],
			 * 	//...
			 * };
			 * //parse the score into Notes
			 * Tone.Note.parseScore(score);
			 * //route all notes on the "synth" channel
			 * Tone.Note.route("synth", function(time, note){
			 * 	//trigger synth
			 * });
			 *  @static
			 *  @param {Object} score
			 *  @return {Array} an array of all of the notes that were created
			 */
		    Tone.Note.parseScore = function (score) {
		        var notes = [];
		        for (var inst in score) {
		            var part = score[inst];
		            if (inst === 'tempo') {
		                Tone.Transport.bpm.value = part;
		            } else if (inst === 'timeSignature') {
		                Tone.Transport.timeSignature = part[0] / (part[1] / 4);
		            } else if (Array.isArray(part)) {
		                for (var i = 0; i < part.length; i++) {
		                    var noteDescription = part[i];
		                    var note;
		                    if (Array.isArray(noteDescription)) {
		                        var time = noteDescription[0];
		                        var value = noteDescription.slice(1);
		                        note = new Tone.Note(inst, time, value);
		                    } else {
		                        note = new Tone.Note(inst, noteDescription);
		                    }
		                    notes.push(note);
		                }
		            } else {
		                throw new TypeError('score parts must be Arrays');
		            }
		        }
		        return notes;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	MUSIC NOTES
		    //	
		    //	Augments Tone.prototype to include note methods
		    ///////////////////////////////////////////////////////////////////////////
		    var noteToIndex = {
		        'c': 0,
		        'c#': 1,
		        'db': 1,
		        'd': 2,
		        'd#': 3,
		        'eb': 3,
		        'e': 4,
		        'f': 5,
		        'f#': 6,
		        'gb': 6,
		        'g': 7,
		        'g#': 8,
		        'ab': 8,
		        'a': 9,
		        'a#': 10,
		        'bb': 10,
		        'b': 11
		    };
		    var noteIndexToNote = [
		        'C',
		        'C#',
		        'D',
		        'D#',
		        'E',
		        'F',
		        'F#',
		        'G',
		        'G#',
		        'A',
		        'A#',
		        'B'
		    ];
		    var middleC = 261.6255653005986;
		    /**
			 *  Convert a note name to frequency. 
			 *  @param  {string} note
			 *  @return {number}     
			 *  @example
			 * var freq = tone.noteToFrequency("A4"); //returns 440
			 */
		    Tone.prototype.noteToFrequency = function (note) {
		        //break apart the note by frequency and octave
		        var parts = note.split(/(\d+)/);
		        if (parts.length === 3) {
		            var index = noteToIndex[parts[0].toLowerCase()];
		            var octave = parts[1];
		            var noteNumber = index + parseInt(octave, 10) * 12;
		            return Math.pow(2, (noteNumber - 48) / 12) * middleC;
		        } else {
		            return 0;
		        }
		    };
		    /**
			 *  Test if a string is in note format: i.e. "C4". 
			 *  @param  {string|number}  note The note to test
			 *  @return {boolean}      true if it's in the form of a note
			 *  @method isNotation
			 *  @lends Tone.prototype.isNote
			 *  @function
			 */
		    Tone.prototype.isNote = function () {
		        var noteFormat = new RegExp(/[a-g]{1}([b#]{1}|[b#]{0})[0-9]+$/i);
		        return function (note) {
		            if (typeof note === 'string') {
		                note = note.toLowerCase();
		            }
		            return noteFormat.test(note);
		        };
		    }();
		    /**
			 *  A pointer to the previous toFrequency method
			 *  @private
			 *  @function
			 */
		    Tone.prototype._overwrittenToFrequency = Tone.prototype.toFrequency;
		    /**
			 *  A method which accepts frequencies in the form
			 *  of notes (`"C#4"`), frequencies as strings ("49hz"), frequency numbers,
			 *  or Time and converts them to their frequency as a number in hertz.
			 *  @param  {Frequency} note the note name or notation
			 *  @param {number=} 	now 	if passed in, this number will be 
			 *                        		used for all 'now' relative timings
			 *  @return {number}      the frequency as a number
			 */
		    Tone.prototype.toFrequency = function (note, now) {
		        if (this.isNote(note)) {
		            note = this.noteToFrequency(note);
		        }
		        return this._overwrittenToFrequency(note, now);
		    };
		    /**
			 *  Convert a frequency to a note name (i.e. A4, C#5).
			 *  @param  {number} freq
			 *  @return {string}         
			 */
		    Tone.prototype.frequencyToNote = function (freq) {
		        var log = Math.log(freq / middleC) / Math.LN2;
		        var noteNumber = Math.round(12 * log) + 48;
		        var octave = Math.floor(noteNumber / 12);
		        var noteName = noteIndexToNote[noteNumber % 12];
		        return noteName + octave.toString();
		    };
		    /**
			 *  Convert an interval (in semitones) to a frequency ratio.
			 *
			 *  @param  {Interval} interval the number of semitones above the base note
			 *  @return {number}          the frequency ratio
			 *  @example
			 * tone.intervalToFrequencyRatio(0); // returns 1
			 * tone.intervalToFrequencyRatio(12); // returns 2
			 */
		    Tone.prototype.intervalToFrequencyRatio = function (interval) {
		        return Math.pow(2, interval / 12);
		    };
		    /**
			 *  Convert a midi note number into a note name. 
			 *
			 *  @param  {MIDI} midiNumber the midi note number
			 *  @return {string}            the note's name and octave
			 *  @example
			 * tone.midiToNote(60); // returns "C3"
			 */
		    Tone.prototype.midiToNote = function (midiNumber) {
		        var octave = Math.floor(midiNumber / 12) - 2;
		        var note = midiNumber % 12;
		        return noteIndexToNote[note] + octave;
		    };
		    /**
			 *  Convert a note to it's midi value. 
			 *
			 *  @param  {string} note the note name (i.e. "C3")
			 *  @return {MIDI} the midi value of that note
			 *  @example
			 * tone.noteToMidi("C3"); // returns 60
			 */
		    Tone.prototype.noteToMidi = function (note) {
		        //break apart the note by frequency and octave
		        var parts = note.split(/(\d+)/);
		        if (parts.length === 3) {
		            var index = noteToIndex[parts[0].toLowerCase()];
		            var octave = parts[1];
		            return index + (parseInt(octave, 10) + 2) * 12;
		        } else {
		            return 0;
		        }
		    };
		    return Tone.Note;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.PulseOscillator is a pulse oscillator with control over pulse width,
			 *         also known as the duty cycle. At 50% duty cycle (width = 0.5) the wave is 
			 *         a square and only odd-numbered harmonics are present. At all other widths 
			 *         even-numbered harmonics are present. Read more 
			 *         [here](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).
			 *
			 *  @constructor
			 *  @extends {Tone.Oscillator}
			 *  @param {Frequency} [frequency] The frequency of the oscillator
			 *  @param {NormalRange} [width] The width of the pulse
			 *  @example
			 * var pulse = new Tone.PulseOscillator("E5", 0.4).toMaster().start();
			 */
		    Tone.PulseOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'width'
		        ], Tone.Oscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  The width of the pulse. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);
		        /**
				 *  gate the width amount
				 *  @type {GainNode}
				 *  @private
				 */
		        this._widthGate = this.context.createGain();
		        /**
				 *  the sawtooth oscillator
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this._sawtooth = new Tone.Oscillator({
		            frequency: options.frequency,
		            detune: options.detune,
		            type: 'sawtooth',
		            phase: options.phase
		        });
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this._sawtooth.frequency;
		        /**
				 *  The detune in cents. 
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this._sawtooth.detune;
		        /**
				 *  Threshold the signal to turn it into a square
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._thresh = new Tone.WaveShaper(function (val) {
		            if (val < 0) {
		                return -1;
		            } else {
		                return 1;
		            }
		        });
		        //connections
		        this._sawtooth.chain(this._thresh, this.output);
		        this.width.chain(this._widthGate, this._thresh);
		        this._readOnly([
		            'width',
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.PulseOscillator, Tone.Oscillator);
		    /**
			 *  The default parameters.
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.PulseOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'phase': 0,
		        'width': 0.2
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} time 
			 *  @private
			 */
		    Tone.PulseOscillator.prototype._start = function (time) {
		        time = this.toSeconds(time);
		        this._sawtooth.start(time);
		        this._widthGate.gain.setValueAtTime(1, time);
		    };
		    /**
			 *  stop the oscillator
			 *  @param  {Time} time 
			 *  @private
			 */
		    Tone.PulseOscillator.prototype._stop = function (time) {
		        time = this.toSeconds(time);
		        this._sawtooth.stop(time);
		        //the width is still connected to the output. 
		        //that needs to be stopped also
		        this._widthGate.gain.setValueAtTime(0, time);
		    };
		    /**
			 * The phase of the oscillator in degrees.
			 * @memberOf Tone.PulseOscillator#
			 * @type {Degrees}
			 * @name phase
			 */
		    Object.defineProperty(Tone.PulseOscillator.prototype, 'phase', {
		        get: function () {
		            return this._sawtooth.phase;
		        },
		        set: function (phase) {
		            this._sawtooth.phase = phase;
		        }
		    });
		    /**
			 * The type of the oscillator. Always returns "pulse".
			 * @readOnly
			 * @memberOf Tone.PulseOscillator#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.PulseOscillator.prototype, 'type', {
		        get: function () {
		            return 'pulse';
		        }
		    });
		    /**
			 *  Clean up method.
			 *  @return {Tone.PulseOscillator} this
			 */
		    Tone.PulseOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._sawtooth.dispose();
		        this._sawtooth = null;
		        this._writable([
		            'width',
		            'frequency',
		            'detune'
		        ]);
		        this.width.dispose();
		        this.width = null;
		        this._widthGate.disconnect();
		        this._widthGate = null;
		        this._widthGate = null;
		        this._thresh.disconnect();
		        this._thresh = null;
		        this.frequency = null;
		        this.detune = null;
		        return this;
		    };
		    return Tone.PulseOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.PWMOscillator modulates the width of a Tone.PulseOscillator 
			 *         at the modulationFrequency. This has the effect of continuously
			 *         changing the timbre of the oscillator by altering the harmonics 
			 *         generated.
			 *
			 *  @extends {Tone.Oscillator}
			 *  @constructor
			 *  @param {Frequency} frequency The starting frequency of the oscillator. 
			 *  @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse. 
			 *  @example
			 *  var pwm = new Tone.PWMOscillator("Ab3", 0.3).toMaster().start();
			 */
		    Tone.PWMOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'modulationFrequency'
		        ], Tone.PWMOscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  the pulse oscillator
				 *  @type {Tone.PulseOscillator}
				 *  @private
				 */
		        this._pulse = new Tone.PulseOscillator(options.modulationFrequency);
		        //change the pulse oscillator type
		        this._pulse._sawtooth.type = 'sine';
		        /**
				 *  the modulator
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this._modulator = new Tone.Oscillator({
		            'frequency': options.frequency,
		            'detune': options.detune
		        });
		        /**
				 *  Scale the oscillator so it doesn't go silent 
				 *  at the extreme values.
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = new Tone.Multiply(1.01);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this._modulator.frequency;
		        /**
				 *  The detune of the oscillator.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this._modulator.detune;
		        /**
				 *  The modulation rate of the oscillator. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.modulationFrequency = this._pulse.frequency;
		        //connections
		        this._modulator.chain(this._scale, this._pulse.width);
		        this._pulse.connect(this.output);
		        this._readOnly([
		            'modulationFrequency',
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.PWMOscillator, Tone.Oscillator);
		    /**
			 *  default values
			 *  @static
			 *  @type {Object}
			 *  @const
			 */
		    Tone.PWMOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'modulationFrequency': 0.4
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} [time=now]
			 *  @private
			 */
		    Tone.PWMOscillator.prototype._start = function (time) {
		        time = this.toSeconds(time);
		        this._modulator.start(time);
		        this._pulse.start(time);
		    };
		    /**
			 *  stop the oscillator
			 *  @param  {Time} time (optional) timing parameter
			 *  @private
			 */
		    Tone.PWMOscillator.prototype._stop = function (time) {
		        time = this.toSeconds(time);
		        this._modulator.stop(time);
		        this._pulse.stop(time);
		    };
		    /**
			 * The type of the oscillator. Always returns "pwm".
			 * @readOnly
			 * @memberOf Tone.PWMOscillator#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.PWMOscillator.prototype, 'type', {
		        get: function () {
		            return 'pwm';
		        }
		    });
		    /**
			 * The phase of the oscillator in degrees.
			 * @memberOf Tone.PWMOscillator#
			 * @type {number}
			 * @name phase
			 */
		    Object.defineProperty(Tone.PWMOscillator.prototype, 'phase', {
		        get: function () {
		            return this._modulator.phase;
		        },
		        set: function (phase) {
		            this._modulator.phase = phase;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return {Tone.PWMOscillator} this
			 */
		    Tone.PWMOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._pulse.dispose();
		        this._pulse = null;
		        this._scale.dispose();
		        this._scale = null;
		        this._modulator.dispose();
		        this._modulator = null;
		        this._writable([
		            'modulationFrequency',
		            'frequency',
		            'detune'
		        ]);
		        this.frequency = null;
		        this.detune = null;
		        this.modulationFrequency = null;
		        return this;
		    };
		    return Tone.PWMOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,
			 *         and Tone.PWMOscillator into one class, allowing it to have the 
			 *         types: sine, square, triangle, sawtooth, pulse or pwm. Additionally,
			 *         OmniOscillator is capable of setting the first x number of partials 
			 *         of the oscillator. For example: "sine4" would set be the first 4 
			 *         partials of the sine wave and "triangle8" would set the first 
			 *         8 partials of the triangle wave. 
			 *
			 *  @extends {Tone.Oscillator}
			 *  @constructor
			 *  @param {Frequency} frequency The initial frequency of the oscillator.
			 *  @param {string} type The type of the oscillator.
			 *  @example
			 *  var omniOsc = new Tone.OmniOscillator("C#4", "pwm");
			 */
		    Tone.OmniOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type'
		        ], Tone.OmniOscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The detune control
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
		        /**
				 *  the type of the oscillator source
				 *  @type {string}
				 *  @private
				 */
		        this._sourceType = undefined;
		        /**
				 *  the oscillator
				 *  @type {Tone.Oscillator|Tone.PWMOscillator|Tone.PulseOscillator}
				 *  @private
				 */
		        this._oscillator = null;
		        //set the oscillator
		        this.type = options.type;
		        this._readOnly([
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.OmniOscillator, Tone.Oscillator);
		    /**
			 *  default values
			 *  @static
			 *  @type {Object}
			 *  @const
			 */
		    Tone.OmniOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'type': 'sine',
		        'width': 0.4,
		        //only applies if the oscillator is set to "pulse",
		        'modulationFrequency': 0.4
		    };
		    /**
			 *  @enum {string}
			 *  @private
			 */
		    var OmniOscType = {
		        PulseOscillator: 'PulseOscillator',
		        PWMOscillator: 'PWMOscillator',
		        Oscillator: 'Oscillator'
		    };
		    /**
			 *  start the oscillator
			 *  @param {Time} [time=now] the time to start the oscillator
			 *  @private
			 */
		    Tone.OmniOscillator.prototype._start = function (time) {
		        this._oscillator.start(time);
		    };
		    /**
			 *  start the oscillator
			 *  @param {Time} [time=now] the time to start the oscillator
			 *  @private
			 */
		    Tone.OmniOscillator.prototype._stop = function (time) {
		        this._oscillator.stop(time);
		    };
		    /**
			 * The type of the oscillator. sine, square, triangle, sawtooth, pwm, or pulse. 
			 * @memberOf Tone.OmniOscillator#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'type', {
		        get: function () {
		            return this._oscillator.type;
		        },
		        set: function (type) {
		            if (type.indexOf('sine') === 0 || type.indexOf('square') === 0 || type.indexOf('triangle') === 0 || type.indexOf('sawtooth') === 0) {
		                if (this._sourceType !== OmniOscType.Oscillator) {
		                    this._sourceType = OmniOscType.Oscillator;
		                    this._createNewOscillator(Tone.Oscillator);
		                }
		                this._oscillator.type = type;
		            } else if (type === 'pwm') {
		                if (this._sourceType !== OmniOscType.PWMOscillator) {
		                    this._sourceType = OmniOscType.PWMOscillator;
		                    this._createNewOscillator(Tone.PWMOscillator);
		                }
		            } else if (type === 'pulse') {
		                if (this._sourceType !== OmniOscType.PulseOscillator) {
		                    this._sourceType = OmniOscType.PulseOscillator;
		                    this._createNewOscillator(Tone.PulseOscillator);
		                }
		            } else {
		                throw new TypeError('Tone.OmniOscillator does not support type ' + type);
		            }
		        }
		    });
		    /**
			 *  connect the oscillator to the frequency and detune signals
			 *  @private
			 */
		    Tone.OmniOscillator.prototype._createNewOscillator = function (OscillatorConstructor) {
		        //short delay to avoid clicks on the change
		        var now = this.now() + this.bufferTime;
		        if (this._oscillator !== null) {
		            var oldOsc = this._oscillator;
		            oldOsc.stop(now);
		            oldOsc.onended = function () {
		                oldOsc.dispose();
		                oldOsc = null;
		            };
		        }
		        this._oscillator = new OscillatorConstructor();
		        this.frequency.connect(this._oscillator.frequency);
		        this.detune.connect(this._oscillator.detune);
		        this._oscillator.connect(this.output);
		        if (this.state === Tone.State.Started) {
		            this._oscillator.start(now);
		        }
		    };
		    /**
			 * The phase of the oscillator in degrees. 
			 * @memberOf Tone.OmniOscillator#
			 * @type {Degrees}
			 * @name phase
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'phase', {
		        get: function () {
		            return this._oscillator.phase;
		        },
		        set: function (phase) {
		            this._oscillator.phase = phase;
		        }
		    });
		    /**
			 * The width of the oscillator (only if the oscillator is set to pulse)
			 * @memberOf Tone.OmniOscillator#
			 * @type {NormalRange}
			 * @signal
			 * @name width
			 * @example
			 * var omniOsc = new Tone.OmniOscillator(440, "pulse");
			 * //can access the width attribute only if type === "pulse"
			 * omniOsc.width.value = 0.2; 
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'width', {
		        get: function () {
		            if (this._sourceType === OmniOscType.PulseOscillator) {
		                return this._oscillator.width;
		            }
		        }
		    });
		    /**
			 * The modulationFrequency Signal of the oscillator 
			 * (only if the oscillator type is set to pwm).
			 * @memberOf Tone.OmniOscillator#
			 * @type {Frequency}
			 * @signal
			 * @name modulationFrequency
			 * @example
			 * var omniOsc = new Tone.OmniOscillator(440, "pwm");
			 * //can access the modulationFrequency attribute only if type === "pwm"
			 * omniOsc.modulationFrequency.value = 0.2; 
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationFrequency', {
		        get: function () {
		            if (this._sourceType === OmniOscType.PWMOscillator) {
		                return this._oscillator.modulationFrequency;
		            }
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return {Tone.OmniOscillator} this
			 */
		    Tone.OmniOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'detune'
		        ]);
		        this.detune.dispose();
		        this.detune = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this._oscillator.dispose();
		        this._oscillator = null;
		        this._sourceType = null;
		        return this;
		    };
		    return Tone.OmniOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Base-class for all instruments
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 */
		    Tone.Instrument = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.Instrument.defaults);
		        /**
				 *  the output
				 *  @type {GainNode}
				 *  @private
				 */
		        this.output = this.context.createGain();
		        /**
				 * The volume of the instrument.
				 * @type {Decibels}
				 * @signal
				 */
		        this.volume = new Tone.Signal({
		            'param': this.output.gain,
		            'units': Tone.Type.Decibels,
		            'value': options.volume
		        });
		        this._readOnly(['volume']);
		    };
		    Tone.extend(Tone.Instrument);
		    /**
			 *  the default attributes
			 *  @type {object}
			 */
		    Tone.Instrument.defaults = {
		        /** the volume of the output in decibels */
		        'volume': 0
		    };
		    /**
			 *  @abstract
			 *  @param {string|number} note the note to trigger
			 *  @param {Time} [time=now] the time to trigger the ntoe
			 *  @param {number} [velocity=1] the velocity to trigger the note
			 */
		    Tone.Instrument.prototype.triggerAttack = Tone.noOp;
		    /**
			 *  @abstract
			 *  @param {Time} [time=now] when to trigger the release
			 */
		    Tone.Instrument.prototype.triggerRelease = Tone.noOp;
		    /**
			 *  Trigger the attack and then the release after the duration. 
			 *  @param  {Frequency} note     The note to trigger.
			 *  @param  {Time} duration How long the note should be held for before
			 *                          triggering the release.
			 *  @param {Time} [time=now]  When the note should be triggered.
			 *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.
			 *  @returns {Tone.Instrument} this
			 *  @example
			 * //trigger "C4" for the duration of an 8th note
			 * synth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.Instrument.prototype.triggerAttackRelease = function (note, duration, time, velocity) {
		        time = this.toSeconds(time);
		        duration = this.toSeconds(duration);
		        this.triggerAttack(note, time, velocity);
		        this.triggerRelease(time + duration);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Instrument} this
			 */
		    Tone.Instrument.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable(['volume']);
		        this.volume.dispose();
		        this.volume = null;
		        return this;
		    };
		    return Tone.Instrument;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  This is a base class for monophonic instruments. 
			 *
			 *  @constructor
			 *  @abstract
			 *  @extends {Tone.Instrument}
			 */
		    Tone.Monophonic = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.Monophonic.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The glide time between notes. 
				 *  @type {Time}
				 */
		        this.portamento = options.portamento;
		    };
		    Tone.extend(Tone.Monophonic, Tone.Instrument);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Monophonic.defaults = { 'portamento': 0 };
		    /**
			 *  Trigger the attack of the note optionally with a given velocity. 
			 *  
			 *  
			 *  @param  {Frequency} note     The note to trigger.
			 *  @param  {Time} [time=now]     When the note should start.
			 *  @param  {number} [velocity=1] velocity The velocity scaler 
			 *                                determines how "loud" the note 
			 *                                will be triggered.
			 *  @returns {Tone.Monophonic} this
			 *  @example
			 * synth.triggerAttack("C4");
			 *  @example
			 * //trigger the note a half second from now at half velocity
			 * synth.triggerAttack("C4", "+0.5", 0.5);
			 */
		    Tone.Monophonic.prototype.triggerAttack = function (note, time, velocity) {
		        time = this.toSeconds(time);
		        this._triggerEnvelopeAttack(time, velocity);
		        this.setNote(note, time);
		        return this;
		    };
		    /**
			 *  Trigger the release portion of the envelope
			 *  @param  {Time} [time=now] If no time is given, the release happens immediatly
			 *  @returns {Tone.Monophonic} this
			 *  @example
			 * synth.triggerRelease();
			 */
		    Tone.Monophonic.prototype.triggerRelease = function (time) {
		        this._triggerEnvelopeRelease(time);
		        return this;
		    };
		    /**
			 *  override this method with the actual method
			 *  @abstract
			 *  @private
			 */
		    Tone.Monophonic.prototype._triggerEnvelopeAttack = function () {
		    };
		    /**
			 *  override this method with the actual method
			 *  @abstract
			 *  @private
			 */
		    Tone.Monophonic.prototype._triggerEnvelopeRelease = function () {
		    };
		    /**
			 *  Set the note at the given time. If no time is given, the note
			 *  will set immediately. 
			 *  @param {Frequency} note The note to change to.
			 *  @param  {Time} [time=now] The time when the note should be set. 
			 *  @returns {Tone.Monophonic} this
			 * @example
			 * //change to F#6 in one quarter note from now.
			 * synth.setNote("F#6", "+4n");
			 * @example
			 * //change to Bb4 right now
			 * synth.setNote("Bb4");
			 */
		    Tone.Monophonic.prototype.setNote = function (note, time) {
		        time = this.toSeconds(time);
		        if (this.portamento > 0) {
		            var currentNote = this.frequency.value;
		            this.frequency.setValueAtTime(currentNote, time);
		            var portTime = this.toSeconds(this.portamento);
		            this.frequency.exponentialRampToValueAtTime(note, time + portTime);
		        } else {
		            this.frequency.setValueAtTime(note, time);
		        }
		        return this;
		    };
		    return Tone.Monophonic;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.MonoSynth is composed of one oscillator, one filter, and two envelopes.
			 *          The amplitude of the Tone.Oscillator and the cutoff frequency of the 
			 *          Tone.Filter are controlled by Tone.Envelopes. 
			 *          <img src="https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240">
			 *          
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var synth = new Tone.MonoSynth({
			 * 	"oscillator" : {
			 * 		"type" : "square"
			 *  },
			 *  "envelope" : {
			 *  	"attack" : 0.1
			 *  }
			 * }).toMaster();
			 * synth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.MonoSynth = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.MonoSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The oscillator.
				 *  @type {Tone.OmniOscillator}
				 */
		        this.oscillator = new Tone.OmniOscillator(options.oscillator);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this.oscillator.frequency;
		        /**
				 *  The detune control.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this.oscillator.detune;
		        /**
				 *  The filter.
				 *  @type {Tone.Filter}
				 */
		        this.filter = new Tone.Filter(options.filter);
		        /**
				 *  The filter envelope.
				 *  @type {Tone.ScaledEnvelope}
				 */
		        this.filterEnvelope = new Tone.ScaledEnvelope(options.filterEnvelope);
		        /**
				 *  The amplitude envelope.
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        //connect the oscillators to the output
		        this.oscillator.chain(this.filter, this.envelope, this.output);
		        //start the oscillators
		        this.oscillator.start();
		        //connect the filter envelope
		        this.filterEnvelope.connect(this.filter.frequency);
		        this._readOnly([
		            'oscillator',
		            'frequency',
		            'detune',
		            'filter',
		            'filterEnvelope',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.MonoSynth, Tone.Monophonic);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MonoSynth.defaults = {
		        'frequency': 'C4',
		        'detune': 0,
		        'oscillator': { 'type': 'square' },
		        'filter': {
		            'Q': 6,
		            'type': 'lowpass',
		            'rolloff': -24
		        },
		        'envelope': {
		            'attack': 0.005,
		            'decay': 0.1,
		            'sustain': 0.9,
		            'release': 1
		        },
		        'filterEnvelope': {
		            'attack': 0.06,
		            'decay': 0.2,
		            'sustain': 0.5,
		            'release': 2,
		            'min': 20,
		            'max': 4000,
		            'exponent': 2
		        }
		    };
		    /**
			 *  start the attack portion of the envelope
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.MonoSynth} this
			 *  @private
			 */
		    Tone.MonoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the envelopes
		        this.envelope.triggerAttack(time, velocity);
		        this.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  start the release portion of the envelope
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.MonoSynth} this
			 *  @private
			 */
		    Tone.MonoSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        this.filterEnvelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.MonoSynth} this
			 */
		    Tone.MonoSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'oscillator',
		            'frequency',
		            'detune',
		            'filter',
		            'filterEnvelope',
		            'envelope'
		        ]);
		        this.oscillator.dispose();
		        this.oscillator = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        this.filterEnvelope.dispose();
		        this.filterEnvelope = null;
		        this.filter.dispose();
		        this.filter = null;
		        this.frequency = null;
		        this.detune = null;
		        return this;
		    };
		    return Tone.MonoSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  AMSynth uses the output of one Tone.MonoSynth to modulate the
			 *          amplitude of another Tone.MonoSynth. The harmonicity (the ratio between
			 *          the two signals) affects the timbre of the output signal the most.
			 *          Read more about Amplitude Modulation Synthesis on 
			 *          [SoundOnSound](http://www.soundonsound.com/sos/mar00/articles/synthsecrets.htm).
			 *          <img src="https://docs.google.com/drawings/d/1TQu8Ed4iFr1YTLKpB3U1_hur-UwBrh5gdBXc8BxfGKw/pub?w=1009&h=457">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                            see defaults below
			 *  @example
			 * var synth = new Tone.AMSynth().toMaster();
			 * synth.triggerAttackRelease("C4", "4n");
			 */
		    Tone.AMSynth = function (options) {
		        options = this.defaultArg(options, Tone.AMSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The carrier voice. 
				 *  @type {Tone.MonoSynth}
				 */
		        this.carrier = new Tone.MonoSynth(options.carrier);
		        this.carrier.volume.value = -10;
		        /**
				 *  The modulator voice. 
				 *  @type {Tone.MonoSynth}
				 */
		        this.modulator = new Tone.MonoSynth(options.modulator);
		        this.modulator.volume.value = -10;
		        /**
				 *  The frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  Harmonicity is the ratio between the two voices. A harmonicity of
				 *  1 is no change. Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch voice1 an octave below voice0
				 * synth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  convert the -1,1 output to 0,1
				 *  @type {Tone.AudioToGain}
				 *  @private
				 */
		        this._modulationScale = new Tone.AudioToGain();
		        /**
				 *  the node where the modulation happens
				 *  @type {GainNode}
				 *  @private
				 */
		        this._modulationNode = this.context.createGain();
		        //control the two voices frequency
		        this.frequency.connect(this.carrier.frequency);
		        this.frequency.chain(this.harmonicity, this.modulator.frequency);
		        this.modulator.chain(this._modulationScale, this._modulationNode.gain);
		        this.carrier.chain(this._modulationNode, this.output);
		        this._readOnly([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity'
		        ]);
		    };
		    Tone.extend(Tone.AMSynth, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AMSynth.defaults = {
		        'harmonicity': 3,
		        'carrier': {
		            'volume': -10,
		            'oscillator': { 'type': 'sine' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0.01,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5,
		                'min': 20000,
		                'max': 20000
		            },
		            'filter': {
		                'Q': 6,
		                'type': 'lowpass',
		                'rolloff': -24
		            }
		        },
		        'modulator': {
		            'volume': -10,
		            'oscillator': { 'type': 'square' },
		            'envelope': {
		                'attack': 2,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'filterEnvelope': {
		                'attack': 4,
		                'decay': 0.2,
		                'sustain': 0.5,
		                'release': 0.5,
		                'min': 20,
		                'max': 1500
		            },
		            'filter': {
		                'Q': 6,
		                'type': 'lowpass',
		                'rolloff': -24
		            }
		        }
		    };
		    /**
			 *  trigger the attack portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will occur
			 *  @param {NormalRange} [velocity=1] the velocity of the note
			 *  @private
			 *  @returns {Tone.AMSynth} this
			 */
		    Tone.AMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the port glide
		        time = this.toSeconds(time);
		        //the envelopes
		        this.carrier.envelope.triggerAttack(time, velocity);
		        this.modulator.envelope.triggerAttack(time);
		        this.carrier.filterEnvelope.triggerAttack(time);
		        this.modulator.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  trigger the release portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @private
			 *  @returns {Tone.AMSynth} this
			 */
		    Tone.AMSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.carrier.triggerRelease(time);
		        this.modulator.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.AMSynth} this
			 */
		    Tone.AMSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity'
		        ]);
		        this.carrier.dispose();
		        this.carrier = null;
		        this.modulator.dispose();
		        this.modulator = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._modulationScale.dispose();
		        this._modulationScale = null;
		        this._modulationNode.disconnect();
		        this._modulationNode = null;
		        return this;
		    };
		    return Tone.AMSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.DrumSynth makes kick and tom sounds using a single oscillator
			 *          with an amplitude envelope and frequency ramp. A Tone.Oscillator
			 *          is routed through a Tone.AmplitudeEnvelope to the output. The drum
			 *          quality of the sound comes from the frequency envelope applied
			 *          during during Tone.DrumSynth.triggerAttack(note). The frequency
			 *          envelope starts at <code>note * .octaves</code> and ramps to 
			 *          <code>note</code> over the duration of <code>.pitchDecay</code>. 
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var synth = new Tone.DrumSynth().toMaster();
			 * synth.triggerAttackRelease("C2", "8n");
			 */
		    Tone.DrumSynth = function (options) {
		        options = this.defaultArg(options, Tone.DrumSynth.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The oscillator.
				 *  @type {Tone.Oscillator}
				 */
		        this.oscillator = new Tone.Oscillator(options.oscillator).start();
		        /**
				 *  The amplitude envelope.
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        /**
				 *  The number of octaves the pitch envelope ramps.
				 *  @type {Positive}
				 */
		        this.octaves = options.octaves;
		        /**
				 *  The amount of time the frequency envelope takes. 
				 *  @type {Time}
				 */
		        this.pitchDecay = options.pitchDecay;
		        this.oscillator.chain(this.envelope, this.output);
		        this._readOnly([
		            'oscillator',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.DrumSynth, Tone.Instrument);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.DrumSynth.defaults = {
		        'pitchDecay': 0.05,
		        'octaves': 10,
		        'oscillator': { 'type': 'sine' },
		        'envelope': {
		            'attack': 0.001,
		            'decay': 0.4,
		            'sustain': 0.01,
		            'release': 1.4,
		            'attackCurve': 'exponential'
		        }
		    };
		    /**
			 *  Trigger the note at the given time with the given velocity. 
			 *  
			 *  @param  {Frequency} note     the note
			 *  @param  {Time} [time=now]     the time, if not given is now
			 *  @param  {number} [velocity=1] velocity defaults to 1
			 *  @returns {Tone.DrumSynth} this
			 *  @example
			 *  kick.triggerAttack(60);
			 */
		    Tone.DrumSynth.prototype.triggerAttack = function (note, time, velocity) {
		        time = this.toSeconds(time);
		        note = this.toFrequency(note);
		        var maxNote = note * this.octaves;
		        this.oscillator.frequency.setValueAtTime(maxNote, time);
		        this.oscillator.frequency.exponentialRampToValueAtTime(note, time + this.toSeconds(this.pitchDecay));
		        this.envelope.triggerAttack(time, velocity);
		        return this;
		    };
		    /**
			 *  Trigger the release portion of the note.
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @returns {Tone.DrumSynth} this
			 */
		    Tone.DrumSynth.prototype.triggerRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.DrumSynth} this
			 */
		    Tone.DrumSynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._writable([
		            'oscillator',
		            'envelope'
		        ]);
		        this.oscillator.dispose();
		        this.oscillator = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        return this;
		    };
		    return Tone.DrumSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.DuoSynth is a monophonic synth composed of two 
			 *          MonoSynths run in parallel with control over the 
			 *          frequency ratio between the two voices and vibrato effect.
			 *          <img src="https://docs.google.com/drawings/d/1bL4GXvfRMMlqS7XyBm9CjL9KJPSUKbcdBNpqOlkFLxk/pub?w=1012&h=448">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var duoSynth = new Tone.DuoSynth().toMaster();
			 * duoSynth.triggerAttackRelease("C4", "2n");
			 */
		    Tone.DuoSynth = function (options) {
		        options = this.defaultArg(options, Tone.DuoSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  the first voice
				 *  @type {Tone.MonoSynth}
				 */
		        this.voice0 = new Tone.MonoSynth(options.voice0);
		        this.voice0.volume.value = -10;
		        /**
				 *  the second voice
				 *  @type {Tone.MonoSynth}
				 */
		        this.voice1 = new Tone.MonoSynth(options.voice1);
		        this.voice1.volume.value = -10;
		        /**
				 *  The vibrato LFO. 
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._vibrato = new Tone.LFO(options.vibratoRate, -50, 50);
		        this._vibrato.start();
		        /**
				 * the vibrato frequency
				 * @type {Frequency}
				 * @signal
				 */
		        this.vibratoRate = this._vibrato.frequency;
		        /**
				 *  the vibrato gain
				 *  @type {GainNode}
				 *  @private
				 */
		        this._vibratoGain = this.context.createGain();
		        /**
				 * The amount of vibrato
				 * @type {Gain}
				 * @signal
				 */
		        this.vibratoAmount = new Tone.Signal(this._vibratoGain.gain, Tone.Type.Gain);
		        this.vibratoAmount.value = options.vibratoAmount;
		        /**
				 *  the delay before the vibrato starts
				 *  @type {number}
				 *  @private
				 */
		        this._vibratoDelay = this.toSeconds(options.vibratoDelay);
		        /**
				 *  the frequency control
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  Harmonicity is the ratio between the two voices. A harmonicity of
				 *  1 is no change. Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch voice1 an octave below voice0
				 * duoSynth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        //control the two voices frequency
		        this.frequency.connect(this.voice0.frequency);
		        this.frequency.chain(this.harmonicity, this.voice1.frequency);
		        this._vibrato.connect(this._vibratoGain);
		        this._vibratoGain.fan(this.voice0.detune, this.voice1.detune);
		        this.voice0.connect(this.output);
		        this.voice1.connect(this.output);
		        this._readOnly([
		            'voice0',
		            'voice1',
		            'frequency',
		            'vibratoAmount',
		            'vibratoRate'
		        ]);
		    };
		    Tone.extend(Tone.DuoSynth, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.DuoSynth.defaults = {
		        'vibratoAmount': 0.5,
		        'vibratoRate': 5,
		        'vibratoDelay': 1,
		        'harmonicity': 1.5,
		        'voice0': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            }
		        },
		        'voice1': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            }
		        }
		    };
		    /**
			 *  start the attack portion of the envelopes
			 *  
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.DuoSynth} this
			 *  @private
			 */
		    Tone.DuoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        time = this.toSeconds(time);
		        this.voice0.envelope.triggerAttack(time, velocity);
		        this.voice1.envelope.triggerAttack(time, velocity);
		        this.voice0.filterEnvelope.triggerAttack(time);
		        this.voice1.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  start the release portion of the envelopes
			 *  
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.DuoSynth} this
			 *  @private
			 */
		    Tone.DuoSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.voice0.triggerRelease(time);
		        this.voice1.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.DuoSynth} this
			 */
		    Tone.DuoSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'voice0',
		            'voice1',
		            'frequency',
		            'vibratoAmount',
		            'vibratoRate'
		        ]);
		        this.voice0.dispose();
		        this.voice0 = null;
		        this.voice1.dispose();
		        this.voice1 = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this._vibrato.dispose();
		        this._vibrato = null;
		        this._vibratoGain.disconnect();
		        this._vibratoGain = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this.vibratoAmount.dispose();
		        this.vibratoAmount = null;
		        this.vibratoRate = null;
		        return this;
		    };
		    return Tone.DuoSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  FMSynth is composed of two Tone.MonoSynths where one Tone.MonoSynth modulates
			 *          the frequency of a second Tone.MonoSynth. A lot of spectral content 
			 *          can be explored using the modulationIndex parameter. Read more about
			 *          frequency modulation synthesis on [SoundOnSound](http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm).
			 *          <img src="https://docs.google.com/drawings/d/1h0PUDZXPgi4Ikx6bVT6oncrYPLluFKy7lj53puxj-DM/pub?w=902&h=462">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var fmSynth = new Tone.FMSynth().toMaster();
			 * fmSynth.triggerAttackRelease("C5", "4n");
			 */
		    Tone.FMSynth = function (options) {
		        options = this.defaultArg(options, Tone.FMSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The carrier voice.
				 *  @type {Tone.MonoSynth}
				 */
		        this.carrier = new Tone.MonoSynth(options.carrier);
		        this.carrier.volume.value = -10;
		        /**
				 *  The modulator voice.
				 *  @type {Tone.MonoSynth}
				 */
		        this.modulator = new Tone.MonoSynth(options.modulator);
		        this.modulator.volume.value = -10;
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  Harmonicity is the ratio between the two voices. A harmonicity of
				 *  1 is no change. Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch voice1 an octave below voice0
				 * synth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  The modulation index which essentially the depth or amount of the modulation. It is the 
				 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the 
				 *  modulating signal (ma) -- as in ma/mf. 
				 *	@type {Positive}
				 *	@signal
				 */
		        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
		        this.modulationIndex.units = Tone.Type.Positive;
		        /**
				 *  the node where the modulation happens
				 *  @type {GainNode}
				 *  @private
				 */
		        this._modulationNode = this.context.createGain();
		        //control the two voices frequency
		        this.frequency.connect(this.carrier.frequency);
		        this.frequency.chain(this.harmonicity, this.modulator.frequency);
		        this.frequency.chain(this.modulationIndex, this._modulationNode);
		        this.modulator.connect(this._modulationNode.gain);
		        this._modulationNode.gain.value = 0;
		        this._modulationNode.connect(this.carrier.frequency);
		        this.carrier.connect(this.output);
		        this._readOnly([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity',
		            'modulationIndex'
		        ]);
		    };
		    Tone.extend(Tone.FMSynth, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.FMSynth.defaults = {
		        'harmonicity': 3,
		        'modulationIndex': 10,
		        'carrier': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5,
		                'min': 20000,
		                'max': 20000
		            }
		        },
		        'modulator': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'triangle' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5,
		                'min': 20000,
		                'max': 20000
		            }
		        }
		    };
		    /**
			 * 	trigger the attack portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will occur
			 *  @param {number} [velocity=1] the velocity of the note
			 *  @returns {Tone.FMSynth} this
			 *  @private
			 */
		    Tone.FMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the port glide
		        time = this.toSeconds(time);
		        //the envelopes
		        this.carrier.envelope.triggerAttack(time, velocity);
		        this.modulator.envelope.triggerAttack(time);
		        this.carrier.filterEnvelope.triggerAttack(time);
		        this.modulator.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  trigger the release portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @returns {Tone.FMSynth} this
			 *  @private
			 */
		    Tone.FMSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.carrier.triggerRelease(time);
		        this.modulator.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.FMSynth} this
			 */
		    Tone.FMSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity',
		            'modulationIndex'
		        ]);
		        this.carrier.dispose();
		        this.carrier = null;
		        this.modulator.dispose();
		        this.modulator = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this.modulationIndex.dispose();
		        this.modulationIndex = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._modulationNode.disconnect();
		        this._modulationNode = null;
		        return this;
		    };
		    return Tone.FMSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Noise is a noise generator. It uses looped noise buffers to save on performance.
			 *          Tone.Noise supports the noise types: "pink", "white", and "brown". Read more about
			 *          colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).
			 *
			 *  @constructor
			 *  @extends {Tone.Source}
			 *  @param {string} type the noise type (white|pink|brown)
			 *  @example
			 * //initialize the noise and start
			 * var noise = new Tone.Noise("pink").start();
			 * 
			 * //make an autofilter to shape the noise
			 * var autoFilter = new Tone.AutoFilter({
			 * 	"frequency" : "8m", 
			 * 	"min" : 800, 
			 * 	"max" : 15000
			 * }).connect(Tone.Master);
			 * 
			 * //connect the noise
			 * noise.connect(autoFilter);
			 * //start the autofilter LFO
			 * autoFilter.start()
			 */
		    Tone.Noise = function () {
		        var options = this.optionsObject(arguments, ['type'], Tone.Noise.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  @private
				 *  @type {AudioBufferSourceNode}
				 */
		        this._source = null;
		        /**
				 *  the buffer
				 *  @private
				 *  @type {AudioBuffer}
				 */
		        this._buffer = null;
		        this.type = options.type;
		    };
		    Tone.extend(Tone.Noise, Tone.Source);
		    /**
			 *  the default parameters
			 *
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Noise.defaults = { 'type': 'white' };
		    /**
			 * The type of the noise. Can be "white", "brown", or "pink". 
			 * @memberOf Tone.Noise#
			 * @type {string}
			 * @name type
			 * @example
			 * noise.type = "white";
			 */
		    Object.defineProperty(Tone.Noise.prototype, 'type', {
		        get: function () {
		            if (this._buffer === _whiteNoise) {
		                return 'white';
		            } else if (this._buffer === _brownNoise) {
		                return 'brown';
		            } else if (this._buffer === _pinkNoise) {
		                return 'pink';
		            }
		        },
		        set: function (type) {
		            if (this.type !== type) {
		                switch (type) {
		                case 'white':
		                    this._buffer = _whiteNoise;
		                    break;
		                case 'pink':
		                    this._buffer = _pinkNoise;
		                    break;
		                case 'brown':
		                    this._buffer = _brownNoise;
		                    break;
		                default:
		                    this._buffer = _whiteNoise;
		                }
		                //if it's playing, stop and restart it
		                if (this.state === Tone.State.Started) {
		                    var now = this.now() + this.bufferTime;
		                    //remove the listener
		                    this._source.onended = undefined;
		                    this._stop(now);
		                    this._start(now);
		                }
		            }
		        }
		    });
		    /**
			 *  internal start method
			 *
			 *  @param {Time} time
			 *  @private
			 */
		    Tone.Noise.prototype._start = function (time) {
		        this._source = this.context.createBufferSource();
		        this._source.buffer = this._buffer;
		        this._source.loop = true;
		        this.connectSeries(this._source, this.output);
		        this._source.start(this.toSeconds(time));
		        this._source.onended = this.onended;
		    };
		    /**
			 *  internal stop method
			 *
			 *  @param {Time} time
			 *  @private
			 */
		    Tone.Noise.prototype._stop = function (time) {
		        if (this._source) {
		            this._source.stop(this.toSeconds(time));
		        }
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Noise} this
			 */
		    Tone.Noise.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        if (this._source !== null) {
		            this._source.disconnect();
		            this._source = null;
		        }
		        this._buffer = null;
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    // THE BUFFERS
		    // borrowed heavily from http://noisehack.com/generate-noise-web-audio-api/
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *	static noise buffers
			 *
			 *  @static
			 *  @private
			 *  @type {AudioBuffer}
			 */
		    var _pinkNoise = null, _brownNoise = null, _whiteNoise = null;
		    Tone._initAudioContext(function (audioContext) {
		        var sampleRate = audioContext.sampleRate;
		        //four seconds per buffer
		        var bufferLength = sampleRate * 4;
		        //fill the buffers
		        _pinkNoise = function () {
		            var buffer = audioContext.createBuffer(2, bufferLength, sampleRate);
		            for (var channelNum = 0; channelNum < buffer.numberOfChannels; channelNum++) {
		                var channel = buffer.getChannelData(channelNum);
		                var b0, b1, b2, b3, b4, b5, b6;
		                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
		                for (var i = 0; i < bufferLength; i++) {
		                    var white = Math.random() * 2 - 1;
		                    b0 = 0.99886 * b0 + white * 0.0555179;
		                    b1 = 0.99332 * b1 + white * 0.0750759;
		                    b2 = 0.969 * b2 + white * 0.153852;
		                    b3 = 0.8665 * b3 + white * 0.3104856;
		                    b4 = 0.55 * b4 + white * 0.5329522;
		                    b5 = -0.7616 * b5 - white * 0.016898;
		                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
		                    channel[i] *= 0.11;
		                    // (roughly) compensate for gain
		                    b6 = white * 0.115926;
		                }
		            }
		            return buffer;
		        }();
		        _brownNoise = function () {
		            var buffer = audioContext.createBuffer(2, bufferLength, sampleRate);
		            for (var channelNum = 0; channelNum < buffer.numberOfChannels; channelNum++) {
		                var channel = buffer.getChannelData(channelNum);
		                var lastOut = 0;
		                for (var i = 0; i < bufferLength; i++) {
		                    var white = Math.random() * 2 - 1;
		                    channel[i] = (lastOut + 0.02 * white) / 1.02;
		                    lastOut = channel[i];
		                    channel[i] *= 3.5;    // (roughly) compensate for gain
		                }
		            }
		            return buffer;
		        }();
		        _whiteNoise = function () {
		            var buffer = audioContext.createBuffer(2, bufferLength, sampleRate);
		            for (var channelNum = 0; channelNum < buffer.numberOfChannels; channelNum++) {
		                var channel = buffer.getChannelData(channelNum);
		                for (var i = 0; i < bufferLength; i++) {
		                    channel[i] = Math.random() * 2 - 1;
		                }
		            }
		            return buffer;
		        }();
		    });
		    return Tone.Noise;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.NoiseSynth is composed of a noise generator (Tone.Noise), one filter (Tone.Filter), 
			 *          and two envelopes (Tone.Envelop). One envelope controls the amplitude
			 *          of the noise and the other is controls the cutoff frequency of the filter. 
			 *          <img src="https://docs.google.com/drawings/d/1rqzuX9rBlhT50MRvD2TKml9bnZhcZmzXF1rf_o7vdnE/pub?w=918&h=242">
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 * @example
			 * var noiseSynth = new Tone.NoiseSynth().toMaster();
			 * noiseSynth.triggerAttackRelease("8n");
			 */
		    Tone.NoiseSynth = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.NoiseSynth.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The noise source.
				 *  @type {Tone.Noise}
				 *  @example
				 * noiseSynth.set("noise.type", "brown");
				 */
		        this.noise = new Tone.Noise();
		        /**
				 *  The filter. 
				 *  @type {Tone.Filter}
				 */
		        this.filter = new Tone.Filter(options.filter);
		        /**
				 *  The filter envelope. 
				 *  @type {Tone.ScaledEnvelope}
				 */
		        this.filterEnvelope = new Tone.ScaledEnvelope(options.filterEnvelope);
		        /**
				 *  The amplitude envelope. 
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        //connect the noise to the output
		        this.noise.chain(this.filter, this.envelope, this.output);
		        //start the noise
		        this.noise.start();
		        //connect the filter envelope
		        this.filterEnvelope.connect(this.filter.frequency);
		        this._readOnly([
		            'noise',
		            'filter',
		            'filterEnvelope',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.NoiseSynth, Tone.Instrument);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.NoiseSynth.defaults = {
		        'noise': { 'type': 'white' },
		        'filter': {
		            'Q': 6,
		            'type': 'highpass',
		            'rolloff': -24
		        },
		        'envelope': {
		            'attack': 0.005,
		            'decay': 0.1,
		            'sustain': 0
		        },
		        'filterEnvelope': {
		            'attack': 0.06,
		            'decay': 0.2,
		            'sustain': 0,
		            'release': 2,
		            'min': 20,
		            'max': 4000,
		            'exponent': 2
		        }
		    };
		    /**
			 *  Start the attack portion of the envelopes. Unlike other 
			 *  instruments, Tone.NoiseSynth doesn't have a note. 
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {number} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.NoiseSynth} this
			 *  @example
			 * noiseSynth.triggerAttack();
			 */
		    Tone.NoiseSynth.prototype.triggerAttack = function (time, velocity) {
		        //the envelopes
		        this.envelope.triggerAttack(time, velocity);
		        this.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  Start the release portion of the envelopes.
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.NoiseSynth} this
			 */
		    Tone.NoiseSynth.prototype.triggerRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        this.filterEnvelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  Trigger the attack and then the release. 
			 *  @param  {Time} duration the duration of the note
			 *  @param  {Time} [time=now]     the time of the attack
			 *  @param  {number} [velocity=1] the velocity
			 *  @returns {Tone.NoiseSynth} this
			 */
		    Tone.NoiseSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {
		        time = this.toSeconds(time);
		        duration = this.toSeconds(duration);
		        this.triggerAttack(time, velocity);
		        this.triggerRelease(time + duration);
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.NoiseSynth} this
			 */
		    Tone.NoiseSynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._writable([
		            'noise',
		            'filter',
		            'filterEnvelope',
		            'envelope'
		        ]);
		        this.noise.dispose();
		        this.noise = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        this.filterEnvelope.dispose();
		        this.filterEnvelope = null;
		        this.filter.dispose();
		        this.filter = null;
		        return this;
		    };
		    return Tone.NoiseSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Karplus-String string synthesis. Often out of tune. 
			 *         Will change when the AudioWorkerNode is available across
			 *         browsers. 
			 *  
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object} [options] see the defaults
			 *  @example
			 * var plucky = new Tone.PluckSynth().toMaster();
			 * plucky.triggerAttack("C4");
			 */
		    Tone.PluckSynth = function (options) {
		        options = this.defaultArg(options, Tone.PluckSynth.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  @type {Tone.Noise}
				 *  @private
				 */
		        this._noise = new Tone.Noise('pink');
		        /**
				 *  The amount of noise at the attack. 
				 *  Nominal range of [0.1, 20]
				 *  @type {number}
				 */
		        this.attackNoise = 1;
		        /**
				 *  the LFCF
				 *  @type {Tone.LowpassCombFilter}
				 *  @private
				 */
		        this._lfcf = new Tone.LowpassCombFilter({
		            'resonance': options.resonance,
		            'dampening': options.dampening
		        });
		        /**
				 *  The resonance control. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.resonance = this._lfcf.resonance;
		        /**
				 *  The dampening control. i.e. the lowpass filter frequency of the comb filter
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.dampening = this._lfcf.dampening;
		        //connections
		        this._noise.connect(this._lfcf);
		        this._lfcf.connect(this.output);
		        this._readOnly([
		            'resonance',
		            'dampening'
		        ]);
		    };
		    Tone.extend(Tone.PluckSynth, Tone.Instrument);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.PluckSynth.defaults = {
		        'attackNoise': 1,
		        'dampening': 4000,
		        'resonance': 0.9
		    };
		    /**
			 *  Trigger the note. 
			 *  @param {Frequency} note The note to trigger.
			 *  @param {Time} [time=now] When the note should be triggered.
			 *  @returns {Tone.PluckSynth} this
			 */
		    Tone.PluckSynth.prototype.triggerAttack = function (note, time) {
		        note = this.toFrequency(note);
		        time = this.toSeconds(time);
		        var delayAmount = 1 / note;
		        this._lfcf.delayTime.setValueAtTime(delayAmount, time);
		        this._noise.start(time);
		        this._noise.stop(time + delayAmount * this.attackNoise);
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.PluckSynth} this
			 */
		    Tone.PluckSynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._noise.dispose();
		        this._lfcf.dispose();
		        this._noise = null;
		        this._lfcf = null;
		        this._writable([
		            'resonance',
		            'dampening'
		        ]);
		        this.dampening = null;
		        this.resonance = null;
		        return this;
		    };
		    return Tone.PluckSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.PolySynth handles voice creation and allocation for any
			 *          instruments passed in as the second paramter. PolySynth is 
			 *          not a synthesizer by itself, it merely manages voices of 
			 *          one of the other types of synths, allowing any of the 
			 *          monophonic synthesizers to be polyphonic. 
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {number|Object} [polyphony=4] The number of voices to create
			 *  @param {function} [voice=Tone.MonoSynth] The constructor of the voices
			 *                                            uses Tone.MonoSynth by default. 
			 *  @example
			 * //a polysynth composed of 6 Voices of MonoSynth
			 * var synth = new Tone.PolySynth(6, Tone.MonoSynth).toMaster();
			 * //set the attributes using the set interface
			 * synth.set("detune", -1200);
			 * //play a chord
			 * synth.triggerAttackRelease(["C4", "E4", "A4"], "4n");
			 */
		    Tone.PolySynth = function () {
		        Tone.Instrument.call(this);
		        var options = this.optionsObject(arguments, [
		            'polyphony',
		            'voice'
		        ], Tone.PolySynth.defaults);
		        /**
				 *  the array of voices
				 *  @type {Array}
				 */
		        this.voices = new Array(options.polyphony);
		        /**
				 *  the queue of free voices
				 *  @private
				 *  @type {Array}
				 */
		        this._freeVoices = [];
		        /**
				 *  keeps track of which notes are down
				 *  @private
				 *  @type {Object}
				 */
		        this._activeVoices = {};
		        //create the voices
		        for (var i = 0; i < options.polyphony; i++) {
		            var v = new options.voice(arguments[2], arguments[3]);
		            this.voices[i] = v;
		            v.connect(this.output);
		        }
		        //make a copy of the voices
		        this._freeVoices = this.voices.slice(0);    //get the prototypes and properties
		    };
		    Tone.extend(Tone.PolySynth, Tone.Instrument);
		    /**
			 *  the defaults
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.PolySynth.defaults = {
		        'polyphony': 4,
		        'voice': Tone.MonoSynth
		    };
		    /**
			 *  Trigger the attack portion of the note
			 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
			 *                                  Frequency or an array of frequencies.
			 *  @param  {Time} [time=now]  The start time of the note.
			 *  @param {number} [velocity=1] The velocity of the note.
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * //trigger a chord immediately with a velocity of 0.2
			 * poly.triggerAttack(["Ab3", "C4", "F5"], undefined, 0.2);
			 */
		    Tone.PolySynth.prototype.triggerAttack = function (notes, time, velocity) {
		        if (!Array.isArray(notes)) {
		            notes = [notes];
		        }
		        for (var i = 0; i < notes.length; i++) {
		            var val = notes[i];
		            var stringified = JSON.stringify(val);
		            if (this._activeVoices[stringified]) {
		                this._activeVoices[stringified].triggerAttack(val, time, velocity);
		            } else if (this._freeVoices.length > 0) {
		                var voice = this._freeVoices.shift();
		                voice.triggerAttack(val, time, velocity);
		                this._activeVoices[stringified] = voice;
		            }
		        }
		        return this;
		    };
		    /**
			 *  Trigger the attack and release after the specified duration
			 *  
			 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
			 *                                  Frequency or an array of frequencies.
			 *  @param  {Time} duration the duration of the note
			 *  @param  {Time} [time=now]     if no time is given, defaults to now
			 *  @param  {number} [velocity=1] the velocity of the attack (0-1)
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * //trigger a chord for a duration of a half note 
			 * poly.triggerAttackRelease(["Eb3", "G4", "C5"], "2n");
			 */
		    Tone.PolySynth.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {
		        time = this.toSeconds(time);
		        this.triggerAttack(notes, time, velocity);
		        this.triggerRelease(notes, time + this.toSeconds(duration));
		        return this;
		    };
		    /**
			 *  Trigger the release of the note. Unlike monophonic instruments, 
			 *  a note (or array of notes) needs to be passed in as the first argument.
			 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
			 *                                  Frequency or an array of frequencies.
			 *  @param  {Time} [time=now]  When the release will be triggered. 
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * poly.triggerAttack(["Ab3", "C4", "F5"]);
			 */
		    Tone.PolySynth.prototype.triggerRelease = function (notes, time) {
		        if (!Array.isArray(notes)) {
		            notes = [notes];
		        }
		        for (var i = 0; i < notes.length; i++) {
		            //get the voice
		            var stringified = JSON.stringify(notes[i]);
		            var voice = this._activeVoices[stringified];
		            if (voice) {
		                voice.triggerRelease(time);
		                this._freeVoices.push(voice);
		                delete this._activeVoices[stringified];
		                voice = null;
		            }
		        }
		        return this;
		    };
		    /**
			 *  Set a member/attribute of the voices. 
			 *  @param {Object|string} params
			 *  @param {number=} value
			 *  @param {Time=} rampTime
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * poly.set({
			 * 	"filter" : {
			 * 		"type" : "highpass"
			 * 	},
			 * 	"envelope" : {
			 * 		"attack" : 0.25
			 * 	}
			 * });
			 */
		    Tone.PolySynth.prototype.set = function (params, value, rampTime) {
		        for (var i = 0; i < this.voices.length; i++) {
		            this.voices[i].set(params, value, rampTime);
		        }
		        return this;
		    };
		    /**
			 *  Get the synth's attributes. Given no arguments get
			 *  will return all available object properties and their corresponding
			 *  values. Pass in a single attribute to retrieve or an array
			 *  of attributes. The attribute strings can also include a "."
			 *  to access deeper properties.
			 *  @param {Array=} params the parameters to get, otherwise will return 
			 *  					   all available.
			 */
		    Tone.PolySynth.prototype.get = function (params) {
		        return this.voices[0].get(params);
		    };
		    /**
			 *  @param {string} presetName the preset name
			 *  @returns {Tone.PolySynth} this
			 *  @private
			 */
		    Tone.PolySynth.prototype.setPreset = function (presetName) {
		        for (var i = 0; i < this.voices.length; i++) {
		            this.voices[i].setPreset(presetName);
		        }
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.PolySynth} this
			 */
		    Tone.PolySynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        for (var i = 0; i < this.voices.length; i++) {
		            this.voices[i].dispose();
		            this.voices[i] = null;
		        }
		        this.voices = null;
		        this._activeVoices = null;
		        this._freeVoices = null;
		        return this;
		    };
		    return Tone.PolySynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Player is an audio file player with start, loop, and stop functions.
			 *  
			 *  @constructor
			 *  @extends {Tone.Source} 
			 *  @param {string|AudioBuffer} url Either the AudioBuffer or the url from
			 *                                  which to load the AudioBuffer
			 *  @param {function=} onload The function to invoke when the buffer is loaded. 
			 *                            Recommended to use Tone.Buffer.onload instead.
			 *  @example
			 * var player = new Tone.Player("./path/to/sample.mp3").toMaster();
			 * Tone.Buffer.onload = function(){
			 * 	player.start();
			 * }
			 */
		    Tone.Player = function () {
		        var options = this.optionsObject(arguments, [
		            'url',
		            'onload'
		        ], Tone.Player.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  @private
				 *  @type {AudioBufferSourceNode}
				 */
		        this._source = null;
		        /**
				 *  If the file should play as soon
				 *  as the buffer is loaded. 
				 *  @type {boolean}
				 *  @example
				 * //will play as soon as it's loaded
				 * var player = new Tone.Player({
				 * 	"url" : "./path/to/sample.mp3",
				 * 	"autostart" : true,
				 * }).toMaster();
				 */
		        this.autostart = options.autostart;
		        /**
				 *  the buffer
				 *  @private
				 *  @type {Tone.Buffer}
				 */
		        this._buffer = new Tone.Buffer({
		            'url': options.url,
		            'onload': this._onload.bind(this, options.onload),
		            'reverse': options.reverse
		        });
		        /**
				 *  if the buffer should loop once it's over
				 *  @type {boolean}
				 *  @private
				 */
		        this._loop = options.loop;
		        /**
				 *  if 'loop' is true, the loop will start at this position
				 *  @type {Time}
				 *  @private
				 */
		        this._loopStart = options.loopStart;
		        /**
				 *  if 'loop' is true, the loop will end at this position
				 *  @type {Time}
				 *  @private
				 */
		        this._loopEnd = options.loopEnd;
		        /**
				 *  the playback rate
				 *  @private
				 *  @type {number}
				 */
		        this._playbackRate = options.playbackRate;
		        /**
				 *  Enabling retrigger will allow a player to be restarted
				 *  before the the previous 'start' is done playing. Otherwise, 
				 *  successive calls to Tone.Player.start will only start
				 *  the sample if it had played all the way through. 
				 *  @type {boolean}
				 */
		        this.retrigger = options.retrigger;
		    };
		    Tone.extend(Tone.Player, Tone.Source);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Player.defaults = {
		        'onload': Tone.noOp,
		        'playbackRate': 1,
		        'loop': false,
		        'autostart': false,
		        'loopStart': 0,
		        'loopEnd': 0,
		        'retrigger': false,
		        'reverse': false
		    };
		    /**
			 *  Load the audio file as an audio buffer.
			 *  Decodes the audio asynchronously and invokes
			 *  the callback once the audio buffer loads. 
			 *  Note: this does not need to be called, if a url
			 *  was passed in to the constructor. Only use this
			 *  if you want to manually load a new url. 
			 * @param {string} url The url of the buffer to load.
			 *                     Filetype support depends on the
			 *                     browser.
			 *  @param  {function=} callback The function to invoke once
			 *                               the sample is loaded.
			 *  @returns {Tone.Player} this
			 */
		    Tone.Player.prototype.load = function (url, callback) {
		        this._buffer.load(url, this._onload.bind(this, callback));
		        return this;
		    };
		    /**
			 * Internal callback when the buffer is loaded.
			 * @private
			 */
		    Tone.Player.prototype._onload = function (callback) {
		        callback(this);
		        if (this.autostart) {
		            this.start();
		        }
		    };
		    /**
			 *  play the buffer between the desired positions
			 *  
			 *  @private
			 *  @param  {Time} [startTime=now] when the player should start.
			 *  @param  {Time} [offset=0] the offset from the beginning of the sample
			 *                                 to start at. 
			 *  @param  {Time=} duration how long the sample should play. If no duration
			 *                                is given, it will default to the full length 
			 *                                of the sample (minus any offset)
			 *  @returns {Tone.Player} this
			 */
		    Tone.Player.prototype._start = function (startTime, offset, duration) {
		        if (this._buffer.loaded) {
		            //if it's a loop the default offset is the loopstart point
		            if (this._loop) {
		                offset = this.defaultArg(offset, this._loopStart);
		            } else {
		                //otherwise the default offset is 0
		                offset = this.defaultArg(offset, 0);
		            }
		            offset = this.toSeconds(offset);
		            duration = this.defaultArg(duration, this._buffer.duration - offset);
		            //the values in seconds
		            startTime = this.toSeconds(startTime);
		            duration = this.toSeconds(duration);
		            //make the source
		            this._source = this.context.createBufferSource();
		            this._source.buffer = this._buffer.get();
		            //set the looping properties
		            if (this._loop) {
		                this._source.loop = this._loop;
		                this._source.loopStart = this.toSeconds(this._loopStart);
		                this._source.loopEnd = this.toSeconds(this._loopEnd);
		                // this fixes a bug in chrome 42 that breaks looping
		                // https://code.google.com/p/chromium/issues/detail?id=457099
		                duration = 65536;
		            } else {
		                this._nextStop = startTime + duration;
		            }
		            //and other properties
		            this._source.playbackRate.value = this._playbackRate;
		            this._source.onended = this.onended;
		            this._source.connect(this.output);
		            //start it
		            this._source.start(startTime, offset, duration);
		        } else {
		            throw Error('tried to start Player before the buffer was loaded');
		        }
		        return this;
		    };
		    /**
			 *  Stop playback.
			 *  @private
			 *  @param  {Time} [time=now]
			 *  @returns {Tone.Player} this
			 */
		    Tone.Player.prototype._stop = function (time) {
		        if (this._source) {
		            this._source.stop(this.toSeconds(time));
		            this._source = null;
		        }
		        return this;
		    };
		    /**
			 *  Set the loop start and end. Will only loop if loop is 
			 *  set to true. 
			 *  @param {Time} loopStart The loop end time
			 *  @param {Time} loopEnd The loop end time
			 *  @returns {Tone.Player} this
			 *  @example
			 * //loop 0.1 seconds of the file. 
			 * player.setLoopPoints(0.2, 0.3);
			 * player.loop = true;
			 */
		    Tone.Player.prototype.setLoopPoints = function (loopStart, loopEnd) {
		        this.loopStart = loopStart;
		        this.loopEnd = loopEnd;
		        return this;
		    };
		    /**
			 * If loop is true, the loop will start at this position. 
			 * @memberOf Tone.Player#
			 * @type {Time}
			 * @name loopStart
			 */
		    Object.defineProperty(Tone.Player.prototype, 'loopStart', {
		        get: function () {
		            return this._loopStart;
		        },
		        set: function (loopStart) {
		            this._loopStart = loopStart;
		            if (this._source) {
		                this._source.loopStart = this.toSeconds(loopStart);
		            }
		        }
		    });
		    /**
			 * If loop is true, the loop will end at this position.
			 * @memberOf Tone.Player#
			 * @type {Time}
			 * @name loopEnd
			 */
		    Object.defineProperty(Tone.Player.prototype, 'loopEnd', {
		        get: function () {
		            return this._loopEnd;
		        },
		        set: function (loopEnd) {
		            this._loopEnd = loopEnd;
		            if (this._source) {
		                this._source.loopEnd = this.toSeconds(loopEnd);
		            }
		        }
		    });
		    /**
			 * The audio buffer belonging to the player. 
			 * @memberOf Tone.Player#
			 * @type {AudioBuffer}
			 * @name buffer
			 */
		    Object.defineProperty(Tone.Player.prototype, 'buffer', {
		        get: function () {
		            return this._buffer;
		        },
		        set: function (buffer) {
		            this._buffer.set(buffer);
		        }
		    });
		    /**
			 * If the buffer should loop once it's over. 
			 * @memberOf Tone.Player#
			 * @type {boolean}
			 * @name loop
			 */
		    Object.defineProperty(Tone.Player.prototype, 'loop', {
		        get: function () {
		            return this._loop;
		        },
		        set: function (loop) {
		            this._loop = loop;
		            if (this._source) {
		                this._source.loop = loop;
		            }
		        }
		    });
		    /**
			 * The playback speed. 1 is normal speed. 
			 * Note that this is not a Tone.Signal because of a bug in Blink. 
			 * Please star [this issue](https://code.google.com/p/chromium/issues/detail?id=311284)
			 * if this an important thing to you.
			 * @memberOf Tone.Player#
			 * @type {number}
			 * @name playbackRate
			 */
		    Object.defineProperty(Tone.Player.prototype, 'playbackRate', {
		        get: function () {
		            return this._playbackRate;
		        },
		        set: function (rate) {
		            this._playbackRate = rate;
		            if (this._source) {
		                this._source.playbackRate.value = rate;
		            }
		        }
		    });
		    /**
			 * The direction the buffer should play in
			 * @memberOf Tone.Player#
			 * @type {boolean}
			 * @name reverse
			 */
		    Object.defineProperty(Tone.Player.prototype, 'reverse', {
		        get: function () {
		            return this._buffer.reverse;
		        },
		        set: function (rev) {
		            this._buffer.reverse = rev;
		        }
		    });
		    /**
			 *  Dispose and disconnect.
			 *  @return {Tone.Player} this
			 */
		    Tone.Player.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        if (this._source !== null) {
		            this._source.disconnect();
		            this._source = null;
		        }
		        this._buffer.dispose();
		        this._buffer = null;
		        return this;
		    };
		    return Tone.Player;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class A sampler instrument which plays an audio buffer 
			 *         through an amplitude envelope and a filter envelope. The sampler takes
			 *         an Object in the constructor which maps a sample name to the URL 
			 *         of the sample. Nested Objects will be flattened and can be accessed using
			 *         a dot notation (see the example).
			 *         <img src="https://docs.google.com/drawings/d/1UK-gi_hxzKDz9Dh4ByyOptuagMOQxv52WxN12HwvtW8/pub?w=931&h=241">
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object|string} urls the urls of the audio file
			 *  @param {Object} [options] the options object for the synth
			 *  @example
			 * var sampler = new Sampler({
			 * 	A : {
			 * 		1 : {"./audio/casio/A1.mp3",
			 * 		2 : "./audio/casio/A2.mp3",
			 * 	},
			 * 	"B.1" : "./audio/casio/B1.mp3",
			 * }).toMaster();
			 * 
			 * //listen for when all the samples have loaded
			 * Tone.Buffer.onload = function(){
			 * 	sampler.triggerAttack("A.1", time, velocity);
			 * };
			 */
		    Tone.Sampler = function (urls, options) {
		        options = this.defaultArg(options, Tone.Sampler.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The sample player.
				 *  @type {Tone.Player}
				 */
		        this.player = new Tone.Player(options.player);
		        this.player.retrigger = true;
		        /**
				 *  the buffers
				 *  @type {Object}
				 *  @private
				 */
		        this._buffers = {};
		        /**
				 *  The amplitude envelope. 
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        /**
				 *  The filter envelope. 
				 *  @type {Tone.ScaledEnvelope}
				 */
		        this.filterEnvelope = new Tone.ScaledEnvelope(options.filterEnvelope);
		        /**
				 *  The name of the current sample. 
				 *  @type {string}
				 *  @private
				 */
		        this._sample = options.sample;
		        /**
				 * the private reference to the pitch
				 * @type {number}
				 * @private
				 */
		        this._pitch = options.pitch;
		        /**
				 *  The filter.
				 *  @type {Tone.Filter}
				 */
		        this.filter = new Tone.Filter(options.filter);
		        //connections / setup
		        this._loadBuffers(urls);
		        this.pitch = options.pitch;
		        this.player.chain(this.filter, this.envelope, this.output);
		        this.filterEnvelope.connect(this.filter.frequency);
		        this._readOnly([
		            'player',
		            'filterEnvelope',
		            'envelope',
		            'filter'
		        ]);
		    };
		    Tone.extend(Tone.Sampler, Tone.Instrument);
		    /**
			 *  the default parameters
			 *  @static
			 */
		    Tone.Sampler.defaults = {
		        'sample': 0,
		        'pitch': 0,
		        'player': { 'loop': false },
		        'envelope': {
		            'attack': 0.001,
		            'decay': 0,
		            'sustain': 1,
		            'release': 0.1
		        },
		        'filterEnvelope': {
		            'attack': 0.001,
		            'decay': 0.001,
		            'sustain': 1,
		            'release': 0.5,
		            'min': 20,
		            'max': 20000,
		            'exponent': 2
		        },
		        'filter': { 'type': 'lowpass' }
		    };
		    /**
			 *  load the buffers
			 *  @param   {Object} urls   the urls
			 *  @private
			 */
		    Tone.Sampler.prototype._loadBuffers = function (urls) {
		        if (typeof urls === 'string') {
		            this._buffers['0'] = new Tone.Buffer(urls, function () {
		                this.sample = '0';
		            }.bind(this));
		        } else {
		            urls = this._flattenUrls(urls);
		            for (var buffName in urls) {
		                this._sample = buffName;
		                var urlString = urls[buffName];
		                this._buffers[buffName] = new Tone.Buffer(urlString);
		            }
		        }
		    };
		    /**
			 *  Flatten an object into a single depth object. 
			 *  thanks to https://gist.github.com/penguinboy/762197
			 *  @param   {Object} ob 	
			 *  @return  {Object}    
			 *  @private
			 */
		    Tone.Sampler.prototype._flattenUrls = function (ob) {
		        var toReturn = {};
		        for (var i in ob) {
		            if (!ob.hasOwnProperty(i))
		                continue;
		            if (typeof ob[i] == 'object') {
		                var flatObject = this._flattenUrls(ob[i]);
		                for (var x in flatObject) {
		                    if (!flatObject.hasOwnProperty(x))
		                        continue;
		                    toReturn[i + '.' + x] = flatObject[x];
		                }
		            } else {
		                toReturn[i] = ob[i];
		            }
		        }
		        return toReturn;
		    };
		    /**
			 *  Start the sample and simultaneously trigger the envelopes. 
			 *  @param {string=} sample The name of the sample to trigger, defaults to
			 *                          the last sample used. 
			 *  @param {Time} [time=now] The time when the sample should start
			 *  @param {number} [velocity=1] The velocity of the note
			 *  @returns {Tone.Sampler} this
			 *  @example
			 * sampler.triggerAttack("B.1");
			 */
		    Tone.Sampler.prototype.triggerAttack = function (name, time, velocity) {
		        time = this.toSeconds(time);
		        if (name) {
		            this.sample = name;
		        }
		        this.player.start(time);
		        this.envelope.triggerAttack(time, velocity);
		        this.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  Start the release portion of the sample. Will stop the sample once the 
			 *  envelope has fully released. 
			 *  
			 *  @param {Time} [time=now] The time when the note should release
			 *  @returns {Tone.Sampler} this
			 *  @example
			 * sampler.triggerRelease();
			 */
		    Tone.Sampler.prototype.triggerRelease = function (time) {
		        time = this.toSeconds(time);
		        this.filterEnvelope.triggerRelease(time);
		        this.envelope.triggerRelease(time);
		        this.player.stop(this.toSeconds(this.envelope.release) + time);
		        return this;
		    };
		    /**
			 * The name of the sample to trigger.
			 * @memberOf Tone.Sampler#
			 * @type {number|string}
			 * @name sample
			 * @example
			 * //set the sample to "A.2" for next time the sample is triggered
			 * sampler.sample = "A.2";
			 */
		    Object.defineProperty(Tone.Sampler.prototype, 'sample', {
		        get: function () {
		            return this._sample;
		        },
		        set: function (name) {
		            if (this._buffers.hasOwnProperty(name)) {
		                this._sample = name;
		                this.player.buffer = this._buffers[name];
		            } else {
		                throw new Error('Sampler does not have a sample named ' + name);
		            }
		        }
		    });
		    /**
			 * The direction the buffer should play in
			 * @memberOf Tone.Sampler#
			 * @type {boolean}
			 * @name reverse
			 */
		    Object.defineProperty(Tone.Sampler.prototype, 'reverse', {
		        get: function () {
		            for (var i in this._buffers) {
		                return this._buffers[i].reverse;
		            }
		        },
		        set: function (rev) {
		            for (var i in this._buffers) {
		                this._buffers[i].reverse = rev;
		            }
		        }
		    });
		    /**
			 * Repitch the sampled note by some interval (measured
			 * in semi-tones). 
			 * @memberOf Tone.Sampler#
			 * @type {Interval}
			 * @name pitch
			 * @example
			 * sampler.pitch = -12; //down one octave
			 * sampler.pitch = 7; //up a fifth
			 */
		    Object.defineProperty(Tone.Sampler.prototype, 'pitch', {
		        get: function () {
		            return this._pitch;
		        },
		        set: function (interval) {
		            this._pitch = interval;
		            this.player.playbackRate = this.intervalToFrequencyRatio(interval);
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.Sampler} this
			 */
		    Tone.Sampler.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._writable([
		            'player',
		            'filterEnvelope',
		            'envelope',
		            'filter'
		        ]);
		        this.player.dispose();
		        this.filterEnvelope.dispose();
		        this.envelope.dispose();
		        this.filter.dispose();
		        this.player = null;
		        this.filterEnvelope = null;
		        this.envelope = null;
		        this.filter = null;
		        for (var sample in this._buffers) {
		            this._buffers[sample].dispose();
		            this._buffers[sample] = null;
		        }
		        this._buffers = null;
		        return this;
		    };
		    return Tone.Sampler;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.SimpleSynth is composed simply of a Tone.OmniOscillator
			 *          routed through a Tone.AmplitudeEnvelope. 
			 *          <img src="https://docs.google.com/drawings/d/1-1_0YW2Z1J2EPI36P8fNCMcZG7N1w1GZluPs4og4evo/pub?w=1163&h=231">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var synth = new Tone.SimpleSynth().toMaster();
			 * synth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.SimpleSynth = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.SimpleSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The oscillator.
				 *  @type {Tone.OmniOscillator}
				 */
		        this.oscillator = new Tone.OmniOscillator(options.oscillator);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this.oscillator.frequency;
		        /**
				 *  The detune control.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this.oscillator.detune;
		        /**
				 *  The amplitude envelope.
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        //connect the oscillators to the output
		        this.oscillator.chain(this.envelope, this.output);
		        //start the oscillators
		        this.oscillator.start();
		        this._readOnly([
		            'oscillator',
		            'frequency',
		            'detune',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.SimpleSynth, Tone.Monophonic);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.SimpleSynth.defaults = {
		        'oscillator': { 'type': 'triangle' },
		        'envelope': {
		            'attack': 0.005,
		            'decay': 0.1,
		            'sustain': 0.3,
		            'release': 1
		        }
		    };
		    /**
			 *  start the attack portion of the envelope
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {number} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.SimpleSynth} this
			 *  @private
			 */
		    Tone.SimpleSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the envelopes
		        this.envelope.triggerAttack(time, velocity);
		        return this;
		    };
		    /**
			 *  start the release portion of the envelope
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.SimpleSynth} this
			 *  @private
			 */
		    Tone.SimpleSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.SimpleSynth} this
			 */
		    Tone.SimpleSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'oscillator',
		            'frequency',
		            'detune',
		            'envelope'
		        ]);
		        this.oscillator.dispose();
		        this.oscillator = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        this.frequency = null;
		        this.detune = null;
		        return this;
		    };
		    return Tone.SimpleSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class   AMSynth uses the output of one Tone.SimpleSynth to modulate the
			 *          amplitude of another Tone.SimpleSynth. The harmonicity (the ratio between
			 *          the two signals) affects the timbre of the output signal the most.
			 *          Read more about Amplitude Modulation Synthesis on [SoundOnSound](http://www.soundonsound.com/sos/mar00/articles/synthsecrets.htm).
			 *          <img src="https://docs.google.com/drawings/d/1p_os_As-N1bpnK8u55gXlgVw3U7BfquLX0Wj57kSZXY/pub?w=1009&h=457">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var synth = new Tone.SimpleAM().toMaster();
			 * synth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.SimpleAM = function (options) {
		        options = this.defaultArg(options, Tone.SimpleAM.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The carrier voice. 
				 *  @type {Tone.SimpleSynth}
				 */
		        this.carrier = new Tone.SimpleSynth(options.carrier);
		        /**
				 *  The modulator voice. 
				 *  @type {Tone.SimpleSynth}
				 */
		        this.modulator = new Tone.SimpleSynth(options.modulator);
		        /**
				 *  the frequency control
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  The ratio between the carrier and the modulator frequencies. A value of 1
				 *  makes both voices in unison, a value of 0.5 puts the modulator an octave below
				 *  the carrier.
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //set the modulator an octave above the carrier frequency
				 * simpleAM.harmonicity.value = 2;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  convert the -1,1 output to 0,1
				 *  @type {Tone.AudioToGain}
				 *  @private
				 */
		        this._modulationScale = new Tone.AudioToGain();
		        /**
				 *  the node where the modulation happens
				 *  @type {GainNode}
				 *  @private
				 */
		        this._modulationNode = this.context.createGain();
		        //control the two voices frequency
		        this.frequency.connect(this.carrier.frequency);
		        this.frequency.chain(this.harmonicity, this.modulator.frequency);
		        this.modulator.chain(this._modulationScale, this._modulationNode.gain);
		        this.carrier.chain(this._modulationNode, this.output);
		        this._readOnly([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity'
		        ]);
		    };
		    Tone.extend(Tone.SimpleAM, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.SimpleAM.defaults = {
		        'harmonicity': 3,
		        'carrier': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0.01,
		                'sustain': 1,
		                'release': 0.5
		            }
		        },
		        'modulator': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'envelope': {
		                'attack': 0.5,
		                'decay': 0.1,
		                'sustain': 1,
		                'release': 0.5
		            }
		        }
		    };
		    /**
			 *  trigger the attack portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will occur
			 *  @param {number} [velocity=1] the velocity of the note
			 *  @returns {Tone.SimpleAM} this
			 *  @private
			 */
		    Tone.SimpleAM.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the port glide
		        time = this.toSeconds(time);
		        //the envelopes
		        this.carrier.envelope.triggerAttack(time, velocity);
		        this.modulator.envelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  trigger the release portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @returns {Tone.SimpleAM} this
			 *  @private
			 */
		    Tone.SimpleAM.prototype._triggerEnvelopeRelease = function (time) {
		        this.carrier.triggerRelease(time);
		        this.modulator.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.SimpleAM} this
			 */
		    Tone.SimpleAM.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity'
		        ]);
		        this.carrier.dispose();
		        this.carrier = null;
		        this.modulator.dispose();
		        this.modulator = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._modulationScale.dispose();
		        this._modulationScale = null;
		        this._modulationNode.disconnect();
		        this._modulationNode = null;
		        return this;
		    };
		    return Tone.SimpleAM;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  SimpleFM is composed of two Tone.SimpleSynths where one Tone.SimpleSynth modulates
			 *          the frequency of a second Tone.SimpleSynth. A lot of spectral content 
			 *          can be explored using the Tone.FMSynth.modulationIndex parameter. Read more about
			 *          frequency modulation synthesis on [SoundOnSound](http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm).
			 *          <img src="https://docs.google.com/drawings/d/1hSU25lLjDk_WJ59DSitQm6iCRpcMWVEAYqBjwmqtRVw/pub?w=902&h=462">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var fmSynth = new Tone.SimpleFM().toMaster();
			 * fmSynth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.SimpleFM = function (options) {
		        options = this.defaultArg(options, Tone.SimpleFM.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The carrier voice. 
				 *  @type {Tone.SimpleSynth}
				 */
		        this.carrier = new Tone.SimpleSynth(options.carrier);
		        this.carrier.volume.value = -10;
		        /**
				 *  The modulator voice. 
				 *  @type {Tone.SimpleSynth}
				 */
		        this.modulator = new Tone.SimpleSynth(options.modulator);
		        this.modulator.volume.value = -10;
		        /**
				 *  the frequency control
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  Harmonicity is the ratio between the two voices. A harmonicity of
				 *  1 is no change. Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch voice1 an octave below voice0
				 * synth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the 
				 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the 
				 *  modulating signal (ma) -- as in ma/mf. 
				 *	@type {Positive}
				 *	@signal
				 */
		        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
		        this.modulationIndex.units = Tone.Type.Positive;
		        /**
				 *  the node where the modulation happens
				 *  @type {GainNode}
				 *  @private
				 */
		        this._modulationNode = this.context.createGain();
		        //control the two voices frequency
		        this.frequency.connect(this.carrier.frequency);
		        this.frequency.chain(this.harmonicity, this.modulator.frequency);
		        this.frequency.chain(this.modulationIndex, this._modulationNode);
		        this.modulator.connect(this._modulationNode.gain);
		        this._modulationNode.gain.value = 0;
		        this._modulationNode.connect(this.carrier.frequency);
		        this.carrier.connect(this.output);
		        this._readOnly([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity',
		            'modulationIndex'
		        ]);
		        ;
		    };
		    Tone.extend(Tone.SimpleFM, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.SimpleFM.defaults = {
		        'harmonicity': 3,
		        'modulationIndex': 10,
		        'carrier': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            }
		        },
		        'modulator': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'triangle' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            }
		        }
		    };
		    /**
			 *  trigger the attack portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will occur
			 *  @param {number} [velocity=1] the velocity of the note
			 *  @returns {Tone.SimpleFM} this
			 *  @private
			 */
		    Tone.SimpleFM.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the port glide
		        time = this.toSeconds(time);
		        //the envelopes
		        this.carrier.envelope.triggerAttack(time, velocity);
		        this.modulator.envelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  trigger the release portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @returns {Tone.SimpleFM} this
			 *  @private
			 */
		    Tone.SimpleFM.prototype._triggerEnvelopeRelease = function (time) {
		        this.carrier.triggerRelease(time);
		        this.modulator.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.SimpleFM} this
			 */
		    Tone.SimpleFM.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity',
		            'modulationIndex'
		        ]);
		        this.carrier.dispose();
		        this.carrier = null;
		        this.modulator.dispose();
		        this.modulator = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this.modulationIndex.dispose();
		        this.modulationIndex = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._modulationNode.disconnect();
		        this._modulationNode = null;
		        return this;
		    };
		    return Tone.SimpleFM;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Tone.Effect is the base class for effects. Connect the effect between
			 * 	        the effectSend and effectReturn GainNodes, then control the amount of
			 * 	        effect which goes to the output using the wet control.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {NormalRange|Object} [wet] The starting wet value. 
			 */
		    Tone.Effect = function () {
		        Tone.call(this);
		        //get all of the defaults
		        var options = this.optionsObject(arguments, ['wet'], Tone.Effect.defaults);
		        /**
				 *  the drywet knob to control the amount of effect
				 *  @type {Tone.CrossFade}
				 *  @private
				 */
		        this._dryWet = new Tone.CrossFade(options.wet);
		        /**
				 *  The wet control is how much of the effected
				 *  will pass through to the output. 1 = 100% effected
				 *  signal, 0 = 100% dry signal. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.wet = this._dryWet.fade;
		        /**
				 *  connect the effectSend to the input of hte effect
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectSend = this.context.createGain();
		        /**
				 *  connect the output of the effect to the effectReturn
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectReturn = this.context.createGain();
		        //connections
		        this.input.connect(this._dryWet.a);
		        this.input.connect(this.effectSend);
		        this.effectReturn.connect(this._dryWet.b);
		        this._dryWet.connect(this.output);
		        this._readOnly(['wet']);
		    };
		    Tone.extend(Tone.Effect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Effect.defaults = { 'wet': 1 };
		    /**
			 *  chains the effect in between the effectSend and effectReturn
			 *  @param  {Tone} effect
			 *  @private
			 *  @returns {Tone.Effect} this
			 */
		    Tone.Effect.prototype.connectEffect = function (effect) {
		        this.effectSend.chain(effect, this.effectReturn);
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Effect} this
			 */
		    Tone.Effect.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._dryWet.dispose();
		        this._dryWet = null;
		        this.effectSend.disconnect();
		        this.effectSend = null;
		        this.effectReturn.disconnect();
		        this.effectReturn = null;
		        this._writable(['wet']);
		        this.wet = null;
		        return this;
		    };
		    return Tone.Effect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.
			 *         Setting the LFO rate and depth allows for control over the filter modulation rate 
			 *         and depth.
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Time|Object} [frequency] The rate of the LFO.
			 *  @param {Frequency} [min] The lower value of the LFOs oscillation
		 	 *  @param {Frequency} [max] The upper value of the LFOs oscillation. 
			 *  @example
			 * //create an autofilter and start it's LFO
			 * var autoFilter = new Tone.AutoFilter("4n").toMaster().start();
			 * //route an oscillator through the filter and start it
			 * var oscillator = new Tone.Oscillator().connect(autoFilter).start();
			 */
		    Tone.AutoFilter = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'min',
		            'max'
		        ], Tone.AutoFilter.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  the lfo which drives the filter cutoff
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfo = new Tone.LFO({
		            'frequency': options.frequency,
		            'amplitude': options.depth,
		            'min': options.min,
		            'max': options.max
		        });
		        /**
				 * The range of the filter modulating between the min and max frequency. 
				 * 0 = no modulation. 1 = full modulation.
				 * @type {NormalRange}
				 * @signal
				 */
		        this.depth = this._lfo.amplitude;
		        /**
				 * How fast the filter modulates between min and max. 
				 * @type {Frequency}
				 * @signal
				 */
		        this.frequency = this._lfo.frequency;
		        /**
				 *  The filter node
				 *  @type {Tone.Filter}
				 */
		        this.filter = new Tone.Filter(options.filter);
		        //connections
		        this.connectEffect(this.filter);
		        this._lfo.connect(this.filter.frequency);
		        this.type = options.type;
		        this._readOnly([
		            'frequency',
		            'depth'
		        ]);
		    };
		    //extend Effect
		    Tone.extend(Tone.AutoFilter, Tone.Effect);
		    /**
			 *  defaults
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AutoFilter.defaults = {
		        'frequency': 1,
		        'type': 'sine',
		        'depth': 1,
		        'min': 200,
		        'max': 1200,
		        'filter': {
		            'type': 'lowpass',
		            'rolloff': -12,
		            'Q': 1
		        }
		    };
		    /**
			 * Start the effect.
			 * @param {Time} [time=now] When the LFO will start. 
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.start = function (time) {
		        this._lfo.start(time);
		        return this;
		    };
		    /**
			 * Stop the effect.
			 * @param {Time} [time=now] When the LFO will stop. 
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.stop = function (time) {
		        this._lfo.stop(time);
		        return this;
		    };
		    /**
			 * Sync the filter to the transport.
			 * @param {Time} [delay=0] Delay time before starting the effect after the
			 *                               Transport has started. 
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.sync = function (delay) {
		        this._lfo.sync(delay);
		        return this;
		    };
		    /**
			 * Unsync the filter from the transport.
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.unsync = function () {
		        this._lfo.unsync();
		        return this;
		    };
		    /**
			 * Type of oscillator attached to the AutoFilter. 
			 * Possible values: "sine", "square", "triangle", "sawtooth".
			 * @memberOf Tone.AutoFilter#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.AutoFilter.prototype, 'type', {
		        get: function () {
		            return this._lfo.type;
		        },
		        set: function (type) {
		            this._lfo.type = type;
		        }
		    });
		    /**
			 * The minimum value of the LFO attached to the cutoff frequency of the filter.
			 * @memberOf Tone.AutoFilter#
			 * @type {Frequency}
			 * @name min
			 */
		    Object.defineProperty(Tone.AutoFilter.prototype, 'min', {
		        get: function () {
		            return this._lfo.min;
		        },
		        set: function (min) {
		            this._lfo.min = min;
		        }
		    });
		    /**
			 * The minimum value of the LFO attached to the cutoff frequency of the filter.
			 * @memberOf Tone.AutoFilter#
			 * @type {Frequency}
			 * @name max
			 */
		    Object.defineProperty(Tone.AutoFilter.prototype, 'max', {
		        get: function () {
		            return this._lfo.max;
		        },
		        set: function (max) {
		            this._lfo.max = max;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._lfo.dispose();
		        this._lfo = null;
		        this.filter.dispose();
		        this.filter = null;
		        this._writable([
		            'frequency',
		            'depth'
		        ]);
		        this.frequency = null;
		        this.depth = null;
		        return this;
		    };
		    return Tone.AutoFilter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.AutoPanner is a Tone.Panner with an LFO connected to the pan amount. 
			 *         More on using autopanners [here](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Frequency|Object} [frequency] Rate of left-right oscillation. 
			 *  @example
			 * //create an autopanner and start it's LFO
			 * var autoPanner = new Tone.AutoPanner("4n").toMaster().start();
			 * //route an oscillator through the panner and start it
			 * var oscillator = new Tone.Oscillator().connect(autoPanner).start();
			 */
		    Tone.AutoPanner = function () {
		        var options = this.optionsObject(arguments, ['frequency'], Tone.AutoPanner.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  the lfo which drives the panning
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfo = new Tone.LFO({
		            'frequency': options.frequency,
		            'amplitude': options.depth,
		            'min': 0,
		            'max': 1,
		            //start at the middle of the cycle
		            'phase': 90
		        });
		        /**
				 * The amount of panning between left and right. 
				 * 0 = always center. 1 = full range between left and right. 
				 * @type {NormalRange}
				 * @signal
				 */
		        this.depth = this._lfo.amplitude;
		        /**
				 *  the panner node which does the panning
				 *  @type {Tone.Panner}
				 *  @private
				 */
		        this._panner = new Tone.Panner();
		        /**
				 * How fast the panner modulates between left and right. 
				 * @type {Frequency}
				 * @signal
				 */
		        this.frequency = this._lfo.frequency;
		        //connections
		        this.connectEffect(this._panner);
		        this._lfo.connect(this._panner.pan);
		        this.type = options.type;
		        this._readOnly([
		            'depth',
		            'frequency'
		        ]);
		    };
		    //extend Effect
		    Tone.extend(Tone.AutoPanner, Tone.Effect);
		    /**
			 *  defaults
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AutoPanner.defaults = {
		        'frequency': 1,
		        'type': 'sine',
		        'depth': 1
		    };
		    /**
			 * Start the effect.
			 * @param {Time} [time=now] When the LFO will start. 
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.start = function (time) {
		        this._lfo.start(time);
		        return this;
		    };
		    /**
			 * Stop the effect.
			 * @param {Time} [time=now] When the LFO will stop. 
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.stop = function (time) {
		        this._lfo.stop(time);
		        return this;
		    };
		    /**
			 * Sync the panner to the transport.
			 * @param {Time} [delay=0] Delay time before starting the effect after the
			 *                               Transport has started. 
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.sync = function (delay) {
		        this._lfo.sync(delay);
		        return this;
		    };
		    /**
			 * Unsync the panner from the transport
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.unsync = function () {
		        this._lfo.unsync();
		        return this;
		    };
		    /**
			 * Type of oscillator attached to the AutoFilter. 
			 * Possible values: "sine", "square", "triangle", "sawtooth".
			 * @memberOf Tone.AutoFilter#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.AutoPanner.prototype, 'type', {
		        get: function () {
		            return this._lfo.type;
		        },
		        set: function (type) {
		            this._lfo.type = type;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._lfo.dispose();
		        this._lfo = null;
		        this._panner.dispose();
		        this._panner = null;
		        this._writable([
		            'depth',
		            'frequency'
		        ]);
		        this.frequency = null;
		        this.depth = null;
		        return this;
		    };
		    return Tone.AutoPanner;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.AutoWah connects a Tone.Follower to a bandpass filter (Tone.Filter).
			 *          The frequency of the filter is adjusted proportionally to the 
			 *          incoming signal's amplitude. Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Frequency|Object} [baseFrequency] The frequency the filter is set 
			 *                                            to at the low point of the wah
			 *  @param {Positive} [octaves] The number of octaves above the baseFrequency
			 *                                the filter will sweep to when fully open
			 *  @param {Decibels} [sensitivity] The decibel threshold sensitivity for 
			 *                                   the incoming signal. Normal range of -40 to 0. 
			 *  @example
			 * var autoWah = new Tone.AutoWah(50, 6, -30).toMaster();
			 * //initialize the synth and connect to autowah
			 * var synth = new SimpleSynth.connect(autoWah);
			 * //Q value influences the effect of the wah - default is 2
			 * autoWah.Q.value = 6;
			 * //more audible on higher notes
			 * synth.triggerAttackRelease("C4", "8n")
			 */
		    Tone.AutoWah = function () {
		        var options = this.optionsObject(arguments, [
		            'baseFrequency',
		            'octaves',
		            'sensitivity'
		        ], Tone.AutoWah.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  The envelope follower. Set the attack/release
				 *  timing to adjust how the envelope is followed. 
				 *  @type {Tone.Follower}
				 *  @private
				 */
		        this.follower = new Tone.Follower(options.follower);
		        /**
				 *  scales the follower value to the frequency domain
				 *  @type {Tone}
				 *  @private
				 */
		        this._sweepRange = new Tone.ScaleExp(0, 1, 0.5);
		        /**
				 *  @type {number}
				 *  @private
				 */
		        this._baseFrequency = options.baseFrequency;
		        /**
				 *  @type {number}
				 *  @private
				 */
		        this._octaves = options.octaves;
		        /**
				 *  the input gain to adjust the sensitivity
				 *  @type {GainNode}
				 *  @private
				 */
		        this._inputBoost = this.context.createGain();
		        /**
				 *  @type {BiquadFilterNode}
				 *  @private
				 */
		        this._bandpass = new Tone.Filter({
		            'rolloff': -48,
		            'frequency': 0,
		            'Q': options.Q
		        });
		        /**
				 *  @type {Tone.Filter}
				 *  @private
				 */
		        this._peaking = new Tone.Filter(0, 'peaking');
		        this._peaking.gain.value = options.gain;
		        /**
				 * The gain of the filter.
				 * @type {Gain}
				 * @signal
				 */
		        this.gain = this._peaking.gain;
		        /**
				 * The quality of the filter.
				 * @type {Positive}
				 * @signal
				 */
		        this.Q = this._bandpass.Q;
		        //the control signal path
		        this.effectSend.chain(this._inputBoost, this.follower, this._sweepRange);
		        this._sweepRange.connect(this._bandpass.frequency);
		        this._sweepRange.connect(this._peaking.frequency);
		        //the filtered path
		        this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);
		        //set the initial value
		        this._setSweepRange();
		        this.sensitivity = options.sensitivity;
		        this._readOnly([
		            'gain',
		            'Q'
		        ]);
		    };
		    Tone.extend(Tone.AutoWah, Tone.Effect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AutoWah.defaults = {
		        'baseFrequency': 100,
		        'octaves': 6,
		        'sensitivity': 0,
		        'Q': 2,
		        'gain': 2,
		        'follower': {
		            'attack': 0.3,
		            'release': 0.5
		        }
		    };
		    /**
			 * The number of octaves that the filter will sweep above the 
			 * baseFrequency. 
			 * @memberOf Tone.AutoWah#
			 * @type {Number}
			 * @name octaves
			 */
		    Object.defineProperty(Tone.AutoWah.prototype, 'octaves', {
		        get: function () {
		            return this._octaves;
		        },
		        set: function (octaves) {
		            this._octaves = octaves;
		            this._setSweepRange();
		        }
		    });
		    /**
			 * The base frequency from which the sweep will start from.
			 * @memberOf Tone.AutoWah#
			 * @type {Frequency}
			 * @name baseFrequency
			 */
		    Object.defineProperty(Tone.AutoWah.prototype, 'baseFrequency', {
		        get: function () {
		            return this._baseFrequency;
		        },
		        set: function (baseFreq) {
		            this._baseFrequency = baseFreq;
		            this._setSweepRange();
		        }
		    });
		    /**
			 * The sensitivity to control how responsive to the input signal the filter is. 
			 * @memberOf Tone.AutoWah#
			 * @type {Decibels}
			 * @name sensitivity
			 */
		    Object.defineProperty(Tone.AutoWah.prototype, 'sensitivity', {
		        get: function () {
		            return this.gainToDb(1 / this._inputBoost.gain.value);
		        },
		        set: function (sensitivy) {
		            this._inputBoost.gain.value = 1 / this.dbToGain(sensitivy);
		        }
		    });
		    /**
			 *  sets the sweep range of the scaler
			 *  @private
			 */
		    Tone.AutoWah.prototype._setSweepRange = function () {
		        this._sweepRange.min = this._baseFrequency;
		        this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.AutoWah} this
			 */
		    Tone.AutoWah.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this.follower.dispose();
		        this.follower = null;
		        this._sweepRange.dispose();
		        this._sweepRange = null;
		        this._bandpass.dispose();
		        this._bandpass = null;
		        this._peaking.dispose();
		        this._peaking = null;
		        this._inputBoost.disconnect();
		        this._inputBoost = null;
		        this._writable([
		            'gain',
		            'Q'
		        ]);
		        this.gain = null;
		        this.Q = null;
		        return this;
		    };
		    return Tone.AutoWah;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Bitcrusher downsamples the incoming signal to a different bitdepth. 
			 *         Lowering the bitdepth of the signal creates distortion. Read more about Bitcrushing
			 *         on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Number} bits The number of bits to downsample the signal. Nominal range
			 *                       of 1 to 8. 
			 *  @example
			 * //initialize crusher and route a synth through it
			 * var crusher = new Tone.BitCrusher(4).toMaster();
			 * var synth = new Tone.MonoSynth().connect(crusher);
			 */
		    Tone.BitCrusher = function () {
		        var options = this.optionsObject(arguments, ['bits'], Tone.BitCrusher.defaults);
		        Tone.Effect.call(this, options);
		        var invStepSize = 1 / Math.pow(2, options.bits - 1);
		        /**
				 *  Subtract the input signal and the modulus of the input signal
				 *  @type {Tone.Subtract}
				 *  @private
				 */
		        this._subtract = new Tone.Subtract();
		        /**
				 *  The mod function
				 *  @type  {Tone.Modulo}
				 *  @private
				 */
		        this._modulo = new Tone.Modulo(invStepSize);
		        /**
				 *  keeps track of the bits
				 *  @type {number}
				 *  @private
				 */
		        this._bits = options.bits;
		        //connect it up
		        this.effectSend.fan(this._subtract, this._modulo);
		        this._modulo.connect(this._subtract, 0, 1);
		        this._subtract.connect(this.effectReturn);
		    };
		    Tone.extend(Tone.BitCrusher, Tone.Effect);
		    /**
			 *  the default values
			 *  @static
			 *  @type {Object}
			 */
		    Tone.BitCrusher.defaults = { 'bits': 4 };
		    /**
			 * The bit depth of the effect. Nominal range of 1-8. 
			 * @memberOf Tone.BitCrusher#
			 * @type {number}
			 * @name bits
			 */
		    Object.defineProperty(Tone.BitCrusher.prototype, 'bits', {
		        get: function () {
		            return this._bits;
		        },
		        set: function (bits) {
		            this._bits = bits;
		            var invStepSize = 1 / Math.pow(2, bits - 1);
		            this._modulo.value = invStepSize;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.BitCrusher} this
			 */
		    Tone.BitCrusher.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._subtract.dispose();
		        this._subtract = null;
		        this._modulo.dispose();
		        this._modulo = null;
		        return this;
		    };
		    return Tone.BitCrusher;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.ChebyShev is a Chebyshev waveshaper, an effect which is good 
			 *         for making different types of distortion sounds.
			 *         Note that odd orders sound very different from even ones, 
			 *         and order = 1 is no change. 
			 *         Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {Positive|Object} [order] The order of the chebyshev polynomial. Normal range between 1-100. 
			 *  @example
			 * //create a new cheby
			 * var cheby = new Tone.Chebyshev(50);
			 * //create a monosynth connected to our cheby
			 * synth = new Tone.MonoSynth().connect(cheby);
			 */
		    Tone.Chebyshev = function () {
		        var options = this.optionsObject(arguments, ['order'], Tone.Chebyshev.defaults);
		        Tone.Effect.call(this);
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._shaper = new Tone.WaveShaper(4096);
		        /**
				 * holds onto the order of the filter
				 * @type {number}
				 * @private
				 */
		        this._order = options.order;
		        this.connectEffect(this._shaper);
		        this.order = options.order;
		        this.oversample = options.oversample;
		    };
		    Tone.extend(Tone.Chebyshev, Tone.Effect);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Chebyshev.defaults = {
		        'order': 1,
		        'oversample': 'none'
		    };
		    /**
			 *  get the coefficient for that degree
			 *  @param {number} x the x value
			 *  @param   {number} degree 
			 *  @param {Object} memo memoize the computed value. 
			 *                       this speeds up computation greatly. 
			 *  @return  {number}       the coefficient 
			 *  @private
			 */
		    Tone.Chebyshev.prototype._getCoefficient = function (x, degree, memo) {
		        if (memo.hasOwnProperty(degree)) {
		            return memo[degree];
		        } else if (degree === 0) {
		            memo[degree] = 0;
		        } else if (degree === 1) {
		            memo[degree] = x;
		        } else {
		            memo[degree] = 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo);
		        }
		        return memo[degree];
		    };
		    /**
			 * The order of the Chebyshev polynomial which creates
			 * the equation which is applied to the incoming 
			 * signal through a Tone.WaveShaper. The equations
			 * are in the form:<br>
			 * order 2: 2x^2 + 1<br>
			 * order 3: 4x^3 + 3x <br>
			 * @memberOf Tone.Chebyshev#
			 * @type {Positive}
			 * @name order
			 */
		    Object.defineProperty(Tone.Chebyshev.prototype, 'order', {
		        get: function () {
		            return this._order;
		        },
		        set: function (order) {
		            this._order = order;
		            var curve = new Array(4096);
		            var len = curve.length;
		            for (var i = 0; i < len; ++i) {
		                var x = i * 2 / len - 1;
		                if (x === 0) {
		                    //should output 0 when input is 0
		                    curve[i] = 0;
		                } else {
		                    curve[i] = this._getCoefficient(x, order, {});
		                }
		            }
		            this._shaper.curve = curve;
		        }
		    });
		    /**
			 * The oversampling of the effect. Can either be "none", "2x" or "4x".
			 * @memberOf Tone.Chebyshev#
			 * @type {string}
			 * @name oversample
			 */
		    Object.defineProperty(Tone.Chebyshev.prototype, 'oversample', {
		        get: function () {
		            return this._shaper.oversample;
		        },
		        set: function (oversampling) {
		            this._shaper.oversample = oversampling;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Chebyshev} this
			 */
		    Tone.Chebyshev.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._shaper.dispose();
		        this._shaper = null;
		        return this;
		    };
		    return Tone.Chebyshev;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Base class for Stereo effects. Provides effectSendL/R and effectReturnL/R. 
			 *
			 *	@constructor
			 *	@extends {Tone.Effect}
			 */
		    Tone.StereoEffect = function () {
		        Tone.call(this);
		        //get the defaults
		        var options = this.optionsObject(arguments, ['wet'], Tone.Effect.defaults);
		        /**
				 *  the drywet knob to control the amount of effect
				 *  @type {Tone.CrossFade}
				 *  @private
				 */
		        this._dryWet = new Tone.CrossFade(options.wet);
		        /**
				 *  The wet control, i.e. how much of the effected
				 *  will pass through to the output. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.wet = this._dryWet.fade;
		        /**
				 *  then split it
				 *  @type {Tone.Split}
				 *  @private
				 */
		        this._split = new Tone.Split();
		        /**
				 *  the effects send LEFT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectSendL = this._split.left;
		        /**
				 *  the effects send RIGHT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectSendR = this._split.right;
		        /**
				 *  the stereo effect merger
				 *  @type {Tone.Merge}
				 *  @private
				 */
		        this._merge = new Tone.Merge();
		        /**
				 *  the effect return LEFT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectReturnL = this._merge.left;
		        /**
				 *  the effect return RIGHT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectReturnR = this._merge.right;
		        //connections
		        this.input.connect(this._split);
		        //dry wet connections
		        this.input.connect(this._dryWet, 0, 0);
		        this._merge.connect(this._dryWet, 0, 1);
		        this._dryWet.connect(this.output);
		        this._readOnly(['wet']);
		    };
		    Tone.extend(Tone.StereoEffect, Tone.Effect);
		    /**
			 *  Clean up. 
			 *  @returns {Tone.StereoEffect} this
			 */
		    Tone.StereoEffect.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._dryWet.dispose();
		        this._dryWet = null;
		        this._split.dispose();
		        this._split = null;
		        this._merge.dispose();
		        this._merge = null;
		        this.effectSendL = null;
		        this.effectSendR = null;
		        this.effectReturnL = null;
		        this.effectReturnR = null;
		        this._writable(['wet']);
		        this.wet = null;
		        return this;
		    };
		    return Tone.StereoEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Tone.FeedbackEffect provides a loop between an 
			 * 	        audio source and its own output. This is a base-class
			 * 	        for feedback effects. 
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {NormalRange|Object} [feedback] The initial feedback value.
			 */
		    Tone.FeedbackEffect = function () {
		        var options = this.optionsObject(arguments, ['feedback']);
		        options = this.defaultArg(options, Tone.FeedbackEffect.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  The amount of signal which is fed back into the effect input. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
		        /**
				 *  the gain which controls the feedback
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedbackGain = this.context.createGain();
		        //the feedback loop
		        this.effectReturn.chain(this._feedbackGain, this.effectSend);
		        this.feedback.connect(this._feedbackGain.gain);
		        this._readOnly(['feedback']);
		    };
		    Tone.extend(Tone.FeedbackEffect, Tone.Effect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.FeedbackEffect.defaults = { 'feedback': 0.125 };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.FeedbackEffect} this
			 */
		    Tone.FeedbackEffect.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._writable(['feedback']);
		        this.feedback.dispose();
		        this.feedback = null;
		        this._feedbackGain.disconnect();
		        this._feedbackGain = null;
		        return this;
		    };
		    return Tone.FeedbackEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Just like a stereo feedback effect, but the feedback is routed from left to right
			 *         and right to left instead of on the same channel.
			 *
			 *	@constructor
			 *	@extends {Tone.FeedbackEffect}
			 */
		    Tone.StereoXFeedbackEffect = function () {
		        var options = this.optionsObject(arguments, ['feedback'], Tone.FeedbackEffect.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  The amount of feedback from the output
				 *  back into the input of the effect (routed
				 *  across left and right channels).
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
		        /**
				 *  the left side feeback
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedbackLR = this.context.createGain();
		        /**
				 *  the right side feeback
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedbackRL = this.context.createGain();
		        //connect it up
		        this.effectReturnL.chain(this._feedbackLR, this.effectSendR);
		        this.effectReturnR.chain(this._feedbackRL, this.effectSendL);
		        this.feedback.fan(this._feedbackLR.gain, this._feedbackRL.gain);
		        this._readOnly(['feedback']);
		    };
		    Tone.extend(Tone.StereoXFeedbackEffect, Tone.FeedbackEffect);
		    /**
			 *  clean up
			 *  @returns {Tone.StereoXFeedbackEffect} this
			 */
		    Tone.StereoXFeedbackEffect.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        this._writable(['feedback']);
		        this.feedback.dispose();
		        this.feedback = null;
		        this._feedbackLR.disconnect();
		        this._feedbackLR = null;
		        this._feedbackRL.disconnect();
		        this._feedbackRL = null;
		        return this;
		    };
		    return Tone.StereoXFeedbackEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Chorus is a stereo chorus effect with feedback composed of 
			 *         a left and right delay with a Tone.LFO applied to the delayTime of each channel. 
			 *         Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).
			 *         Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).
			 *
			 *	@constructor
			 *	@extends {Tone.StereoXFeedbackEffect}
			 *	@param {Frequency|Object} [frequency] The frequency of the LFO.
			 *	@param {Number} [delayTime] The delay of the chorus effect in ms. 
			 *	@param {NormalRange} [depth] The depth of the chorus.
			 *	@example
			 * var chorus = new Tone.Chorus(4, 2.5, 0.5);
			 * var synth = new Tone.PolySynth(4, Tone.MonoSynth).connect(chorus);
			 * synth.triggerAttackRelease(["C3","E3","G3"], "8n");
			 */
		    Tone.Chorus = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'delayTime',
		            'depth'
		        ], Tone.Chorus.defaults);
		        Tone.StereoXFeedbackEffect.call(this, options);
		        /**
				 *  the depth of the chorus
				 *  @type {number}
				 *  @private
				 */
		        this._depth = options.depth;
		        /**
				 *  the delayTime
				 *  @type {number}
				 *  @private
				 */
		        this._delayTime = options.delayTime / 1000;
		        /**
				 *  the lfo which controls the delayTime
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoL = new Tone.LFO(options.rate, 0, 1);
		        /**
				 *  another LFO for the right side with a 180 degree phase diff
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoR = new Tone.LFO(options.rate, 0, 1);
		        this._lfoR.phase = 180;
		        /**
				 *  delay for left
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delayNodeL = this.context.createDelay();
		        /**
				 *  delay for right
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delayNodeR = this.context.createDelay();
		        /**
				 * The frequency of the LFO which modulates the delayTime. 
				 * @type {Frequency}
				 * @signal
				 */
		        this.frequency = this._lfoL.frequency;
		        //connections
		        this.connectSeries(this.effectSendL, this._delayNodeL, this.effectReturnL);
		        this.connectSeries(this.effectSendR, this._delayNodeR, this.effectReturnR);
		        //and pass through to make the detune apparent
		        this.input.connect(this.output);
		        //lfo setup
		        this._lfoL.connect(this._delayNodeL.delayTime);
		        this._lfoR.connect(this._delayNodeR.delayTime);
		        //start the lfo
		        this._lfoL.start();
		        this._lfoR.start();
		        //have one LFO frequency control the other
		        this._lfoL.frequency.connect(this._lfoR.frequency);
		        //set the initial values
		        this.depth = this._depth;
		        this.frequency.value = options.frequency;
		        this.type = options.type;
		        this._readOnly(['frequency']);
		    };
		    Tone.extend(Tone.Chorus, Tone.StereoXFeedbackEffect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Chorus.defaults = {
		        'frequency': 1.5,
		        'delayTime': 3.5,
		        'depth': 0.7,
		        'feedback': 0.1,
		        'type': 'sine'
		    };
		    /**
			 * The depth of the effect. A depth of 1 makes the delayTime
			 * modulate between 0 and 2*delayTime (centered around the delayTime). 
			 * @memberOf Tone.Chorus#
			 * @type {NormalRange}
			 * @name depth
			 */
		    Object.defineProperty(Tone.Chorus.prototype, 'depth', {
		        get: function () {
		            return this._depth;
		        },
		        set: function (depth) {
		            this._depth = depth;
		            var deviation = this._delayTime * depth;
		            this._lfoL.min = Math.max(this._delayTime - deviation, 0);
		            this._lfoL.max = this._delayTime + deviation;
		            this._lfoR.min = Math.max(this._delayTime - deviation, 0);
		            this._lfoR.max = this._delayTime + deviation;
		        }
		    });
		    /**
			 * The delayTime in milliseconds of the chorus. A larger delayTime
			 * will give a more pronounced effect. Nominal range a delayTime
			 * is between 2 and 20ms. 
			 * @memberOf Tone.Chorus#
			 * @type {Number}
			 * @name delayTime
			 */
		    Object.defineProperty(Tone.Chorus.prototype, 'delayTime', {
		        get: function () {
		            return this._delayTime * 1000;
		        },
		        set: function (delayTime) {
		            this._delayTime = delayTime / 1000;
		            this.depth = this._depth;
		        }
		    });
		    /**
			 * The oscillator type of the LFO. 
			 * @memberOf Tone.Chorus#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.Chorus.prototype, 'type', {
		        get: function () {
		            return this._lfoL.type;
		        },
		        set: function (type) {
		            this._lfoL.type = type;
		            this._lfoR.type = type;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Chorus} this
			 */
		    Tone.Chorus.prototype.dispose = function () {
		        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
		        this._lfoL.dispose();
		        this._lfoL = null;
		        this._lfoR.dispose();
		        this._lfoR = null;
		        this._delayNodeL.disconnect();
		        this._delayNodeL = null;
		        this._delayNodeR.disconnect();
		        this._delayNodeR = null;
		        this._writable('frequency');
		        this.frequency = null;
		        return this;
		    };
		    return Tone.Chorus;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Convolver is a wrapper around the Native Web Audio 
			 *          [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).
			 *          Convolution is useful for reverb and filter emulation. Read more about convolution reverb on
			 *          [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).
			 *  
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {string|Tone.Buffer|Object} [url] The URL of the impulse response or the Tone.Buffer
			 *                                           contianing the impulse response. 
			 *  @example
			 * //initializing the convolver with an impulse response
			 * var convolver = new Tone.Convolver("./path/to/ir.wav");
			 * convolver.toMaster();
			 * //after the buffer has loaded
			 * Tone.Buffer.onload = function(){
			 * 	//testing out convolution with a noise burst
			 * 	var burst = new Tone.NoiseSynth().connect(convolver);
			 * 	burst.triggerAttackRelease("16n");
			 * };
			 */
		    Tone.Convolver = function () {
		        var options = this.optionsObject(arguments, ['url'], Tone.Convolver.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  convolver node
				 *  @type {ConvolverNode}
				 *  @private
				 */
		        this._convolver = this.context.createConvolver();
		        /**
				 *  the convolution buffer
				 *  @type {Tone.Buffer}
				 *  @private
				 */
		        this._buffer = new Tone.Buffer(options.url, function (buffer) {
		            this.buffer = buffer;
		            options.onload();
		        }.bind(this));
		        this.connectEffect(this._convolver);
		    };
		    Tone.extend(Tone.Convolver, Tone.Effect);
		    /**
			 *  @static
			 *  @const
			 *  @type  {Object}
			 */
		    Tone.Convolver.defaults = {
		        'url': '',
		        'onload': Tone.noOp
		    };
		    /**
			 *  The convolver's buffer
			 *  @memberOf Tone.Convolver#
			 *  @type {AudioBuffer}
			 *  @name buffer
			 */
		    Object.defineProperty(Tone.Convolver.prototype, 'buffer', {
		        get: function () {
		            return this._buffer.get();
		        },
		        set: function (buffer) {
		            this._buffer.set(buffer);
		            this._convolver.buffer = this._buffer.get();
		        }
		    });
		    /**
			 *  Load an impulse response url as an audio buffer.
			 *  Decodes the audio asynchronously and invokes
			 *  the callback once the audio buffer loads.
			 *  @param {string} url The url of the buffer to load.
			 *                      filetype support depends on the
			 *                      browser.
			 *  @param  {function=} callback
			 *  @returns {Tone.Convolver} this
			 */
		    Tone.Convolver.prototype.load = function (url, callback) {
		        this._buffer.load(url, function (buff) {
		            this.buffer = buff;
		            if (callback) {
		                callback();
		            }
		        }.bind(this));
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Convolver} this
			 */
		    Tone.Convolver.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._convolver.disconnect();
		        this._convolver = null;
		        this._buffer.dispose();
		        this._buffer = null;
		        return this;
		    };
		    return Tone.Convolver;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Distortion is a simple distortion effect using Tone.WaveShaper.
			 *         Algorithm from [a stackoverflow answer](http://stackoverflow.com/a/22313408).
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {Number|Object} [distortion] The amount of distortion (nominal range of 0-1)
			 *  @example
			 * var dist = new Tone.Distortion(0.8).toMaster();
			 * var fm = new Tone.SimpleFM().connect(dist);
			 * //this sounds good on bass notes
			 * fm.triggerAttackRelease("A1", "8n");
			 */
		    Tone.Distortion = function () {
		        var options = this.optionsObject(arguments, ['distortion'], Tone.Distortion.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._shaper = new Tone.WaveShaper(4096);
		        /**
				 * holds the distortion amount
				 * @type {number}
				 * @private
				 */
		        this._distortion = options.distortion;
		        this.connectEffect(this._shaper);
		        this.distortion = options.distortion;
		        this.oversample = options.oversample;
		    };
		    Tone.extend(Tone.Distortion, Tone.Effect);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Distortion.defaults = {
		        'distortion': 0.4,
		        'oversample': 'none'
		    };
		    /**
			 * The amount of distortion. Range between 0-1. 
			 * @memberOf Tone.Distortion#
			 * @type {number}
			 * @name distortion
			 */
		    Object.defineProperty(Tone.Distortion.prototype, 'distortion', {
		        get: function () {
		            return this._distortion;
		        },
		        set: function (amount) {
		            this._distortion = amount;
		            var k = amount * 100;
		            var deg = Math.PI / 180;
		            this._shaper.setMap(function (x) {
		                if (Math.abs(x) < 0.001) {
		                    //should output 0 when input is 0
		                    return 0;
		                } else {
		                    return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
		                }
		            });
		        }
		    });
		    /**
			 * The oversampling of the effect. Can either be "none", "2x" or "4x".
			 * @memberOf Tone.Distortion#
			 * @type {string}
			 * @name oversample
			 */
		    Object.defineProperty(Tone.Distortion.prototype, 'oversample', {
		        get: function () {
		            return this._shaper.oversample;
		        },
		        set: function (oversampling) {
		            this._shaper.oversample = oversampling;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Distortion} this
			 */
		    Tone.Distortion.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._shaper.dispose();
		        this._shaper = null;
		        return this;
		    };
		    return Tone.Distortion;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.FeedbackDelay is a DelayNode in which part of output
			 *          signal is fed back into the delay. 
			 *
			 *  @constructor
			 *  @extends {Tone.FeedbackEffect}
			 *  @param {Time|Object} [delayTime] The delay applied to the incoming signal. 
			 *  @param {NormalRange=} feedback The amount of the effected signal which 
			 *                            is fed back through the delay.
			 *  @example
			 * var feedbackDelay = new Tone.FeedbackDelay("8n", 0.5).toMaster();
			 * var tom = new Tone.DrumSynth({
			 * 	"octaves" : 4,
			 * 	"pitchDecay" : 0.1
			 * }).connect(feedbackDelay);
			 * tom.triggerAttackRelease("A2","32n");
			 */
		    Tone.FeedbackDelay = function () {
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'feedback'
		        ], Tone.FeedbackDelay.defaults);
		        Tone.FeedbackEffect.call(this, options);
		        /**
				 *  The delayTime of the DelayNode. 
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
		        /**
				 *  the delay node
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delayNode = this.context.createDelay(4);
		        // connect it up
		        this.connectEffect(this._delayNode);
		        this.delayTime.connect(this._delayNode.delayTime);
		        this._readOnly(['delayTime']);
		    };
		    Tone.extend(Tone.FeedbackDelay, Tone.FeedbackEffect);
		    /**
			 *  The default values. 
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.FeedbackDelay.defaults = { 'delayTime': 0.25 };
		    /**
			 *  clean up
			 *  @returns {Tone.FeedbackDelay} this
			 */
		    Tone.FeedbackDelay.prototype.dispose = function () {
		        Tone.FeedbackEffect.prototype.dispose.call(this);
		        this.delayTime.dispose();
		        this._delayNode.disconnect();
		        this._delayNode = null;
		        this._writable(['delayTime']);
		        this.delayTime = null;
		        return this;
		    };
		    return Tone.FeedbackDelay;
		});
		Module(function (Tone) {
		    
		    /**
			 *  an array of comb filter delay values from Freeverb implementation
			 *  @static
			 *  @private
			 *  @type {Array}
			 */
		    var combFilterTunings = [
		        1557 / 44100,
		        1617 / 44100,
		        1491 / 44100,
		        1422 / 44100,
		        1277 / 44100,
		        1356 / 44100,
		        1188 / 44100,
		        1116 / 44100
		    ];
		    /**
			 *  an array of allpass filter frequency values from Freeverb implementation
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var allpassFilterFrequencies = [
		        225,
		        556,
		        441,
		        341
		    ];
		    /**
			 *  @class Tone.Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).
			 *         Read more on reverb on [SoundOnSound](http://www.soundonsound.com/sos/may00/articles/reverb.htm).
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {NormalRange|Object} [roomSize] Correlated to the decay time. 
			 *  @param {Frequency} [dampening] The cutoff frequency of a lowpass filter as part 
			 *                                 of the reverb. 
			 *  @example
			 * var freeverb = new Tone.Freeverb().toMaster();
			 * freeverb.dampening.value = 1000;
			 * //routing synth through the reverb
			 * var synth = new Tone.AMSynth().connect(freeverb);
			 */
		    Tone.Freeverb = function () {
		        var options = this.optionsObject(arguments, [
		            'roomSize',
		            'dampening'
		        ], Tone.Freeverb.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  The roomSize value between. A larger roomSize
				 *  will result in a longer decay. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
		        /**
				 *  The amount of dampening of the reverberant signal. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.dampening = new Tone.Signal(options.dampening, Tone.Type.Frequency);
		        /**
				 *  the comb filters
				 *  @type {Array}
				 *  @private
				 */
		        this._combFilters = [];
		        /**
				 *  the allpass filters on the left
				 *  @type {Array}
				 *  @private
				 */
		        this._allpassFiltersL = [];
		        /**
				 *  the allpass filters on the right
				 *  @type {Array}
				 *  @private
				 */
		        this._allpassFiltersR = [];
		        //make the allpass filters on teh right
		        for (var l = 0; l < allpassFilterFrequencies.length; l++) {
		            var allpassL = this.context.createBiquadFilter();
		            allpassL.type = 'allpass';
		            allpassL.frequency.value = allpassFilterFrequencies[l];
		            this._allpassFiltersL.push(allpassL);
		        }
		        //make the allpass filters on the left
		        for (var r = 0; r < allpassFilterFrequencies.length; r++) {
		            var allpassR = this.context.createBiquadFilter();
		            allpassR.type = 'allpass';
		            allpassR.frequency.value = allpassFilterFrequencies[r];
		            this._allpassFiltersR.push(allpassR);
		        }
		        //make the comb filters
		        for (var c = 0; c < combFilterTunings.length; c++) {
		            var lfpf = new Tone.LowpassCombFilter(combFilterTunings[c]);
		            if (c < combFilterTunings.length / 2) {
		                this.effectSendL.chain(lfpf, this._allpassFiltersL[0]);
		            } else {
		                this.effectSendR.chain(lfpf, this._allpassFiltersR[0]);
		            }
		            this.roomSize.connect(lfpf.resonance);
		            this.dampening.connect(lfpf.dampening);
		            this._combFilters.push(lfpf);
		        }
		        //chain the allpass filters togetehr
		        this.connectSeries.apply(this, this._allpassFiltersL);
		        this.connectSeries.apply(this, this._allpassFiltersR);
		        this._allpassFiltersL[this._allpassFiltersL.length - 1].connect(this.effectReturnL);
		        this._allpassFiltersR[this._allpassFiltersR.length - 1].connect(this.effectReturnR);
		        this._readOnly([
		            'roomSize',
		            'dampening'
		        ]);
		    };
		    Tone.extend(Tone.Freeverb, Tone.StereoEffect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Freeverb.defaults = {
		        'roomSize': 0.7,
		        'dampening': 3000
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Freeverb} this
			 */
		    Tone.Freeverb.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        for (var al = 0; al < this._allpassFiltersL.length; al++) {
		            this._allpassFiltersL[al].disconnect();
		            this._allpassFiltersL[al] = null;
		        }
		        this._allpassFiltersL = null;
		        for (var ar = 0; ar < this._allpassFiltersR.length; ar++) {
		            this._allpassFiltersR[ar].disconnect();
		            this._allpassFiltersR[ar] = null;
		        }
		        this._allpassFiltersR = null;
		        for (var cf = 0; cf < this._combFilters.length; cf++) {
		            this._combFilters[cf].dispose();
		            this._combFilters[cf] = null;
		        }
		        this._combFilters = null;
		        this._writable([
		            'roomSize',
		            'dampening'
		        ]);
		        this.roomSize.dispose();
		        this.roomSize = null;
		        this.dampening.dispose();
		        this.dampening = null;
		        return this;
		    };
		    return Tone.Freeverb;
		});
		Module(function (Tone) {
		    
		    /**
			 *  an array of the comb filter delay time values
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var combFilterDelayTimes = [
		        1687 / 25000,
		        1601 / 25000,
		        2053 / 25000,
		        2251 / 25000
		    ];
		    /**
			 *  the resonances of each of the comb filters
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var combFilterResonances = [
		        0.773,
		        0.802,
		        0.753,
		        0.733
		    ];
		    /**
			 *  the allpass filter frequencies
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var allpassFilterFreqs = [
		        347,
		        113,
		        37
		    ];
		    /**
			 *  @class Tone.JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)
			 *         tuned by John Chowning in 1970.
			 *         It is made up of three allpass filters and four Tone.FeedbackCombFilter. 
			 *         
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {NormalRange|Object} [roomSize] Coorelates to the decay time.
			 *  @example
			 * var reverb = new Tone.JCReverb(0.4).connect(Tone.Master);
			 * var delay = new Tone.FeedbackDelay(0.5); 
			 * //connecting the synth to reverb through delay
			 * var synth = new Tone.DuoSynth().chain(delay, reverb);
			 * synth.triggerAttackRelease("A4","8n");
			 */
		    Tone.JCReverb = function () {
		        var options = this.optionsObject(arguments, ['roomSize'], Tone.JCReverb.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  room size control values between [0,1]
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
		        /**
				 *  scale the room size
				 *  @type {Tone.Scale}
				 *  @private
				 */
		        this._scaleRoomSize = new Tone.Scale(-0.733, 0.197);
		        /**
				 *  a series of allpass filters
				 *  @type {Array}
				 *  @private
				 */
		        this._allpassFilters = [];
		        /**
				 *  parallel feedback comb filters
				 *  @type {Array}
				 *  @private
				 */
		        this._feedbackCombFilters = [];
		        //make the allpass filters
		        for (var af = 0; af < allpassFilterFreqs.length; af++) {
		            var allpass = this.context.createBiquadFilter();
		            allpass.type = 'allpass';
		            allpass.frequency.value = allpassFilterFreqs[af];
		            this._allpassFilters.push(allpass);
		        }
		        //and the comb filters
		        for (var cf = 0; cf < combFilterDelayTimes.length; cf++) {
		            var fbcf = new Tone.FeedbackCombFilter(combFilterDelayTimes[cf], 0.1);
		            this._scaleRoomSize.connect(fbcf.resonance);
		            fbcf.resonance.value = combFilterResonances[cf];
		            this._allpassFilters[this._allpassFilters.length - 1].connect(fbcf);
		            if (cf < combFilterDelayTimes.length / 2) {
		                fbcf.connect(this.effectReturnL);
		            } else {
		                fbcf.connect(this.effectReturnR);
		            }
		            this._feedbackCombFilters.push(fbcf);
		        }
		        //chain the allpass filters together
		        this.roomSize.connect(this._scaleRoomSize);
		        this.connectSeries.apply(this, this._allpassFilters);
		        this.effectSendL.connect(this._allpassFilters[0]);
		        this.effectSendR.connect(this._allpassFilters[0]);
		        this._readOnly(['roomSize']);
		    };
		    Tone.extend(Tone.JCReverb, Tone.StereoEffect);
		    /**
			 *  the default values
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.JCReverb.defaults = { 'roomSize': 0.5 };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.JCReverb} this
			 */
		    Tone.JCReverb.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        for (var apf = 0; apf < this._allpassFilters.length; apf++) {
		            this._allpassFilters[apf].disconnect();
		            this._allpassFilters[apf] = null;
		        }
		        this._allpassFilters = null;
		        for (var fbcf = 0; fbcf < this._feedbackCombFilters.length; fbcf++) {
		            this._feedbackCombFilters[fbcf].dispose();
		            this._feedbackCombFilters[fbcf] = null;
		        }
		        this._feedbackCombFilters = null;
		        this._writable(['roomSize']);
		        this.roomSize.dispose();
		        this.roomSize = null;
		        this._scaleRoomSize.dispose();
		        this._scaleRoomSize = null;
		        return this;
		    };
		    return Tone.JCReverb;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Mid/Side processing separates the the 'mid' signal 
			 *         (which comes out of both the left and the right channel) 
			 *         and the 'side' (which only comes out of the the side channels) 
			 *         and effects them separately before being recombined.
			 *         Applies a Mid/Side seperation and recombination.
			 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
			 *         <br><br>
			 *         This is a base-class for Mid/Side Effects. 
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 */
		    Tone.MidSideEffect = function () {
		        Tone.Effect.call(this);
		        /**
				 *  The mid/side split
				 *  @type  {Tone.MidSideSplit}
				 *  @private
				 */
		        this._midSideSplit = new Tone.MidSideSplit();
		        /**
				 *  The mid/side merge
				 *  @type  {Tone.MidSideMerge}
				 *  @private
				 */
		        this._midSideMerge = new Tone.MidSideMerge();
		        /**
				 *  The mid send. Connect to mid processing
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this.midSend = this._midSideSplit.mid;
		        /**
				 *  The side send. Connect to side processing
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this.sideSend = this._midSideSplit.side;
		        /**
				 *  The mid return connection
				 *  @type {GainNode}
				 *  @private
				 */
		        this.midReturn = this._midSideMerge.mid;
		        /**
				 *  The side return connection
				 *  @type {GainNode}
				 *  @private
				 */
		        this.sideReturn = this._midSideMerge.side;
		        //the connections
		        this.effectSend.connect(this._midSideSplit);
		        this._midSideMerge.connect(this.effectReturn);
		    };
		    Tone.extend(Tone.MidSideEffect, Tone.Effect);
		    /**
			 *  Clean up. 
			 *  @returns {Tone.MidSideEffect} this
			 */
		    Tone.MidSideEffect.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._midSideSplit.dispose();
		        this._midSideSplit = null;
		        this._midSideMerge.dispose();
		        this._midSideMerge = null;
		        this.midSend = null;
		        this.sideSend = null;
		        this.midReturn = null;
		        this.sideReturn = null;
		        return this;
		    };
		    return Tone.MidSideEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Phaser is a phaser effect. Phasers work by changing the phase
			 *         of different frequency components of an incoming signal. Read more on 
			 *         [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)). 
			 *         Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).
			 *
			 *	@extends {Tone.StereoEffect}
			 *	@constructor
			 *	@param {Frequency|Object} [frequency] The speed of the phasing. 
			 *	@param {number} [depth] The depth of the effect. 
			 *	@param {Frequency} [baseFrequency] The base frequency of the filters. 
			 *	@example
			 * var phaser = new Tone.Phaser({
			 * 	"frequency" : 15, 
			 * 	"depth" : 5, 
			 * 	"baseFrequency" : 1000
			 * }).toMaster();
			 * var synth = new Tone.FMSynth().connect(phaser);
			 * synth.triggerAttackRelease("E3", "2n");
			 */
		    Tone.Phaser = function () {
		        //set the defaults
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'depth',
		            'baseFrequency'
		        ], Tone.Phaser.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  the lfo which controls the frequency on the left side
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoL = new Tone.LFO(options.frequency, 0, 1);
		        /**
				 *  the lfo which controls the frequency on the right side
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoR = new Tone.LFO(options.frequency, 0, 1);
		        this._lfoR.phase = 180;
		        /**
				 *  the base modulation frequency
				 *  @type {number}
				 *  @private
				 */
		        this._baseFrequency = options.baseFrequency;
		        /**
				 *  the depth of the phasing
				 *  @type {number}
				 *  @private
				 */
		        this._depth = options.depth;
		        /**
				 *  The quality factor of the filters
				 *  @type {Positive}
				 *  @signal
				 */
		        this.Q = new Tone.Signal(options.Q, Tone.Type.Positive);
		        /**
				 *  the array of filters for the left side
				 *  @type {Array}
				 *  @private
				 */
		        this._filtersL = this._makeFilters(options.stages, this._lfoL, this.Q);
		        /**
				 *  the array of filters for the left side
				 *  @type {Array}
				 *  @private
				 */
		        this._filtersR = this._makeFilters(options.stages, this._lfoR, this.Q);
		        /**
				 * the frequency of the effect
				 * @type {Tone.Signal}
				 */
		        this.frequency = this._lfoL.frequency;
		        this.frequency.value = options.frequency;
		        //connect them up
		        this.effectSendL.connect(this._filtersL[0]);
		        this.effectSendR.connect(this._filtersR[0]);
		        this._filtersL[options.stages - 1].connect(this.effectReturnL);
		        this._filtersR[options.stages - 1].connect(this.effectReturnR);
		        //control the frequency with one LFO
		        this._lfoL.frequency.connect(this._lfoR.frequency);
		        //set the options
		        this.baseFrequency = options.baseFrequency;
		        this.depth = options.depth;
		        //start the lfo
		        this._lfoL.start();
		        this._lfoR.start();
		        this._readOnly([
		            'frequency',
		            'Q'
		        ]);
		    };
		    Tone.extend(Tone.Phaser, Tone.StereoEffect);
		    /**
			 *  defaults
			 *  @static
			 *  @type {object}
			 */
		    Tone.Phaser.defaults = {
		        'frequency': 0.5,
		        'depth': 10,
		        'stages': 10,
		        'Q': 10,
		        'baseFrequency': 350
		    };
		    /**
			 *  @param {number} stages
			 *  @returns {Array} the number of filters all connected together
			 *  @private
			 */
		    Tone.Phaser.prototype._makeFilters = function (stages, connectToFreq, Q) {
		        var filters = new Array(stages);
		        //make all the filters
		        for (var i = 0; i < stages; i++) {
		            var filter = this.context.createBiquadFilter();
		            filter.type = 'allpass';
		            Q.connect(filter.Q);
		            connectToFreq.connect(filter.frequency);
		            filters[i] = filter;
		        }
		        this.connectSeries.apply(this, filters);
		        return filters;
		    };
		    /**
			 * The depth of the effect. 
			 * @memberOf Tone.Phaser#
			 * @type {number}
			 * @name depth
			 */
		    Object.defineProperty(Tone.Phaser.prototype, 'depth', {
		        get: function () {
		            return this._depth;
		        },
		        set: function (depth) {
		            this._depth = depth;
		            var max = this._baseFrequency + this._baseFrequency * depth;
		            this._lfoL.max = max;
		            this._lfoR.max = max;
		        }
		    });
		    /**
			 * The the base frequency of the filters. 
			 * @memberOf Tone.Phaser#
			 * @type {number}
			 * @name baseFrequency
			 */
		    Object.defineProperty(Tone.Phaser.prototype, 'baseFrequency', {
		        get: function () {
		            return this._baseFrequency;
		        },
		        set: function (freq) {
		            this._baseFrequency = freq;
		            this._lfoL.min = freq;
		            this._lfoR.min = freq;
		            this.depth = this._depth;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.Phaser} this
			 */
		    Tone.Phaser.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'Q'
		        ]);
		        this.Q.dispose();
		        this.Q = null;
		        this._lfoL.dispose();
		        this._lfoL = null;
		        this._lfoR.dispose();
		        this._lfoR = null;
		        for (var i = 0; i < this._filtersL.length; i++) {
		            this._filtersL[i].disconnect();
		            this._filtersL[i] = null;
		        }
		        this._filtersL = null;
		        for (var j = 0; j < this._filtersR.length; j++) {
		            this._filtersR[j].disconnect();
		            this._filtersR[j] = null;
		        }
		        this._filtersR = null;
		        this.frequency = null;
		        return this;
		    };
		    return Tone.Phaser;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.PingPongDelay is a feedback delay effect where the echo is heard
			 *          first in one channel and next in the opposite channel. In a stereo
			 *          system these are the right and left channels.
			 *          PingPongDelay in more simplified terms is two Tone.FeedbackDelays 
			 *          with independent delay values. Each delay is routed to one channel
			 *          (left or right), and the channel triggered second will always 
			 *          trigger at the same interval after the first.
			 *
			 * 	@constructor
			 * 	@extends {Tone.StereoXFeedbackEffect}
			 *  @param {Time|Object} [delayTime] The delayTime between consecutive echos.
			 *  @param {NormalRange=} feedback The amount of the effected signal which 
			 *                                 is fed back through the delay.
			 *  @example
			 * var pingPong = new Tone.PingPongDelay("4n", 0.2).toMaster();
			 * var drum = new Tone.DrumSynth().connect(pingPong);
			 * drum.triggerAttackRelease("C4", "32n");
			 */
		    Tone.PingPongDelay = function () {
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'feedback'
		        ], Tone.PingPongDelay.defaults);
		        Tone.StereoXFeedbackEffect.call(this, options);
		        /**
				 *  the delay node on the left side
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._leftDelay = this.context.createDelay(options.maxDelayTime);
		        /**
				 *  the delay node on the right side
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._rightDelay = this.context.createDelay(options.maxDelayTime);
		        /**
				 *  the predelay on the right side
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._rightPreDelay = this.context.createDelay(options.maxDelayTime);
		        /**
				 *  the delay time signal
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
		        //connect it up
		        this.effectSendL.chain(this._leftDelay, this.effectReturnL);
		        this.effectSendR.chain(this._rightPreDelay, this._rightDelay, this.effectReturnR);
		        this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);
		        //rearranged the feedback to be after the rightPreDelay
		        this._feedbackLR.disconnect();
		        this._feedbackLR.connect(this._rightDelay);
		        this._readOnly(['delayTime']);
		    };
		    Tone.extend(Tone.PingPongDelay, Tone.StereoXFeedbackEffect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.PingPongDelay.defaults = {
		        'delayTime': 0.25,
		        'maxDelayTime': 1
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.PingPongDelay} this
			 */
		    Tone.PingPongDelay.prototype.dispose = function () {
		        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
		        this._leftDelay.disconnect();
		        this._leftDelay = null;
		        this._rightDelay.disconnect();
		        this._rightDelay = null;
		        this._rightPreDelay.disconnect();
		        this._rightPreDelay = null;
		        this._writable(['delayTime']);
		        this.delayTime.dispose();
		        this.delayTime = null;
		        return this;
		    };
		    return Tone.PingPongDelay;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Base class for stereo feedback effects where the effectReturn
			 *         is fed back into the same channel. 
			 *
			 *	@constructor
			 *	@extends {Tone.FeedbackEffect}
			 */
		    Tone.StereoFeedbackEffect = function () {
		        var options = this.optionsObject(arguments, ['feedback'], Tone.FeedbackEffect.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  controls the amount of feedback
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
		        /**
				 *  the left side feeback
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedbackL = this.context.createGain();
		        /**
				 *  the right side feeback
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedbackR = this.context.createGain();
		        //connect it up
		        this.effectReturnL.chain(this._feedbackL, this.effectSendL);
		        this.effectReturnR.chain(this._feedbackR, this.effectSendR);
		        this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);
		        this._readOnly(['feedback']);
		    };
		    Tone.extend(Tone.StereoFeedbackEffect, Tone.FeedbackEffect);
		    /**
			 *  clean up
			 *  @returns {Tone.StereoFeedbackEffect} this
			 */
		    Tone.StereoFeedbackEffect.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        this._writable(['feedback']);
		        this.feedback.dispose();
		        this.feedback = null;
		        this._feedbackL.disconnect();
		        this._feedbackL = null;
		        this._feedbackR.disconnect();
		        this._feedbackR = null;
		        return this;
		    };
		    return Tone.StereoFeedbackEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Applies a width factor to the mid/side seperation. 
			 *         0 is all mid and 1 is all side.
			 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
			 *         <br><br>
			 *         <code>
			 *         Mid *= 2*(1-width)<br>
			 *         Side *= 2*width
			 *         </code>
			 *
			 *  @extends {Tone.MidSideEffect}
			 *  @constructor
			 *  @param {NormalRange|Object} [width] The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.
			 */
		    Tone.StereoWidener = function () {
		        var options = this.optionsObject(arguments, ['width'], Tone.StereoWidener.defaults);
		        Tone.MidSideEffect.call(this, options);
		        /**
				 *  The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.width = new Tone.Signal(0.5, Tone.Type.NormalRange);
		        /**
				 *  Mid multiplier
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._midMult = new Tone.Expr('$0 * ($1 * (1 - $2))');
		        /**
				 *  Side multiplier
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._sideMult = new Tone.Expr('$0 * ($1 * $2)');
		        /**
				 *  constant output of 2
				 *  @type {Tone}
				 *  @private
				 */
		        this._two = new Tone.Signal(2);
		        //the mid chain
		        this._two.connect(this._midMult, 0, 1);
		        this.width.connect(this._midMult, 0, 2);
		        //the side chain
		        this._two.connect(this._sideMult, 0, 1);
		        this.width.connect(this._sideMult, 0, 2);
		        //connect it to the effect send/return
		        this.midSend.chain(this._midMult, this.midReturn);
		        this.sideSend.chain(this._sideMult, this.sideReturn);
		        this._readOnly(['width']);
		    };
		    Tone.extend(Tone.StereoWidener, Tone.MidSideEffect);
		    /**
			 *  the default values
			 *  @static
			 *  @type {Object}
			 */
		    Tone.StereoWidener.defaults = { 'width': 0.5 };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.StereoWidener} this
			 */
		    Tone.StereoWidener.prototype.dispose = function () {
		        Tone.MidSideEffect.prototype.dispose.call(this);
		        this._writable(['width']);
		        this.width.dispose();
		        this.width = null;
		        this._midMult.dispose();
		        this._midMult = null;
		        this._sideMult.dispose();
		        this._sideMult = null;
		        this._two.dispose();
		        this._two = null;
		        return this;
		    };
		    return Tone.StereoWidener;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Tremelo modulates the amplitude of an incoming signal using a Tone.LFO. 
			 *         The type, frequency, and depth of the LFO is controllable. 
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {Frequency|Object} [frequency] The rate of the effect. 
			 *  @param {NormalRange} [depth] The depth of the wavering.
			 *  @example
			 * //create an tremolo and start it's LFO
			 * var tremolo = new Tone.Tremolo(9, 0.75).toMaster().start();
			 * //route an oscillator through the tremolo and start it
			 * var oscillator = new Tone.Oscillator().connect(tremolo).start();
			 */
		    Tone.Tremolo = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'depth'
		        ], Tone.Tremolo.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  The tremelo LFO
				 *  @type  {Tone.LFO}
				 *  @private
				 */
		        this._lfo = new Tone.LFO({
		            'frequency': options.frequency,
		            'amplitude': options.depth,
		            'min': 1,
		            'max': 0
		        });
		        /**
				 *  Where the gain is multiplied
				 *  @type  {GainNode}
				 *  @private
				 */
		        this._amplitude = this.context.createGain();
		        /**
				 *  The frequency of the tremolo.	
				 *  @type  {Frequency}
				 *  @signal
				 */
		        this.frequency = this._lfo.frequency;
		        /**
				 *  The depth of the effect. A depth of 0, has no effect
				 *  on the amplitude, and a depth of 1 makes the amplitude
				 *  modulate fully between 0 and 1. 
				 *  @type  {NormalRange}
				 *  @signal
				 */
		        this.depth = this._lfo.amplitude;
		        this._readOnly([
		            'frequency',
		            'depth'
		        ]);
		        this.connectEffect(this._amplitude);
		        this._lfo.connect(this._amplitude.gain);
		        this.type = options.type;
		    };
		    Tone.extend(Tone.Tremolo, Tone.Effect);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Tremolo.defaults = {
		        'frequency': 10,
		        'type': 'sine',
		        'depth': 0.5
		    };
		    /**
			 * Start the tremolo.
			 * @param {Time} [time=now] When the tremolo begins.
			 * @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.start = function (time) {
		        this._lfo.start(time);
		        return this;
		    };
		    /**
			 * Stop the tremolo.
			 * @param {Time} [time=now] When the tremolo stops.
			 * @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.stop = function (time) {
		        this._lfo.stop(time);
		        return this;
		    };
		    /**
			 * Sync the effect to the transport.
			 * @param {Time} [delay=0] Delay time before starting the effect after the
			 *                              Transport has started. 
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.Tremolo.prototype.sync = function (delay) {
		        this._lfo.sync(delay);
		        return this;
		    };
		    /**
			 * Unsync the filter from the transport
			 * @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.unsync = function () {
		        this._lfo.unsync();
		        return this;
		    };
		    /**
			 * Type of oscillator attached to the Tremolo.
			 * @memberOf Tone.Tremolo#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.Tremolo.prototype, 'type', {
		        get: function () {
		            return this._lfo.type;
		        },
		        set: function (type) {
		            this._lfo.type = type;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'depth'
		        ]);
		        this._lfo.dispose();
		        this._lfo = null;
		        this._amplitude.disconnect();
		        this._amplitude = null;
		        this.frequency = null;
		        this.depth = null;
		        return this;
		    };
		    return Tone.Tremolo;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Clip the incoming signal so that the output is always between min and max.
			 * 	
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} min the minimum value of the outgoing signal
			 *  @param {number} max the maximum value of the outgoing signal
			 *  @example
			 * var clip = new Tone.Clip(0.5, 1);
			 * var osc = new Tone.Oscillator().connect(clip);
			 * //clips the output of the oscillator to between 0.5 and 1.
			 */
		    Tone.Clip = function (min, max) {
		        //make sure the args are in the right order
		        if (min > max) {
		            var tmp = min;
		            min = max;
		            max = tmp;
		        }
		        /**
				 *  The min clip value
				 *  @type {Number}
				 *  @signal
				 */
		        this.min = this.input = new Tone.Min(max);
		        this._readOnly('min');
		        /**
				 *  The max clip value
				 *  @type {Number}
				 *  @signal
				 */
		        this.max = this.output = new Tone.Max(min);
		        this._readOnly('max');
		        this.min.connect(this.max);
		    };
		    Tone.extend(Tone.Clip, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.Clip} this
			 */
		    Tone.Clip.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('min');
		        this.min.dispose();
		        this.min = null;
		        this._writable('max');
		        this.max.dispose();
		        this.max = null;
		        return this;
		    };
		    return Tone.Clip;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Normalize takes an input min and max and maps it linearly to NormalRange [0,1]
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {number} inputMin the min input value
			 *  @param {number} inputMax the max input value
			 *  @example
			 * var norm = new Tone.Normalize(2, 4);
			 * var sig = new Tone.Signal(3).connect(norm);
			 * //output of norm is 0.5. 
			 */
		    Tone.Normalize = function (inputMin, inputMax) {
		        /**
				 *  the min input value
				 *  @type {number}
				 *  @private
				 */
		        this._inputMin = this.defaultArg(inputMin, 0);
		        /**
				 *  the max input value
				 *  @type {number}
				 *  @private
				 */
		        this._inputMax = this.defaultArg(inputMax, 1);
		        /**
				 *  subtract the min from the input
				 *  @type {Tone.Add}
				 *  @private
				 */
		        this._sub = this.input = new Tone.Add(0);
		        /**
				 *  divide by the difference between the input and output
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._div = this.output = new Tone.Multiply(1);
		        this._sub.connect(this._div);
		        this._setRange();
		    };
		    Tone.extend(Tone.Normalize, Tone.SignalBase);
		    /**
			 * The minimum value the input signal will reach.
			 * @memberOf Tone.Normalize#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.Normalize.prototype, 'min', {
		        get: function () {
		            return this._inputMin;
		        },
		        set: function (min) {
		            this._inputMin = min;
		            this._setRange();
		        }
		    });
		    /**
			 * The maximum value the input signal will reach.
			 * @memberOf Tone.Normalize#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.Normalize.prototype, 'max', {
		        get: function () {
		            return this._inputMax;
		        },
		        set: function (max) {
		            this._inputMax = max;
		            this._setRange();
		        }
		    });
		    /**
			 *  set the values
			 *  @private
			 */
		    Tone.Normalize.prototype._setRange = function () {
		        this._sub.value = -this._inputMin;
		        this._div.value = 1 / (this._inputMax - this._inputMin);
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Normalize} this
			 */
		    Tone.Normalize.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._sub.dispose();
		        this._sub = null;
		        this._div.dispose();
		        this._div = null;
		        return this;
		    };
		    return Tone.Normalize;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Route a single input to the specified output. 
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} [outputCount=2] the number of inputs the switch accepts
			 *  @example
			 * var route = new Tone.Route(4);
			 * var signal = new Tone.Signal(3).connect(route);
			 * route.select(0);
			 * //signal is routed through output 0
			 * route.select(3);
			 * //signal is now routed through output 3
			 */
		    Tone.Route = function (outputCount) {
		        outputCount = this.defaultArg(outputCount, 2);
		        Tone.call(this, 1, outputCount);
		        /**
				 *  The control signal.
				 *  @type {Number}
				 *  @signal
				 */
		        this.gate = new Tone.Signal(0);
		        this._readOnly('gate');
		        //make all the inputs and connect them
		        for (var i = 0; i < outputCount; i++) {
		            var routeGate = new RouteGate(i);
		            this.output[i] = routeGate;
		            this.gate.connect(routeGate.selecter);
		            this.input.connect(routeGate);
		        }
		    };
		    Tone.extend(Tone.Route, Tone.SignalBase);
		    /**
			 *  Routes the signal to one of the outputs and close the others.
			 *  @param {number} [which=0] Open one of the gates (closes the other).
			 *  @param {Time} [time=now] The time when the switch will open.
			 *  @returns {Tone.Route} this
			 */
		    Tone.Route.prototype.select = function (which, time) {
		        //make sure it's an integer
		        which = Math.floor(which);
		        this.gate.setValueAtTime(which, this.toSeconds(time));
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Route} this
			 */
		    Tone.Route.prototype.dispose = function () {
		        this._writable('gate');
		        this.gate.dispose();
		        this.gate = null;
		        for (var i = 0; i < this.output.length; i++) {
		            this.output[i].dispose();
		            this.output[i] = null;
		        }
		        Tone.prototype.dispose.call(this);
		        return this;
		    };
		    ////////////START HELPER////////////
		    /**
			 *  helper class for Tone.Route representing a single gate
			 *  @constructor
			 *  @extends {Tone}
			 *  @private
			 */
		    var RouteGate = function (num) {
		        /**
				 *  the selector
				 *  @type {Tone.Equal}
				 */
		        this.selecter = new Tone.Equal(num);
		        /**
				 *  the gate
				 *  @type {GainNode}
				 */
		        this.gate = this.input = this.output = this.context.createGain();
		        //connect the selecter to the gate gain
		        this.selecter.connect(this.gate.gain);
		    };
		    Tone.extend(RouteGate);
		    /**
			 *  clean up
			 *  @private
			 */
		    RouteGate.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.selecter.dispose();
		        this.selecter = null;
		        this.gate.disconnect();
		        this.gate = null;
		    };
		    ////////////END HELPER////////////
		    //return Tone.Route
		    return Tone.Route;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  When the gate is set to 0, the input signal does not pass through to the output. 
			 *          If the gate is set to 1, the input signal passes through.
			 *          the gate is initially closed.
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {Boolean} [open=false] If the gate is initially open or closed.
			 *  @example
			 * var sigSwitch = new Tone.Switch();
			 * var signal = new Tone.Signal(2).connect(sigSwitch);
			 * //initially no output from sigSwitch
			 * sigSwitch.gate.value = 1;
			 * //open the switch and allow the signal through
			 * //the output of sigSwitch is now 2. 
			 */
		    Tone.Switch = function (open) {
		        open = this.defaultArg(open, false);
		        Tone.call(this);
		        /**
				 *  The control signal for the switch.
				 *  When this value is 0, the input signal will NOT pass through,
				 *  when it is high (1), the input signal will pass through.
				 *  
				 *  @type {Number}
				 *  @signal
				 */
		        this.gate = new Tone.Signal(0);
		        this._readOnly('gate');
		        /**
				 *  thresh the control signal to either 0 or 1
				 *  @type {Tone.GreaterThan}
				 *  @private
				 */
		        this._thresh = new Tone.GreaterThan(0.5);
		        this.input.connect(this.output);
		        this.gate.chain(this._thresh, this.output.gain);
		        //initially open
		        if (open) {
		            this.open();
		        }
		    };
		    Tone.extend(Tone.Switch, Tone.SignalBase);
		    /**
			 *  Open the switch at a specific time. 
			 *
			 *  @param {Time} [time=now] The time when the switch will be open. 
			 *  @returns {Tone.Switch} this
			 *  @example
			 *  //open the switch to let the signal through
			 *  sigSwitch.open();
			 */
		    Tone.Switch.prototype.open = function (time) {
		        this.gate.setValueAtTime(1, this.toSeconds(time));
		        return this;
		    };
		    /**
			 *  Close the switch at a specific time. 
			 *
			 *  @param {Time} [time=now] The time when the switch will be closed.
			 *  @returns {Tone.Switch} this
			 *  @example
			 *  //close the switch a half second from now
			 *  sigSwitch.close("+0.5");
			 */
		    Tone.Switch.prototype.close = function (time) {
		        this.gate.setValueAtTime(0, this.toSeconds(time));
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Switch} this
			 */
		    Tone.Switch.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('gate');
		        this.gate.dispose();
		        this.gate = null;
		        this._thresh.dispose();
		        this._thresh = null;
		        return this;
		    };
		    return Tone.Switch;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Microphone is a WebRTC Microphone. Check 
			 *          [Media Stream API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_API)
			 *          to see which browsers are supported. 
			 *
			 *  @constructor
			 *  @extends {Tone.Source}
			 *  @param {number} [inputNum=0] If multiple inputs are present, select the input number.
			 *  @example
			 * //mic will feedback if played through master
			 * var mic = new Tone.Microphone();
			 * mic.start();
			 */
		    Tone.Microphone = function (inputNum) {
		        Tone.Source.call(this);
		        /**
				 *  @type {MediaStreamAudioSourceNode}
				 *  @private
				 */
		        this._mediaStream = null;
		        /**
				 *  @type {LocalMediaStream}
				 *  @private
				 */
		        this._stream = null;
		        /**
				 *  @type {Object}
				 *  @private
				 */
		        this._constraints = { 'audio': true };
		        //get the option
		        var self = this;
		        MediaStreamTrack.getSources(function (media_sources) {
		            if (inputNum < media_sources.length) {
		                self.constraints.audio = { optional: [{ sourceId: media_sources[inputNum].id }] };
		            }
		        });
		    };
		    Tone.extend(Tone.Microphone, Tone.Source);
		    /**
			 *  start the stream. 
			 *  @private
			 */
		    Tone.Microphone.prototype._start = function () {
		        navigator.getUserMedia(this._constraints, this._onStream.bind(this), this._onStreamError.bind(this));
		    };
		    /**
			 *  stop the stream. 
			 *  @private
			 */
		    Tone.Microphone.prototype._stop = function () {
		        this._stream.stop();
		        return this;
		    };
		    /**
			 *  called when the stream is successfully setup
			 *  @param   {LocalMediaStream} stream 
			 *  @private
			 */
		    Tone.Microphone.prototype._onStream = function (stream) {
		        this._stream = stream;
		        // Wrap a MediaStreamSourceNode around the live input stream.
		        this._mediaStream = this.context.createMediaStreamSource(stream);
		        this._mediaStream.connect(this.output);
		    };
		    /**
			 *  called on error
			 *  @param   {Error} e 
			 *  @private
			 */
		    Tone.Microphone.prototype._onStreamError = function (e) {
		        console.error(e);
		    };
		    /**
			 *  Clean up.
			 *  @return {Tone.Microphone} this
			 */
		    Tone.Microphone.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        if (this._mediaStream) {
		            this._mediaStream.disconnect();
		            this._mediaStream = null;
		        }
		        this._stream = null;
		        this._constraints = null;
		        return this;
		    };
		    //polyfill
		    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
		    return Tone.Microphone;
		});

		//UMD
		if ( true ) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return Tone;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof module === "object") {
			module.exports = Tone;
	 	} else {
			root.Tone = Tone;
		}
	} (this));

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var Tone = __webpack_require__(3);
	var rainFX = __webpack_require__(5);
	var humidityFX = __webpack_require__(6);
	var visibilityFX = __webpack_require__(7);
	var cloudFX = __webpack_require__(8);
	var stormFX = __webpack_require__(9);
	var temperatureFX = __webpack_require__(10);
	var windFx = __webpack_require__(11);
	var g = __webpack_require__(12);


	function Instrument(sampleSet) {
	    this.trackSet = sampleSet;
	    this.toneSynth = new Tone.PolySynth(1, Tone.Sampler, sampleSet, {"envelope" : {"release" : 0.2}});
	    this.toneSynth.toMaster();
	    this.fxOn = false;
	    this.wind = new windFx();
	    Tone.Buffer.onload = function(){
	        g.setBuffer(true);
	        console.log("buffer :" + g.getBuffer())
	    }
	}


	Instrument.prototype = {
	    connectFX: function(weather) {
	        //windFx
	        this.wind.setFx(weather);

	        //disconnect any existing effect
	        this.toneSynth.disconnect();
	        
	        //change the bpm of Transport
	        this.BPM = temperatureFX(weather);
	        
	        //all other fx are regular ones to chain between the instrument and the Master
	        this.toneSynth.chain(
	            rainFX(weather),
	            humidityFX(weather),
	            visibilityFX(weather),
	            cloudFX(weather),
	            stormFX(weather),
	            Tone.Master
	        );
	        console.log("fx applied");
	        $(".onoffswitch-checkbox").prop('checked', true);
	        this.fxOn = true;
	    },
	    getTrackSetArray: function() {
	        var set = this.trackSet;
	        var setArray = [];
	        for (var key in set){
	            setArray.push(key);
	        }
	        return setArray;
	    },
	    disconnectFX: function(){
	        $(".onoffswitch-checkbox").prop('checked', false);
	        this.toneSynth.disconnect();
	        this.wind.noise.stop();
	        // this.wind.autoFilter.disconnect();
	    },
	    directToMaster: function() {
	        this.toneSynth.toMaster();
	    }
	};

	module.exports = Instrument;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var Tone = __webpack_require__(3);

	function rainFx(weather){
	    
	    var precipIntensity = weather.precipIntensity;
	    var precipProbability = weather.precipProbability;
	    console.log("precipIntensity: " + precipIntensity);
	    console.log("precipProbability: " + precipProbability);

	    var delayTime = 0;
	    var feedback = 0;
	    
	    if (precipIntensity) {
	        if (precipIntensity <= 0.002){
	            delayTime = "1n";
	        }
	        else if (precipIntensity <= 0.017){
	            delayTime = "2n";
	        }
	        else if (precipIntensity <= 0.002){
	            delayTime = "4n";
	        }
	        else if (precipIntensity <= 0.1){
	            delayTime = "8n";
	        }
	        else {
	            delayTime = "16n";
	        }
	    }

	    // if (precipProbability) feedback = precipProbability;
	    
	    console.log("--pingPong");
	    console.log("delayTime: "+delayTime);
	    console.log("feedback: "+feedback);
	    
	    var pingPong = new Tone.PingPongDelay(delayTime, feedback);
	    pingPong.wet.value = 0.35;
	    if (precipIntensity === 0) pingPong.wet.value=0;
	    return pingPong;
	}

	module.exports = rainFx;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// AUTOFILTER--------------------------------
	// "humidity":0.7, (A numerical value between 0 and 1 (inclusive) representing the relative humidity.)

	var Tone = __webpack_require__(3);

	function humidityFx(weather){
	    
	    var humidity = weather.humidity;
	    console.log("humidity: "+humidity);
	    var roomSize = 0;

	    // if (humidity) {
	    //     if (humidity <= 0.2){
	    //         frequency = "1n";
	    //     }
	    //     else if (humidity <= 0.4){
	    //         frequency = "2n";
	    //     }
	    //     else if (humidity <= 0.65){
	    //         frequency = "4n";
	    //     }
	    //     else if (humidity <= 0.8){
	    //         frequency = "8n";
	    //     }
	    //     else {
	    //         frequency = "16n";
	    //     }
	    // }
	    
	    roomSize = humidity * 0.5;
	    
	    console.log("--reverb");
	    console.log("roomSize: "+roomSize);
	    var reverb = new Tone.Freeverb(roomSize);
	    // reverb.dampening.value = 5000;
	    if (roomSize < 0.2) reverb.wet.value=0;
	    return reverb;
	    // var autoFilter = new Tone.AutoFilter(frequency);
	    // return autoFilter;
	}

	module.exports = humidityFx;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	// CHORUS-----------------------------------
	// "visibility":10, (In miles, max 10)


	// Tone.js
	// Chorus  Tone.StereoXFeedbackEffect
	// Tone.Chorus is a stereo chorus effect with feedback composed of a left and right delay with a Tone.LFO applied to the delayTime of each channel. Inspiration from Tuna.js. Read more on the chorus effect on SoundOnSound.
	// new Tone.Chorus ([frequency][, delayTime][, depth]) 
	//  .frequency ~ {Frequency} : The frequency of the LFO which modulates the delayTime.
	// .depth {NormalRange} :  The depth of the effect. A depth of 1 makes the delayTime modulate between 0 and 2*delayTime (centered around the delayTime).
	// .delayTime {Number} : The delayTime in milliseconds of the chorus. A larger delayTime will give a more pronounced effect. Nominal range a delayTime is between 2 and 20ms.


	var Tone = __webpack_require__(3);

	function visibilityFx(weather){
	    
	    var visibility = weather.visibility;
	    console.log("visibility: "+visibility);
	    var frequency = 0;
	    var delayTime = 0;
	    var depth = 0;
	    
	    if (visibility < 10)
	    {
	        frequency = (2 - (visibility/10)); // arbitrary set frequency between 1 and 2 
	        delayTime = (10 - visibility) * 2; // delayTime between 2 and 20
	        depth = (10 - visibility) / 10; // delayTime between 0 and 1
	    }
	    
	    console.log("--chorus");
	    console.log("frequency: " + frequency);
	    console.log("delayTime :" + delayTime);
	    console.log("depth :" +depth);
	    
	    var chorus = new Tone.Chorus (frequency, delayTime, depth) ;
	    return chorus;
	}

	module.exports = visibilityFx;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	// LOWPASS FILTER-------------------------------------
	// "cloudCover":0.6, (A numerical value between 0 and 1 (inclusive) representing the percentage of sky occluded by clouds.)

	// 0 corresponds to clear sky
	// 0.4 to scattered clouds
	// 0.75 to broken cloud cover
	// 1 to completely overcast skies.

	//  new Tone.Filter ([frequency][, type][, rolloff])
	// frequency {Frequency|Object}
	// The cutoff frequency of the filter.
	// type {string}
	// The type of filter.
	// rolloff {number}
	// The drop in decibels per octave after the cutoff frequency. 3 choices: -12, -24, and -48


	var Tone = __webpack_require__(3);

	function cloudFx(weather){
	    
	    var cloudCover = weather.cloudCover;
	    console.log("cloudCover: " + cloudCover);

	    var frequency = 44000;

	    if (cloudCover >= 0.3){
	        if (cloudCover < 0.4){
	            frequency = 5000;
	        }
	        else if (cloudCover < 0.5){
	            frequency = 4100;
	        }
	        else if (cloudCover < 0.6){
	            frequency = 3200;
	        }
	        else if (cloudCover < 0.7){
	            frequency = 2300;
	        }
	        else if (cloudCover < 0.8){
	            frequency = 1400;
	        }
	        else {
	            frequency = 500;
	        }
	    } 

	    console.log("--low pass filter");
	    console.log("frequency: "+frequency);
	    var filter = new Tone.Filter(frequency, "lowpass");
	    return filter;
	}

	module.exports = cloudFx;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	// "nearestStormDistance":55, (In miles.)

	//  new Tone.Distortion ([distortion])
	// distortion {Number|Object}
	// The amount of distortion (nominal range of 0-1)

	var Tone = __webpack_require__(3);

	function stormFx(weather){
	    
	    var nearestStormDistance = weather.nearestStormDistance;
	    console.log("nearestStormDistance: " + nearestStormDistance);

	    var amount = 0;

	    if (nearestStormDistance < 600 ) {
	        amount = 100 / (nearestStormDistance + 1);
	    }

	    console.log("--distortion");
	    console.log("amount: "+amount);
	    
	    var dist = new Tone.Distortion(amount);
	    dist.wet.value = 0.25;
	    // if (precipIntensity === 0) pingPong.wet.value=0;
	    return dist;
	}

	module.exports = stormFx;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// -------------------BPM
	// "temperature":55.25, (In F)
	// "apparentTemperature":55.25, (In F)

	// Temperature is affecting the bpm directly on the Transport


	var Tone = __webpack_require__(3);

	function temperature(weather){
	    var tempF = weather.temperature;
	    
	    var tempC = (tempF - 32)/1.8;
	    console.log("tempC: "+tempC);
	    
	    var newBPM = 120;

	    if (tempC < -30) {
	        newBPM = 150;
	    }
	    else if (tempC < -20){
	        newBPM = 142
	    }
	    else if (tempC < -15){
	        newBPM = 134
	    }
	    else if (tempC < -10){
	        newBPM = 126
	    }
	    else if (tempC < -5){
	        newBPM = 119
	    }
	    else if (tempC < 5){
	        newBPM = 112
	    }
	    else if (tempC < 10){
	        newBPM = 105
	    }
	    else if (tempC < 15){
	        newBPM = 98
	    }
	    else if (tempC < 20){
	        newBPM = 91
	    }
	    else if (tempC < 25){
	        newBPM = 84
	    }
	    else if (tempC < 30){
	        newBPM = 77
	    }
	    else {
	        newBPM = 70;
	    }
	    
	    console.log("--BPM: "+newBPM);
	    
	    Tone.Transport.bpm.value = newBPM;
	    return newBPM;
	}

	module.exports = temperature;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	// PHASER OR NOISE------------------------
	// "windSpeed":10.74, (Miles per hour)

	// new Tone.Noise (type)
	// type {string}
	// the noise type (white|pink|brown)

	var Tone = __webpack_require__(3);


	function windFx(){
	        
	    this.autoFilter = new Tone.AutoFilter({
	    	"frequency" : "1n", 
	    	"min" : 700, 
	    	"max" : 900
	    });
	    
	    this.isOn = false;
	    //initialize the noise and start
	    this.noise = new Tone.Noise("pink");
	    this.noise.volume.value = -60;
	    
	    this.autoFilter.start();
	    this.noise.chain(this.autoFilter,Tone.Master);
	}

	windFx.prototype = {
	    setFx:function(weather){
	        
	        var wind = weather.windSpeed;
	        console.log("wind: "+wind);
	        
	        var noiseVol = -60;
	        
	        if (wind > 0) {
	            noiseVol = -20 + wind;
	            this.isOn = true;
	            if (Tone.Transport.state === "started") this.noise.start();
	        }
	        else {
	            if (Tone.Transport.state === "started") this.noise.stop();
	            this.isOn = false;
	        }
	        
	        this.noise.volume.value = noiseVol;
	        console.log("noiseVol: " + this.noise.volume.value);
	    }
	};

	module.exports = windFx;

/***/ },
/* 12 */
/***/ function(module, exports) {

	var instrument = {empty: true};
	var weather = {empty: true};
	var buffer = false;
	var nexusReady = false;


	module.exports = {
	    getInstru: function(){return instrument;},
	    setInstru: function(i){instrument = i;},
	    getWeather: function(){return weather;},
	    setWeather: function(w){weather = w;},
	    getBuffer: function(){return buffer;},
	    setBuffer: function(b){buffer = b;},
	    getNexus: function(){return nexusReady;},
	    setNexus: function(n){nexusReady = n;},
	};


/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = {
	    Bulldog: {
	    	"Kick" : "./audio/bulldog/bulldog-kick.mp3",
	    	"Snare" : "./audio/bulldog/bulldog-snare.mp3",
	    	"Hi-Hat 1" : "./audio/bulldog/bulldog-hihat-1.mp3",
	    	"Hi-Hat 2" : "./audio/bulldog/bulldog-hihat-2.mp3",
	    	"Synth-1" : "./audio/bulldog/bulldog-synth-1.mp3",
	    	"Synth-2" : "./audio/bulldog/bulldog-synth-2.mp3",
	    	"Synth-3" : "./audio/bulldog/bulldog-synth-3.mp3",
	    	"Tom" :  "./audio/bulldog/bulldog-tom.mp3",
	    },
	    French_Toast: {
	    	"Kick" : "./audio/french-toast/french-toast-kick.mp3",
	    	"Snare" : "./audio/french-toast/french-toast-snare.mp3",
	    	"Hi-Hat" : "./audio/french-toast/french-toast-hihat.mp3",
	    	"Punch" : "./audio/french-toast/french-toast-punch.mp3",
	    	"C" : "./audio/juno-106/juno-106-c.mp3",
	    	"E" : "./audio/juno-106/juno-106-e.mp3",
	    	"G" : "./audio/juno-106/juno-106-g.mp3",
	    	"A" : "./audio/juno-106/juno-106-a.mp3",
	    },
	    Fame_Boy: {
	        "Kick" : "./audio/drum/kick.mp3",
	        "Snare" : "./audio/drum/snare.mp3",
	        "Hi-hat" : "./audio/drum/hihat.mp3",
	        "Tom" : "./audio/drum/tom.mp3",
	    	"A" : "./audio/casio/A1.mp3",
	    	"C#" : "./audio/casio/Cs2.mp3",
	    	"E" : "./audio/casio/E2.mp3",
	    	"F#" : "./audio/casio/Fs2.mp3",
	    },
	    Casio: {
	    	"C" : "./audio/casio/C2.mp3",
	    	"D" : "./audio/casio/D2.mp3",
	    	"E" : "./audio/casio/E2.mp3",
	    	"F" : "./audio/casio/F2.mp3",
	    	"G" : "./audio/casio/G2.mp3",
	    	"A" : "./audio/casio/A2.mp3",
	    	"B" : "./audio/casio/B1.mp3",
	    	"F#" : "./audio/casio/Fs2.mp3",
	    },
	    Juno_106: {
	    	"C" : "./audio/juno-106/juno-106-c.mp3",
	    	"D" : "./audio/juno-106/juno-106-d.mp3",
	    	"E" : "./audio/juno-106/juno-106-e.mp3",
	    	"F" : "./audio/juno-106/juno-106-f.mp3",
	    	"G" : "./audio/juno-106/juno-106-g.mp3",
	    	"A" : "./audio/juno-106/juno-106-a.mp3",
	    	"B" : "./audio/juno-106/juno-106-b.mp3",
	    	"C2"  : "./audio/juno-106/juno-106-c2.mp3",
	    },
	    Rhodes_Minor: {
	    	"A" : "./audio/rhodes-minor/rhodes-m-a.mp3",
	    	"B" : "./audio/rhodes-minor/rhodes-m-b.mp3",
	    	"C" : "./audio/rhodes-minor/rhodes-m-c.mp3",
	    	"D" : "./audio/rhodes-minor/rhodes-m-d.mp3",
	    	"E" : "./audio/rhodes-minor/rhodes-m-e.mp3",
	    	"F" : "./audio/rhodes-minor/rhodes-m-f.mp3",
	    	"G" : "./audio/rhodes-minor/rhodes-m-g.mp3",
	    	"A2" : "./audio/rhodes-minor/rhodes-m-a2.mp3",
	    },
	    Rhodes_Major: {
	    	"C" : "./audio/rhodes-major/rhodes-c.mp3",
	    	"D" : "./audio/rhodes-major/rhodes-d.mp3",
	    	"E" : "./audio/rhodes-major/rhodes-e.mp3",
	    	"F" : "./audio/rhodes-major/rhodes-f.mp3",
	    	"G" : "./audio/rhodes-major/rhodes-g.mp3",
	    	"A" : "./audio/rhodes-major/rhodes-a.mp3",
	    	"B" : "./audio/rhodes-major/rhodes-b.mp3",
	    	"C2": "./audio/rhodes-major/rhodes-c2.mp3",
	    },
	    Sine_Bass: {
	    	"C" : "./audio/sine-bass/sine-bass-c.mp3",
	    	"D" : "./audio/sine-bass/sine-bass-d.mp3",
	    	"E" : "./audio/sine-bass/sine-bass-e.mp3",
	    	"F" : "./audio/sine-bass/sine-bass-f.mp3",
	    	"G" : "./audio/sine-bass/sine-bass-g.mp3",
	    	"A" : "./audio/sine-bass/sine-bass-a.mp3",
	    	"B" : "./audio/sine-bass/sine-bass-b.mp3",
	    	"C2": "./audio/sine-bass/sine-bass-c2.mp3",
	    },
	    
	    
	    
	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	//functions that execute async operations
	var g = __webpack_require__(12);


	//get position of user from his browser
	function getUserLatLong() {
	    var $dfd = $.Deferred();

	    if (navigator.geolocation) {
	        navigator.geolocation.getCurrentPosition(function(position) {
	            var pos = {
	                lat: position.coords.latitude,
	                lng: position.coords.longitude
	            };
	            $dfd.resolve(pos);
	        },function(){
	            $("#searchTextField").val("").attr("placeholder","Select a location");
	        });
	    }
	    else {
	        $dfd.reject(new Error('API not available'));
	        $("#searchTextField").val("").attr("placeholder","Select a location");
	    }

	    return $dfd.promise();
	}



	//get city of a given location as a string for the search bar or as an object from getUserLatLong{lat:xx, lng:yy}
	function getPosition(data) {

	    var $dfd = $.Deferred();
	    var middleUrl = '';
	    var x = 0;
	    
	    if (typeof data === "string") {
	        middleUrl = "address=" + data;
	        x = 0;
	    }
	    else {
	        middleUrl = "latlng=" + data.lat + "," + data.lng;
	        x = 4;
	    }

	    var url = "https://maps.googleapis.com/maps/api/geocode/json?" + middleUrl + "&key=AIzaSyDmk5AKVdNHYCjGEv-UeAK0LOaiiCGP_DE";

	    $.ajax({
	        url: url,
	        datatype: "jsonp",
	        success: function(city) {
	            if (city.status === "OK") {
	                var position = city.results[0].geometry.location;
	                $("#searchTextField").val(city.results[x].formatted_address);
	                $dfd.resolve(position);
	            }
	            else {
	                $dfd.reject(new Error("An error has occurred: location cannot be found"));
	                shake("#searchTextField");
	                $("#searchTextField").val("").attr("placeholder","Invalid selection");
	            }
	        },
	        error: function(error) {
	            $dfd.reject(error);
	        }
	    });

	    return $dfd.promise();
	}


	//// Shake animation custom
	function shake(div){                                                                                                                                                                                            
	   var interval = 100;                                                                                                 
	   var distance = -10;                                                                                                  
	   var times = 4;                                                                                                      

	   $(div).css('position','relative');                                                                                  
	   for(var iter=0;iter<(times+1);iter++){                                                                              
	       $(div).animate({ 
	           left:((iter%2==0 ? distance : distance+15))
	           },interval);                                   
	   }                                                                                                             
	   $(div).animate({ left: 0},interval);                                                                                
	}

	function getWeather(pos) {

	    var $dfd = $.Deferred();

	    $.ajax({
	        url: "https://api.forecast.io/forecast/9cefef474c591d3e1ae766e338942cd9/" + pos.lat + "," + pos.lng,
	        dataType: "jsonp",
	        success: function(forecastInfo) {

	            var currentWeather = forecastInfo.currently;

	            g.setWeather(currentWeather);
	            //console.log(currentWeather);

	            $dfd.resolve(currentWeather);
	        },
	        error: function(error) {
	            $dfd.reject(error);
	        }
	    });

	    return $dfd.promise();
	}



	module.exports = {
	    getUserLatLong: getUserLatLong,
	    getPosition: getPosition,
	    getWeather: getWeather
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var Tone = __webpack_require__(3);


	function sequencer(Instrument){

		//keep track of steps and notes
		var stepNumber = 0;
		var noteNames = Instrument.getTrackSetArray();
		// console.log(noteNames);
		
		//the repeated callback
		Tone.Transport.setInterval(function(time){
			
			// get the notes at the step
			var column = matrix1.matrix[stepNumber];
			for (var i = 0; i < 8; i++){
				if (column[i] === 1){
					console.log(noteNames[i]);
					Instrument.toneSynth.triggerAttackRelease(noteNames[i], "32n", time);
				}
			}
			
			matrix1.jumpToCol(stepNumber);
			stepNumber++;
			stepNumber = stepNumber % 16;
			
		}, "16n");
		
		
		//transport settings
		Tone.Transport.loopEnd = "1m";
		Tone.Transport.loop = true;
	}

	module.exports = sequencer;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var Tone = __webpack_require__(3);
	var g = __webpack_require__(12);
	var async = __webpack_require__(14);
	var getLink = __webpack_require__(17);
	var sampleSet = __webpack_require__(13);
	var loadSequencer = __webpack_require__(15);
	var Instrument  = __webpack_require__(4);
	var decoder = __webpack_require__(18);

	//jQuery helpers
	$.fn.isOnScreen = function(){
	    var viewport = {};
	    viewport.top = $(window).scrollTop();
	    viewport.bottom = viewport.top + $(window).height();
	    var bounds = {};
	    bounds.top = this.offset().top;
	    bounds.bottom = bounds.top + this.outerHeight();
	    return ((bounds.top <= viewport.bottom) && (bounds.bottom >= viewport.top));
	};


	//// NEXUS UI SET UP
	function nexusSetting() {

	    var dialResponsivity = [dial1, dial2, dial3, dial4, dial5, dial6, dial7];
	    for (var i = 0; i < 7; i++) {
	        dialResponsivity[i].responsivity = 0;
	    }

	    nx.colorize("#0affea");
	    nx.colorize("fill", "#424242");

	    matrix1.col = 16;
	    matrix1.row = 8;
	    matrix1.init();
	    
	    //add a method to clear the sequencer
	    matrix1.clear = clear;

	    onResize();
	    decoder();
	    
	    g.setNexus(true);
	    
	    if (!g.getInstru().empty){
	        loadSequencer(g.getInstru());
	        loadPlayButtonHandler();
	    }
	    
	    if (!g.getWeather().empty) {
	        dialAnimationLauncher(g.getWeather());
	    }
	}



	function loadSearchHandlers() {
	    var $searchField = $("#searchTextField");

	    //// ACTION SEARCH INPUT
	    $searchField.on("keypress", function(e) {
	        if (e.keyCode === 13) {
	            setTimeout(function() {

	                async.getPosition($searchField.val())
	                    .then(async.getWeather)
	                    .then(function(weather){
	                        g.getInstru().connectFX(weather);
	                        dialAnimation(weather);
	                    });
	            }, 50);
	        }
	    });

	    $("body").on("mousedown", ".pac-container", function(e) {

	        setTimeout(function() {

	            async.getPosition($searchField.val())
	                .then(async.getWeather)
	                .then(function(weather){
	                    g.getInstru().connectFX(weather);
	                    dialAnimation(weather);
	                });
	        }, 50);
	    });
	}



	//// PLAY BUTTON
	function loadPlayButtonHandler() {

	    var playButton = $('#toggle1');
	    
	    playButton.active = false;
	    playButton.start = function() {
	        var instrument = g.getInstru();
	        if (instrument.wind.isOn && instrument.fxOn) instrument.wind.noise.start();
	        Tone.Transport.start();
	    };
	    playButton.stop = function() {
	        var instrument = g.getInstru();
	        if (instrument.wind.isOn) instrument.wind.noise.stop();
	        Tone.Transport.stop();
	    };
	    
	    function bufferNotification(){
	        var $message = messageToUser("Loading sounds");
	        
	        setInterval(function(){
	            if (g.getBuffer()) $message.fadeOut(100);
	        },500);
	       
	    }
	    
	    playButton.on('mousedown touchstart', function(e) {
	        
	        if (!playButton.active) {
	            if (g.getBuffer()){
	                playButton.active = true;
	                playButton.start();
	            }
	            else {
	                bufferNotification();
	            }
	        }
	        else {
	            playButton.active = false;
	            playButton.stop();
	        }
	    });

	    $(window).on("keydown", function(e) {
	        if (e.keyCode === 32) {
	            // if ($(window).scrollTop() <= 580) {
	            //     $(".arrow").trigger("click");
	            // }
	            // else {
	                if (!playButton.active) {
	                    if (g.getBuffer()){
	                        playButton.start();
	                        toggle1.val.value = 1;
	                        toggle1.draw();
	                        playButton.active = true;
	                    }
	                    else{
	                        bufferNotification();
	                    }
	                }
	                else {
	                    playButton.stop();
	                    toggle1.val.value = 0;
	                    toggle1.draw();
	                    playButton.active = false;
	                }
	            // }
	        }
	    });
	}


	function displayWeatherData(data) {
	    // TEMPERATURE
	    if (typeof data.temperature !== "number") {
	        $(".data1").text("n/a");
	        $(".data1m").text("n/a");
	    }
	    else {
	        $(".data1").text(Math.round(data.temperature) + "F");
	        $(".data1m").text(Math.round((data.temperature - 32) * (5 / 9)) + "C");
	    }
	    //PRECIPITATION
	    if (typeof data.precipIntensity !== "number") {
	        $(".data2").text("n/a");
	        $(".data2m").text("n/a");
	    }
	    else {
	        $(".data2").text(Math.round(data.precipIntensity * 1000) / 1000 + " in/h");
	        $(".data2m").text(Math.round((data.precipIntensity * 25.4)) + " mm/h");
	    }
	    //HUMIDITY
	    if (typeof data.humidity !== "number") {
	        $(".data3").text("n/a");
	    }
	    else {
	        $(".data3").text(Math.round(data.humidity * 100) + "%");
	    }
	    //WIND SPEED
	    if (typeof data.windSpeed !== "number") {
	        $(".data4").text("n/a");
	        $(".data4m").text("n/a");
	    }
	    else {
	        $(".data4").text(Math.round(data.windSpeed) + " mph");
	        $(".data4m").text(Math.round(data.windSpeed * 1.609344) + " km/h");
	    }
	    //VISIBILITY
	    if (typeof data.visibility !== "number") {
	        $(".data5").text("n/a");
	        $(".data5m").text("n/a");
	    }
	    else {
	        $(".data5").text(Math.round(data.visibility) + " mi");
	        $(".data5m").text(Math.round(data.visibility * 1.609344) + " km");
	    }
	    //CLOUD COVER
	    if (typeof data.cloudCover !== "number") {
	        $(".data6").text("n/a");
	    }
	    else {
	        $(".data6").text(Math.round(data.cloudCover * 100) + "%");
	    }
	    //NEAREST STORM
	    if (typeof data.nearestStormDistance !== "number") {
	        $(".data7").text("n/a");
	        $(".data7m").text("n/a");
	    }
	    else {
	        $(".data7").text(Math.round(data.nearestStormDistance) + " mi");
	        $(".data7m").text(Math.round(data.nearestStormDistance * 1.609344) + " km");
	    }
	}


	function dialAnimationLauncher(weather){
	    //handling FX UI Motion
	    var $dials = $(".console");
	    if ($dials.isOnScreen()) {
	        
	        dialAnimation(weather);
	    }
	    else {//if not currently on screen, add event to trigger when motion automatically
	        
	        var $window = $(window);
	        $window.on("scroll load", function dialDisplayHandler() {
	            if ($dials.isOnScreen())
	            {
	                dialAnimation(weather);
	                $window.unbind("scroll load",dialDisplayHandler);
	            }
	        });      
	    }
	}

	function dialAnimation(data) {
	    var $console = $(".console");
	    if ($console.isOnScreen())
	    {
	        displayWeatherData(data);
	    
	        var valueDial = [dial1, dial2, dial3, dial4, dial5, dial6, dial7];
	        for (var i = 0; i < valueDial.length; i++) {
	            valueDial[i].val.value = 0;
	        }
	    
	        var speed = [];
	        
	        for (var i = 0; i < 7; i++) {
	            speed[i] = (Math.round(Math.random() * 22) + 8) / 1500;
	        }
	        
	        //TEMPERATURE
	        var val1 = (data.temperature + 30) / 134;
	        if (data.temperature < -30 || typeof data.temperature !== "number") {
	            val1 = 0;
	            dial1.val.value = 0;
	            dial1.init();
	        }
	        else if (data.temperature > 104) {
	            val1 = 1;
	        }
	        var intDial1 = setInterval(function() {
	            if (dial1.val.value >= val1) {
	                dial1.val.value = val1;
	                dial1.init();
	                clearInterval(intDial1);
	            }
	            else {
	                dial1.val.value += speed[0];
	                dial1.init();
	            }
	        }, 20);
	        
	        //PRECIPITATION
	        var val2 = (data.precipIntensity * 10) / 2;
	        if (data.precipIntensity > 0.2) {
	            val2 = 1;
	        }
	        else if (typeof data.precipIntensity !== "number") {
	            val2 = 0;
	            dial2.val.value = 0;
	            dial2.init();
	        }
	        var intDial2 = setInterval(function() {
	            if (dial2.val.value >= val2) {
	                dial2.val.value = val2;
	                dial2.init();
	                clearInterval(intDial2);
	            }
	            else {
	                dial2.val.value += speed[1];;
	                dial2.init();
	            }
	        }, 20);
	        
	        //HUMIDITY
	        var val3 = data.humidity;
	        if (typeof data.humidity !== "number") {
	            val3 = 0;
	            dial3.val.value = 0;
	            dial3.init();
	        }
	        var intDial3 = setInterval(function() {
	            if (dial3.val.value >= val3) {
	                dial3.val.value = val3;
	                dial3.init();
	                clearInterval(intDial3);
	            }
	            else {
	                dial3.val.value += speed[2];
	                dial3.init();
	            }
	        }, 20);
	        
	        //WIND SPEED
	        var val4 = data.windSpeed / 40;
	        if (data.windSpeed > 40) {
	            val4 = 1;
	        }
	        else if (typeof data.windSpeed !== "number") {
	            val4 = 0;
	            dial4.val.value = 0;
	            dial4.init();
	        }
	        var intDial4 = setInterval(function() {
	            if (dial4.val.value >= val4) {
	                dial4.val.value = val4;
	                dial4.init();
	                clearInterval(intDial4);
	            }
	            else {
	                dial4.val.value += speed[3];
	                dial4.init();
	            }
	        }, 20);
	        
	        //VISIBILITY
	        var val5 = (data.visibility-10)/-10;
	        if (typeof data.visibility !== "number") {
	            val5 = 0;
	            dial5.val.value = 0;
	            dial5.init();
	        }
	        var intDial5 = setInterval(function() {
	            if (dial5.val.value >= val5) {
	                dial5.val.value = val5;
	                dial5.init();
	                clearInterval(intDial5);
	            }
	            else {
	                dial5.val.value += speed[4];
	                dial5.init();
	            }
	        }, 20);
	        
	        //CLOUD COVER
	        var val6 = data.cloudCover;
	        if (typeof data.cloudCover !== "number") {
	            val6 = 0;
	            dial6.val.value = 0;
	            dial6.init();
	        }
	        var intDial6 = setInterval(function() {
	            if (dial6.val.value >= val6) {
	                dial6.val.value = val6;
	                dial6.init();
	                clearInterval(intDial6);
	            }
	            else {
	                dial6.val.value += speed[5];
	                dial6.init();
	            }
	        }, 20);
	        
	        //NEAREST STORM 0 600
	        var val7 = 1 - (data.nearestStormDistance / 600);
	        if (data.nearestStormDistance > 600 || typeof data.nearestStormDistance !== "number") {
	            val7 = 0;
	            dial7.val.value = 0;
	            dial7.init();
	        }
	        var intDial7 = setInterval(function() {
	            if (dial7.val.value >= val7) {
	                dial7.val.value = val7;
	                dial7.init();
	                clearInterval(intDial7);
	            }
	            else {
	                dial7.val.value += speed[6];
	                dial7.init();
	            }
	        }, 20);
	    }
	}

	function mainDisplayAnimation() {

	    var $title = $(".title h1");
	    if ($title.isOnScreen())
	    {
	        //// INPUT ANIMATION
	        $("#searchTextField").animate({
	            width: "100%"
	        }, {
	            queue: false,
	            duration: 1000
	        });
	        //// 2ND TITLE ANIMATION
	        $title.animate({
	            opacity: 1
	        }, {
	            queue: false,
	            duration: 2000
	        });
	        //// TRACK NAMES ANIMATION
	        for (var i = 0; i <= 8; i++) {
	            var duration = Math.floor(Math.random() * 1001) + 2000;
	            $(".track-names p:nth-child(" + i + ")").animate({
	                opacity: 1
	            }, {
	                queue: false,
	                duration: duration
	            });
	        }
	    }
	    else //if not currently on screen, add event to trigger when motion automatically
	    {
	        var $window = $(window);
	        $window.on("scroll load", function mainDisplayHandler() {
	            if ($title.isOnScreen())
	            {
	                mainDisplayAnimation();
	                $window.unbind("scroll load",mainDisplayHandler);
	            }
	        });
	    }
	}

	//// TOGGLE IMPERIAL-METRIC
	$(".input").on("click", ".system", function() {
	    $(".switch").toggleClass("nodisplay");
	    ($(".system").text() === "Switch to metric system") ? $(".system").text("Switch to imperial system"): $(".system").text("Switch to metric system");
	});

	//// ON RESIZE
	function onResize(){
	    var widthWinInit = $(window).width();
	    $(window).on("resize", function() {
	        var widthMove  = widthWinInit - $(window).width();
	        widthWinInit = $(window).width();
	        
	        matrix1.resize(matrix1.width-widthMove,matrix1.height);
	        $("#matrix1").attr("width",matrix1.width).attr("height",matrix1.height);
	        matrix1.draw();
	        
	        $('#searchTextField').css("width", "100%");
	        // toggle1.resize($('.toggle-size').width(), $('.toggle-size').height());
	        toggle1.resize(toggle1.width-widthMove,toggle1.height);
	    });
	}

	//// SCROLL EFFECT
	$('a[href*=#]:not([href=#])').click(function() {

	    if (location.pathname.replace(/^\//, '') === this.pathname.replace(/^\//, '') || location.hostname == this.hostname) {
	        var target = $(this.hash);
	        target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
	        if (target.length) {
	            $('html,body').animate({
	                scrollTop: target.offset().top
	            }, 1000);
	            return false;
	        }
	    }
	});

	///SHARE LINK BUTTON
	$('.share').on('click', function() {
	    var link = getLink();
	    
	    var $overlay = $('<div class="overlay"></div>');
	    var $input = $('<input />');
	    
	    $overlay.append($input);
	    $('body').append($overlay);
	    $overlay.hide();
	    
	    
	    $input.attr("value", link);
	    $overlay.fadeIn(100);
	    
	    $(".overlay input").on("click", function(){
	        this.select();
	    });

	    $overlay.on('click', function(evt) {
	        if (evt.target === evt.currentTarget) {
	            $overlay.fadeOut(100);
	        }
	    });
	});

	//// SWITCH ON/OFF FX
	$('.onoffswitch-checkbox').on("click",function switchFX(){
	    if (!g.getInstru().empty){
	        var instrument = g.getInstru();
	        if (instrument.fxOn) {
	            instrument.disconnectFX();
	            instrument.directToMaster();
	            instrument.fxOn = false;
	        }
	        else {
	            if (!g.getWeather().empty) instrument.connectFX(g.getWeather());
	        }
	    }
	});

	/// CLEAR THE MATRIX
	function clear(){
	    var grid = this.matrix;
	    
	    for (var y = 0; y < grid.length; y++){
	        for (var x = 0; x < grid[y].length; x++){
	           this.setCell(y,x,0);   
	        }
	    }
	}

	$(".menu li.clear-sequencer").on("click",function clearSeq(){
	    if (matrix1) matrix1.clear();
	});

	/// DISPLAY TRACK NAMES
	function displayTrackNames(instrument){
	    var $trackBlock = $(".track-names");
	    var trackNames = instrument.getTrackSetArray();

	    $trackBlock.children().each(function(index,track){
	        $(track).text(trackNames[index]);
	    });
	}

	/// SELECT ANOTHER SOUND SET
	function loadNewTrackSet(Set){
	    
	    //Buffer unload;
	    g.setBuffer(false);
	    console.log("buffer :" + g.getBuffer())
	    var prevInstrument = g.getInstru();
	    //Disconnect the existing sounds from the master
	    prevInstrument.disconnectFX();

	    //Recreate a new instrument and connect it
	    var newInstrument = new Instrument(Set);
	    var weather = g.getWeather();
	    g.setInstru(newInstrument);
	    
	    displayTrackNames(newInstrument);
	    if (!g.getWeather().empty) {newInstrument.connectFX(weather);}
	    loadSequencer(newInstrument);
	}


	$(".menu .m2 li").on("click",function(){
	    
	    //Stop the sequencer if playing
	    var playButton = $('#toggle1');
	    toggle1.val.value = 0;
	    toggle1.draw();
	    playButton.active = false;
	    
	    var instrument = g.getInstru();
	    if (instrument.wind.isOn) instrument.wind.noise.stop();
	    Tone.Transport.stop();
	    
	    var $this = $(this);
	    var soundSet = $this.text();
	    if (sampleSet.hasOwnProperty(soundSet)) setTimeout(function() {loadNewTrackSet(sampleSet[soundSet]);}, 500);
	    else {
	        var $message = messageToUser("Sorry this soundset does not exist");
	        $message.on('click', function(evt) {
	            $message.fadeOut(100);
	        });
	    }
	})


	//// RELOAD URL ON ORIENTATION CHANGE
	$(window).on('orientationchange', function(e) {
	    var link = getLink();
	    window.location.href = link;
	    window.location.reload();
	});

	//// AUTOMATIC SELECT SEARCH INPUT
	$("#searchTextField").on("click", function(){
	    this.select();
	});

	//// Message to user with overlay
	function messageToUser(textToDisplay){
	    var $overlay = $('<div class="overlay"></div>');
	    var $p = $('<p>');
	    
	    $overlay.append($p);
	    $('body').append($overlay);
	    $overlay.hide();
	    
	    
	    $p.text(textToDisplay);
	    $overlay.fadeIn(100);
	    
	    return $overlay;
	}


	$(".track-names").children().on("click",function(){
	    var $this = $(this);
	    var note = $this.text();
	    var instrument = g.getInstru();
	    instrument.toneSynth.triggerAttackRelease(note, "32n");
	})


	module.exports = {
	    nexusSetting: nexusSetting,
	    dialAnimation: dialAnimation,
	    mainDisplayAnimation: mainDisplayAnimation,
	    loadSearchHandlers:loadSearchHandlers,
	    dialAnimationLauncher:dialAnimationLauncher,
	    loadPlayButtonHandler: loadPlayButtonHandler,
	    displayTrackNames:displayTrackNames
	};


/***/ },
/* 17 */
/***/ function(module, exports) {

	function getLink() {
	    //Convert null in array for 0
	    var melody = matrix1.matrix;
	 
	    for (var i = 0; i < melody.length; i++ ) {
	        for (var j = 0; j < melody[i].length; j++) {
	            // console.log('value : ', melody[i][j]);
	            if(!melody[i][j]) {melody[i][j] = 0;}
	        }
	    }
	    
	    // console.log('zzzzzzzzz ', JSON.stringify(melody));
	    
	    //Create string for urlHash
	    var urlHash = '';
	    for (var i = 0; i < 16; i++) {
	        urlHash += melody[i].join('');
	    }
	    
	    //create link for popup
	    var link = window.location+"/#"+urlHash; 
	    return link;   
	}



	module.exports = getLink;

		

/***/ },
/* 18 */
/***/ function(module, exports) {

	// Decode the urlHash
	function decoder() {
	    
	    if(window.location.hash !== "") { var loopHash = window.location.hash.substring(1); }
	    else { var loopHash = "10010000000000000001010000000000110100100000000000010000000000011001100000000001000100000000000011000000001000000001100000000100"; }
	    
	    for (var i = 0; i < 16; i++) {
	        for (var j = 0; j < 8; j++) {
	            if (loopHash[i*8 + j] === '1') {
	                matrix1.setCell(i, j, true);
	            }
	        }
	    }
	}

	module.exports = decoder;

/***/ }
/******/ ]);
